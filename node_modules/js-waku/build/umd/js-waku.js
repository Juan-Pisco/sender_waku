(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["jswaku"] = factory();
	else
		root["jswaku"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.proto = exports.StoreCodec = exports.WakuStore = exports.PageDirection = exports.waku_store = exports.RelayCodecs = exports.WakuRelay = exports.waku_relay = exports.PushResponse = exports.LightPushCodec = exports.WakuLightPush = exports.waku_light_push = exports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = exports.WakuMessage = exports.waku_message = exports.DefaultPubSubTopic = exports.Waku = exports.waku = exports.utils = exports.enr = exports.discovery = exports.getNodesFromHostedJson = void 0;
var discovery_1 = __webpack_require__(/*! ./lib/discovery */ "./src/lib/discovery/index.ts");
Object.defineProperty(exports, "getNodesFromHostedJson", ({ enumerable: true, get: function () { return discovery_1.getNodesFromHostedJson; } }));
exports.discovery = __importStar(__webpack_require__(/*! ./lib/discovery */ "./src/lib/discovery/index.ts"));
exports.enr = __importStar(__webpack_require__(/*! ./lib/enr */ "./src/lib/enr/index.ts"));
exports.utils = __importStar(__webpack_require__(/*! ./lib/utils */ "./src/lib/utils.ts"));
exports.waku = __importStar(__webpack_require__(/*! ./lib/waku */ "./src/lib/waku.ts"));
var waku_1 = __webpack_require__(/*! ./lib/waku */ "./src/lib/waku.ts");
Object.defineProperty(exports, "Waku", ({ enumerable: true, get: function () { return waku_1.Waku; } }));
Object.defineProperty(exports, "DefaultPubSubTopic", ({ enumerable: true, get: function () { return waku_1.DefaultPubSubTopic; } }));
exports.waku_message = __importStar(__webpack_require__(/*! ./lib/waku_message */ "./src/lib/waku_message/index.ts"));
var waku_message_1 = __webpack_require__(/*! ./lib/waku_message */ "./src/lib/waku_message/index.ts");
Object.defineProperty(exports, "WakuMessage", ({ enumerable: true, get: function () { return waku_message_1.WakuMessage; } }));
var version_1_1 = __webpack_require__(/*! ./lib/waku_message/version_1 */ "./src/lib/waku_message/version_1.ts");
Object.defineProperty(exports, "generatePrivateKey", ({ enumerable: true, get: function () { return version_1_1.generatePrivateKey; } }));
Object.defineProperty(exports, "generateSymmetricKey", ({ enumerable: true, get: function () { return version_1_1.generateSymmetricKey; } }));
Object.defineProperty(exports, "getPublicKey", ({ enumerable: true, get: function () { return version_1_1.getPublicKey; } }));
exports.waku_light_push = __importStar(__webpack_require__(/*! ./lib/waku_light_push */ "./src/lib/waku_light_push/index.ts"));
var waku_light_push_1 = __webpack_require__(/*! ./lib/waku_light_push */ "./src/lib/waku_light_push/index.ts");
Object.defineProperty(exports, "WakuLightPush", ({ enumerable: true, get: function () { return waku_light_push_1.WakuLightPush; } }));
Object.defineProperty(exports, "LightPushCodec", ({ enumerable: true, get: function () { return waku_light_push_1.LightPushCodec; } }));
Object.defineProperty(exports, "PushResponse", ({ enumerable: true, get: function () { return waku_light_push_1.PushResponse; } }));
exports.waku_relay = __importStar(__webpack_require__(/*! ./lib/waku_relay */ "./src/lib/waku_relay/index.ts"));
var waku_relay_1 = __webpack_require__(/*! ./lib/waku_relay */ "./src/lib/waku_relay/index.ts");
Object.defineProperty(exports, "WakuRelay", ({ enumerable: true, get: function () { return waku_relay_1.WakuRelay; } }));
Object.defineProperty(exports, "RelayCodecs", ({ enumerable: true, get: function () { return waku_relay_1.RelayCodecs; } }));
exports.waku_store = __importStar(__webpack_require__(/*! ./lib/waku_store */ "./src/lib/waku_store/index.ts"));
var waku_store_1 = __webpack_require__(/*! ./lib/waku_store */ "./src/lib/waku_store/index.ts");
Object.defineProperty(exports, "PageDirection", ({ enumerable: true, get: function () { return waku_store_1.PageDirection; } }));
Object.defineProperty(exports, "WakuStore", ({ enumerable: true, get: function () { return waku_store_1.WakuStore; } }));
Object.defineProperty(exports, "StoreCodec", ({ enumerable: true, get: function () { return waku_store_1.StoreCodec; } }));
exports.proto = __importStar(__webpack_require__(/*! ./proto */ "./src/proto/index.ts"));


/***/ }),

/***/ "./src/lib/discovery/bootstrap.ts":
/*!****************************************!*\
  !*** ./src/lib/discovery/bootstrap.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Bootstrap = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
const dns_1 = __webpack_require__(/*! ./dns */ "./src/lib/discovery/dns.ts");
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/discovery/index.ts");
const dbg = debug_1.default('waku:discovery:bootstrap');
/**
 * Parse options and expose function to return bootstrap peer addresses.
 */
class Bootstrap {
    constructor(opts) {
        const maxPeers = opts.maxPeers ?? Bootstrap.DefaultMaxPeers;
        if (opts.default) {
            dbg('Use hosted list of peers.');
            this.getBootstrapPeers = index_1.getNodesFromHostedJson.bind({}, undefined, undefined, maxPeers);
        }
        else if (opts.peers !== undefined && opts.peers.length > 0) {
            dbg('Use provided list of peers.');
            const allPeers = opts.peers.map((node) => new multiaddr_1.Multiaddr(node));
            const peers = index_1.getPseudoRandomSubset(allPeers, maxPeers);
            this.getBootstrapPeers = () => Promise.resolve(peers);
        }
        else if (typeof opts.getPeers === 'function') {
            dbg('Bootstrap: Use provided getPeers function.');
            const getPeers = opts.getPeers;
            this.getBootstrapPeers = async () => {
                const allPeers = await getPeers();
                return index_1.getPseudoRandomSubset(allPeers, maxPeers).map((node) => new multiaddr_1.Multiaddr(node));
            };
        }
        else if (opts.enrUrl) {
            const enrUrl = opts.enrUrl;
            dbg('Use provided EIP-1459 ENR Tree URL.');
            const dns = dns_1.DnsNodeDiscovery.dnsOverHttp();
            this.getBootstrapPeers = async () => {
                const enrs = await dns.getPeers(maxPeers, [enrUrl]);
                dbg(`Found ${enrs.length} peers`);
                return enrs.map((enr) => enr.getFullMultiaddrs()).flat();
            };
        }
        else {
            dbg('No bootstrap method specified, no peer will be returned');
            this.getBootstrapPeers = undefined;
        }
    }
}
exports.Bootstrap = Bootstrap;
Bootstrap.DefaultMaxPeers = 1;


/***/ }),

/***/ "./src/lib/discovery/dns.ts":
/*!**********************************!*\
  !*** ./src/lib/discovery/dns.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DnsNodeDiscovery = void 0;
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js"));
const debug_1 = __webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js");
const enr_1 = __webpack_require__(/*! ../enr */ "./src/lib/enr/index.ts");
const dns_over_https_1 = __webpack_require__(/*! ./dns_over_https */ "./src/lib/discovery/dns_over_https.ts");
const enrtree_1 = __webpack_require__(/*! ./enrtree */ "./src/lib/discovery/enrtree.ts");
const dbg = debug_1.debug('waku:discovery:dns');
class DnsNodeDiscovery {
    constructor(dns) {
        this._errorTolerance = 10;
        this._DNSTreeCache = {};
        this.dns = dns;
    }
    static dnsOverHttp(endpoints) {
        const dnsClient = new dns_over_https_1.DnsOverHttps(endpoints);
        return new DnsNodeDiscovery(dnsClient);
    }
    /**
     * Returns a list of verified peers listed in an EIP-1459 DNS tree. Method may
     * return fewer peers than requested if `maxQuantity` is larger than the number
     * of ENR records or the number of errors/duplicate peers encountered by randomized
     * search exceeds `maxQuantity` plus the `errorTolerance` factor.
     */
    async getPeers(maxQuantity, enrTreeUrls) {
        let totalSearches = 0;
        const peers = [];
        const networkIndex = Math.floor(Math.random() * enrTreeUrls.length);
        const { publicKey, domain } = enrtree_1.ENRTree.parseTree(enrTreeUrls[networkIndex]);
        while (peers.length < maxQuantity &&
            totalSearches < maxQuantity + this._errorTolerance) {
            const context = {
                domain,
                publicKey,
                visits: {},
            };
            const peer = await this._search(domain, context);
            if (peer && isNewPeer(peer, peers)) {
                peers.push(peer);
                dbg(`got new peer candidate from DNS address=${peer.nodeId}@${peer.ip}`);
            }
            totalSearches++;
        }
        return peers;
    }
    /**
     * Runs a recursive, randomized descent of the DNS tree to retrieve a single
     * ENR record as an ENR. Returns null if parsing or DNS resolution fails.
     */
    async _search(subdomain, context) {
        const entry = await this._getTXTRecord(subdomain, context);
        context.visits[subdomain] = true;
        let next;
        let branches;
        const entryType = getEntryType(entry);
        try {
            switch (entryType) {
                case enrtree_1.ENRTree.ROOT_PREFIX:
                    next = enrtree_1.ENRTree.parseAndVerifyRoot(entry, context.publicKey);
                    return await this._search(next, context);
                case enrtree_1.ENRTree.BRANCH_PREFIX:
                    branches = enrtree_1.ENRTree.parseBranch(entry);
                    next = selectRandomPath(branches, context);
                    return await this._search(next, context);
                case enrtree_1.ENRTree.RECORD_PREFIX:
                    return enr_1.ENR.decodeTxt(entry);
                default:
                    return null;
            }
        }
        catch (error) {
            dbg(`Failed to search DNS tree ${entryType} at subdomain ${subdomain}: ${error}`);
            return null;
        }
    }
    /**
     * Retrieves the TXT record stored at a location from either
     * this DNS tree cache or via DNS query
     */
    async _getTXTRecord(subdomain, context) {
        if (this._DNSTreeCache[subdomain]) {
            return this._DNSTreeCache[subdomain];
        }
        // Location is either the top level tree entry host or a subdomain of it.
        const location = subdomain !== context.domain
            ? `${subdomain}.${context.domain}`
            : context.domain;
        const response = await this.dns.resolveTXT(location);
        assert_1.default(response.length, 'Received empty result array while fetching TXT record');
        assert_1.default(response[0].length, 'Received empty TXT record');
        // Branch entries can be an array of strings of comma delimited subdomains, with
        // some subdomain strings split across the array elements
        const result = response.join('');
        this._DNSTreeCache[subdomain] = result;
        return result;
    }
}
exports.DnsNodeDiscovery = DnsNodeDiscovery;
function getEntryType(entry) {
    if (entry.startsWith(enrtree_1.ENRTree.ROOT_PREFIX))
        return enrtree_1.ENRTree.ROOT_PREFIX;
    if (entry.startsWith(enrtree_1.ENRTree.BRANCH_PREFIX))
        return enrtree_1.ENRTree.BRANCH_PREFIX;
    if (entry.startsWith(enrtree_1.ENRTree.RECORD_PREFIX))
        return enrtree_1.ENRTree.RECORD_PREFIX;
    return '';
}
/**
 * Returns a randomly selected subdomain string from the list provided by a branch
 * entry record.
 *
 * The client must track subdomains which are already resolved to avoid
 * going into an infinite loop b/c branch entries can contain
 * circular references. It’s in the client’s best interest to traverse the
 * tree in random order.
 */
function selectRandomPath(branches, context) {
    // Identify domains already visited in this traversal of the DNS tree.
    // Then filter against them to prevent cycles.
    const circularRefs = {};
    for (const [idx, subdomain] of branches.entries()) {
        if (context.visits[subdomain]) {
            circularRefs[idx] = true;
        }
    }
    // If all possible paths are circular...
    if (Object.keys(circularRefs).length === branches.length) {
        throw new Error('Unresolvable circular path detected');
    }
    // Randomly select a viable path
    let index;
    do {
        index = Math.floor(Math.random() * branches.length);
    } while (circularRefs[index]);
    return branches[index];
}
/**
 * @returns false if candidate peer already exists in the
 *         current collection of peers based on the node id value;
 *         true otherwise.
 */
function isNewPeer(peer, peers) {
    if (!peer || !peer.nodeId)
        return false;
    for (const existingPeer of peers) {
        if (peer.nodeId === existingPeer.nodeId) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "./src/lib/discovery/dns_over_https.ts":
/*!*********************************************!*\
  !*** ./src/lib/discovery/dns_over_https.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DnsOverHttps = void 0;
const dns_query_1 = __webpack_require__(/*! dns-query */ "./node_modules/dns-query/index.js");
const { cloudflare, google, opendns } = dns_query_1.endpoints;
class DnsOverHttps {
    /**
     * Create new Dns-Over-Http DNS client.
     *
     * @param endpoints The endpoints for Dns-Over-Https queries.
     * See [dns-query](https://www.npmjs.com/package/dns-query) for details.
     * Defaults to cloudflare, google and opendns.
     *
     * @throws {code: string} If DNS query fails.
     */
    constructor(endpoints = [cloudflare, google, opendns]) {
        this.endpoints = endpoints;
    }
    async resolveTXT(domain) {
        const response = await dns_query_1.query({
            questions: [{ type: 'TXT', name: domain }],
        });
        const answers = response.answers;
        const data = answers.map((a) => a.data);
        const result = [];
        data.forEach((d) => {
            if (typeof d === 'string') {
                result.push(d);
            }
            else if (Array.isArray(d)) {
                d.forEach((sd) => {
                    if (typeof sd === 'string') {
                        result.push(sd);
                    }
                    else {
                        result.push(Buffer.from(sd).toString('utf-8'));
                    }
                });
            }
            else {
                result.push(Buffer.from(d).toString('utf-8'));
            }
        });
        return result;
    }
}
exports.DnsOverHttps = DnsOverHttps;


/***/ }),

/***/ "./src/lib/discovery/enrtree.ts":
/*!**************************************!*\
  !*** ./src/lib/discovery/enrtree.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENRTree = void 0;
const assert_1 = __importDefault(__webpack_require__(/*! assert */ "./node_modules/assert/build/assert.js"));
const base64url_1 = __importDefault(__webpack_require__(/*! base64url */ "./node_modules/base64url/index.js"));
const base32 = __importStar(__webpack_require__(/*! hi-base32 */ "./node_modules/hi-base32/src/base32.js"));
const secp256k1_1 = __webpack_require__(/*! secp256k1 */ "./node_modules/secp256k1/elliptic.js");
const enr_1 = __webpack_require__(/*! ../enr */ "./src/lib/enr/index.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
class ENRTree {
    /**
     * Extracts the branch subdomain referenced by a DNS tree root string after verifying
     * the root record signature with its base32 compressed public key.
     */
    static parseAndVerifyRoot(root, publicKey) {
        assert_1.default(root.startsWith(this.ROOT_PREFIX), `ENRTree root entry must start with '${this.ROOT_PREFIX}'`);
        const rootValues = ENRTree.parseRootValues(root);
        const decodedPublicKey = base32.decode.asBytes(publicKey);
        // The signature is a 65-byte secp256k1 over the keccak256 hash
        // of the record content, excluding the `sig=` part, encoded as URL-safe base64 string
        // (Trailing recovery bit must be trimmed to pass `ecdsaVerify` method)
        const signedComponent = root.split(' sig')[0];
        const signedComponentBuffer = Buffer.from(signedComponent);
        const signatureBuffer = base64url_1.default
            .toBuffer(rootValues.signature)
            .slice(0, 64);
        const keyBuffer = Buffer.from(decodedPublicKey);
        const isVerified = secp256k1_1.ecdsaVerify(signatureBuffer, utils_1.keccak256Buf(signedComponentBuffer), keyBuffer);
        assert_1.default(isVerified, 'Unable to verify ENRTree root signature');
        return rootValues.eRoot;
    }
    static parseRootValues(txt) {
        const matches = txt.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\d+) sig=([^ ]+)$/);
        assert_1.default.ok(Array.isArray(matches), 'Could not parse ENRTree root entry');
        matches.shift(); // The first entry is the full match
        const [eRoot, lRoot, seq, signature] = matches;
        assert_1.default.ok(eRoot, "Could not parse 'e' value from ENRTree root entry");
        assert_1.default.ok(lRoot, "Could not parse 'l' value from ENRTree root entry");
        assert_1.default.ok(seq, "Could not parse 'seq' value from ENRTree root entry");
        assert_1.default.ok(signature, "Could not parse 'sig' value from ENRTree root entry");
        return { eRoot, lRoot, seq: Number(seq), signature };
    }
    /**
     * Returns the public key and top level domain of an ENR tree entry.
     * The domain is the starting point for traversing a set of linked DNS TXT records
     * and the public key is used to verify the root entry record
     */
    static parseTree(tree) {
        assert_1.default(tree.startsWith(this.TREE_PREFIX), `ENRTree tree entry must start with '${this.TREE_PREFIX}'`);
        const matches = tree.match(/^enrtree:\/\/([^@]+)@(.+)$/);
        assert_1.default.ok(Array.isArray(matches), 'Could not parse ENRTree tree entry');
        matches.shift(); // The first entry is the full match
        const [publicKey, domain] = matches;
        assert_1.default.ok(publicKey, 'Could not parse public key from ENRTree tree entry');
        assert_1.default.ok(domain, 'Could not parse domain from ENRTree tree entry');
        return { publicKey, domain };
    }
    /**
     * Returns subdomains listed in an ENR branch entry. These in turn lead to
     * either further branch entries or ENR records.
     */
    static parseBranch(branch) {
        assert_1.default(branch.startsWith(this.BRANCH_PREFIX), `ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);
        return branch.split(this.BRANCH_PREFIX)[1].split(',');
    }
}
exports.ENRTree = ENRTree;
ENRTree.RECORD_PREFIX = enr_1.ENR.RECORD_PREFIX;
ENRTree.TREE_PREFIX = 'enrtree:';
ENRTree.BRANCH_PREFIX = 'enrtree-branch:';
ENRTree.ROOT_PREFIX = 'enrtree-root:';


/***/ }),

/***/ "./src/lib/discovery/hosted_json.ts":
/*!******************************************!*\
  !*** ./src/lib/discovery/hosted_json.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNodesFromHostedJson = void 0;
/**
 * GET list of nodes from remote HTTP host.
 *
 * Default behavior is to return nodes hosted by Status.
 *
 * @param path The property path to access the node list. The result should be
 * a string, a string array or an object. If the result is an object then the
 * values of the objects are used as multiaddresses. For example, if the GET
 * request returns `{ foo: { bar: [address1, address2] } }` then `path` should be
 * `[ "foo", "bar" ]`.
 * @param url Remote host containing bootstrap peers in JSON format.
 * @param wantedNumber The number of connections desired. Defaults to [DefaultWantedNumber].
 *
 * @returns An array of multiaddresses.
 * @throws If the remote host is unreachable or the response cannot be parsed
 * according to the passed _path_.
 */
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "./node_modules/axios/index.js"));
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/discovery/index.ts");
const dbg = debug_1.default('waku:discovery');
const DefaultWantedNumber = 1;
async function getNodesFromHostedJson(path = ['fleets', 'wakuv2.prod', 'waku-websocket'], url = 'https://fleets.status.im/', wantedNumber = DefaultWantedNumber) {
    if (wantedNumber <= 0) {
        return [];
    }
    const res = await axios_1.default.get(url, {
        headers: { 'Content-Type': 'application/json' },
    });
    let nodes = res.data;
    for (const prop of path) {
        if (nodes[prop] === undefined) {
            dbg(`Failed to retrieve bootstrap nodes: ${prop} does not exist on `, nodes);
            throw `Failed to retrieve bootstrap nodes: ${prop} does not exist on ${JSON.stringify(nodes)}`;
        }
        nodes = nodes[prop];
    }
    if (Array.isArray(nodes)) {
        return index_1.getPseudoRandomSubset(nodes, wantedNumber).map((node) => new multiaddr_1.Multiaddr(node));
    }
    if (typeof nodes === 'string') {
        return [new multiaddr_1.Multiaddr(nodes)];
    }
    if (typeof nodes === 'object') {
        nodes = Object.values(nodes);
        nodes = nodes.map((node) => new multiaddr_1.Multiaddr(node));
        return index_1.getPseudoRandomSubset(nodes, wantedNumber);
    }
    throw `Failed to retrieve bootstrap nodes: response format is not supported: ${JSON.stringify(nodes)}`;
}
exports.getNodesFromHostedJson = getNodesFromHostedJson;


/***/ }),

/***/ "./src/lib/discovery/index.ts":
/*!************************************!*\
  !*** ./src/lib/discovery/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPseudoRandomSubset = exports.ENRTree = exports.DnsOverHttps = exports.DnsNodeDiscovery = exports.Bootstrap = exports.getNodesFromHostedJson = void 0;
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
var hosted_json_1 = __webpack_require__(/*! ./hosted_json */ "./src/lib/discovery/hosted_json.ts");
Object.defineProperty(exports, "getNodesFromHostedJson", ({ enumerable: true, get: function () { return hosted_json_1.getNodesFromHostedJson; } }));
var bootstrap_1 = __webpack_require__(/*! ./bootstrap */ "./src/lib/discovery/bootstrap.ts");
Object.defineProperty(exports, "Bootstrap", ({ enumerable: true, get: function () { return bootstrap_1.Bootstrap; } }));
var dns_1 = __webpack_require__(/*! ./dns */ "./src/lib/discovery/dns.ts");
Object.defineProperty(exports, "DnsNodeDiscovery", ({ enumerable: true, get: function () { return dns_1.DnsNodeDiscovery; } }));
var dns_over_https_1 = __webpack_require__(/*! ./dns_over_https */ "./src/lib/discovery/dns_over_https.ts");
Object.defineProperty(exports, "DnsOverHttps", ({ enumerable: true, get: function () { return dns_over_https_1.DnsOverHttps; } }));
var enrtree_1 = __webpack_require__(/*! ./enrtree */ "./src/lib/discovery/enrtree.ts");
Object.defineProperty(exports, "ENRTree", ({ enumerable: true, get: function () { return enrtree_1.ENRTree; } }));
function getPseudoRandomSubset(values, wantedNumber) {
    if (values.length <= wantedNumber) {
        return values;
    }
    return utils_1.shuffle(values).slice(0, wantedNumber);
}
exports.getPseudoRandomSubset = getPseudoRandomSubset;


/***/ }),

/***/ "./src/lib/enr/constants.ts":
/*!**********************************!*\
  !*** ./src/lib/enr/constants.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MULTIADDR_LENGTH_SIZE = exports.ERR_NO_SIGNATURE = exports.ERR_INVALID_ID = exports.MAX_RECORD_SIZE = void 0;
// Maximum encoded size of an ENR
exports.MAX_RECORD_SIZE = 300;
exports.ERR_INVALID_ID = 'Invalid record id';
exports.ERR_NO_SIGNATURE = 'No valid signature found';
// The maximum length of byte size of a multiaddr to encode in the `multiaddr` field
// The size is a big endian 16-bit unsigned integer
exports.MULTIADDR_LENGTH_SIZE = 2;


/***/ }),

/***/ "./src/lib/enr/create.ts":
/*!*******************************!*\
  !*** ./src/lib/enr/create.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createNodeId = void 0;
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
function createNodeId(buffer) {
    if (buffer.length !== 32) {
        throw new Error('NodeId must be 32 bytes in length');
    }
    return utils_1.bufToHex(buffer);
}
exports.createNodeId = createNodeId;


/***/ }),

/***/ "./src/lib/enr/enr.ts":
/*!****************************!*\
  !*** ./src/lib/enr/enr.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENR = void 0;
const base64url_1 = __importDefault(__webpack_require__(/*! base64url */ "./node_modules/base64url/index.js"));
const bigint_buffer_1 = __webpack_require__(/*! bigint-buffer */ "./node_modules/bigint-buffer/dist/browser.js");
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const convert_1 = __importDefault(__webpack_require__(/*! multiaddr/src/convert */ "./node_modules/multiaddr/src/convert.js"));
const RLP = __importStar(__webpack_require__(/*! rlp */ "./node_modules/rlp/dist.browser/index.js"));
const varint_1 = __webpack_require__(/*! varint */ "./node_modules/varint/index.js");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/lib/enr/constants.ts");
const keypair_1 = __webpack_require__(/*! ./keypair */ "./src/lib/enr/keypair/index.ts");
const v4 = __importStar(__webpack_require__(/*! ./v4 */ "./src/lib/enr/v4.ts"));
class ENR extends Map {
    constructor(kvs = {}, seq = 1n, signature = null) {
        super(Object.entries(kvs));
        this.seq = seq;
        this.signature = signature;
    }
    static createV4(publicKey, kvs = {}) {
        return new ENR({
            ...kvs,
            id: Buffer.from('v4'),
            secp256k1: publicKey,
        });
    }
    static createFromPeerId(peerId, kvs = {}) {
        const keypair = keypair_1.createKeypairFromPeerId(peerId);
        switch (keypair.type) {
            case keypair_1.KeypairType.secp256k1:
                return ENR.createV4(keypair.publicKey, kvs);
            default:
                throw new Error();
        }
    }
    static decodeFromValues(decoded) {
        if (!Array.isArray(decoded)) {
            throw new Error('Decoded ENR must be an array');
        }
        if (decoded.length % 2 !== 0) {
            throw new Error('Decoded ENR must have an even number of elements');
        }
        const [signature, seq, ...kvs] = decoded;
        if (!signature || Array.isArray(signature)) {
            throw new Error('Decoded ENR invalid signature: must be a byte array');
        }
        if (!seq || Array.isArray(seq)) {
            throw new Error('Decoded ENR invalid sequence number: must be a byte array');
        }
        const obj = {};
        for (let i = 0; i < kvs.length; i += 2) {
            obj[kvs[i].toString()] = Buffer.from(kvs[i + 1]);
        }
        const enr = new ENR(obj, bigint_buffer_1.toBigIntBE(seq), signature);
        if (!enr.verify(RLP.encode([seq, ...kvs]), signature)) {
            throw new Error('Unable to verify ENR signature');
        }
        return enr;
    }
    static decode(encoded) {
        const decoded = RLP.decode(encoded);
        return ENR.decodeFromValues(decoded);
    }
    static decodeTxt(encoded) {
        if (!encoded.startsWith(this.RECORD_PREFIX)) {
            throw new Error(`"string encoded ENR must start with '${this.RECORD_PREFIX}'`);
        }
        return ENR.decode(base64url_1.default.toBuffer(encoded.slice(4)));
    }
    set(k, v) {
        this.signature = null;
        this.seq++;
        return super.set(k, v);
    }
    get id() {
        const id = this.get('id');
        if (!id)
            throw new Error('id not found.');
        return id.toString('utf8');
    }
    get keypairType() {
        switch (this.id) {
            case 'v4':
                return keypair_1.KeypairType.secp256k1;
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
    }
    get publicKey() {
        switch (this.id) {
            case 'v4':
                return this.get('secp256k1');
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
    }
    get keypair() {
        return keypair_1.createKeypair(this.keypairType, undefined, this.publicKey);
    }
    get peerId() {
        return keypair_1.createPeerIdFromKeypair(this.keypair);
    }
    get nodeId() {
        switch (this.id) {
            case 'v4':
                return v4.nodeId(this.publicKey);
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
    }
    get ip() {
        const raw = this.get('ip');
        if (raw) {
            return convert_1.default.toString(multiaddr_1.protocols.names.ip4.code, raw);
        }
        else {
            return undefined;
        }
    }
    set ip(ip) {
        if (ip) {
            this.set('ip', convert_1.default.toBytes(multiaddr_1.protocols.names.ip4.code, ip));
        }
        else {
            this.delete('ip');
        }
    }
    get tcp() {
        const raw = this.get('tcp');
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.tcp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set tcp(port) {
        if (port === undefined) {
            this.delete('tcp');
        }
        else {
            this.set('tcp', convert_1.default.toBytes(multiaddr_1.protocols.names.tcp.code, port));
        }
    }
    get udp() {
        const raw = this.get('udp');
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.udp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set udp(port) {
        if (port === undefined) {
            this.delete('udp');
        }
        else {
            this.set('udp', convert_1.default.toBytes(multiaddr_1.protocols.names.udp.code, port));
        }
    }
    get ip6() {
        const raw = this.get('ip6');
        if (raw) {
            return convert_1.default.toString(multiaddr_1.protocols.names.ip6.code, raw);
        }
        else {
            return undefined;
        }
    }
    set ip6(ip) {
        if (ip) {
            this.set('ip6', convert_1.default.toBytes(multiaddr_1.protocols.names.ip6.code, ip));
        }
        else {
            this.delete('ip6');
        }
    }
    get tcp6() {
        const raw = this.get('tcp6');
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.tcp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set tcp6(port) {
        if (port === undefined) {
            this.delete('tcp6');
        }
        else {
            this.set('tcp6', convert_1.default.toBytes(multiaddr_1.protocols.names.tcp.code, port));
        }
    }
    get udp6() {
        const raw = this.get('udp6');
        if (raw) {
            return Number(convert_1.default.toString(multiaddr_1.protocols.names.udp.code, raw));
        }
        else {
            return undefined;
        }
    }
    set udp6(port) {
        if (port === undefined) {
            this.delete('udp6');
        }
        else {
            this.set('udp6', convert_1.default.toBytes(multiaddr_1.protocols.names.udp.code, port));
        }
    }
    /**
     * Get the `multiaddrs` field from ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of [[getLocationMultiaddr]] should be preferred.
     *
     * The multiaddresses stored in this field are expected to be location multiaddresses, ie, peer id less.
     */
    get multiaddrs() {
        const raw = this.get('multiaddrs');
        if (raw) {
            const multiaddrs = [];
            try {
                let index = 0;
                while (index < raw.length) {
                    const sizeBytes = raw.slice(index, index + 2);
                    const size = Buffer.from(sizeBytes).readUInt16BE(0);
                    const multiaddrBytes = raw.slice(index + constants_1.MULTIADDR_LENGTH_SIZE, index + size + constants_1.MULTIADDR_LENGTH_SIZE);
                    const multiaddr = new multiaddr_1.Multiaddr(multiaddrBytes);
                    multiaddrs.push(multiaddr);
                    index += size + constants_1.MULTIADDR_LENGTH_SIZE;
                }
            }
            catch (e) {
                throw new Error('Invalid value in multiaddrs field');
            }
            return multiaddrs;
        }
        else {
            return undefined;
        }
    }
    /**
     * Set the `multiaddrs` field on the ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of [[setLocationMultiaddr]] should be preferred.
     *
     * The multiaddresses stored in this field must to be location multiaddresses, ie, peer id less.
     */
    set multiaddrs(multiaddrs) {
        if (multiaddrs === undefined) {
            this.delete('multiaddrs');
        }
        else {
            let multiaddrsBuf = Buffer.from([]);
            multiaddrs.forEach((multiaddr) => {
                if (multiaddr.getPeerId())
                    throw new Error('`multiaddr` field MUST not contain peer id');
                const bytes = multiaddr.bytes;
                let buf = Buffer.alloc(2);
                // Prepend the size of the next entry
                const written = buf.writeUInt16BE(bytes.length, 0);
                if (written !== constants_1.MULTIADDR_LENGTH_SIZE) {
                    throw new Error(`Internal error: unsigned 16-bit integer was not written in ${constants_1.MULTIADDR_LENGTH_SIZE} bytes`);
                }
                buf = Buffer.concat([buf, bytes]);
                multiaddrsBuf = Buffer.concat([multiaddrsBuf, buf]);
            });
            this.set('multiaddrs', multiaddrsBuf);
        }
    }
    getLocationMultiaddr(protocol) {
        if (protocol === 'udp') {
            return (this.getLocationMultiaddr('udp4') || this.getLocationMultiaddr('udp6'));
        }
        if (protocol === 'tcp') {
            return (this.getLocationMultiaddr('tcp4') || this.getLocationMultiaddr('tcp6'));
        }
        const isIpv6 = protocol.endsWith('6');
        const ipVal = this.get(isIpv6 ? 'ip6' : 'ip');
        if (!ipVal) {
            return undefined;
        }
        const isUdp = protocol.startsWith('udp');
        const isTcp = protocol.startsWith('tcp');
        let protoName, protoVal;
        if (isUdp) {
            protoName = 'udp';
            protoVal = isIpv6 ? this.get('udp6') : this.get('udp');
        }
        else if (isTcp) {
            protoName = 'tcp';
            protoVal = isIpv6 ? this.get('tcp6') : this.get('tcp');
        }
        else {
            return undefined;
        }
        if (!protoVal) {
            return undefined;
        }
        // Create raw multiaddr buffer
        // multiaddr length is:
        //  1 byte for the ip protocol (ip4 or ip6)
        //  N bytes for the ip address
        //  1 or 2 bytes for the protocol as buffer (tcp or udp)
        //  2 bytes for the port
        const ipMa = multiaddr_1.protocols.names[isIpv6 ? 'ip6' : 'ip4'];
        const ipByteLen = ipMa.size / 8;
        const protoMa = multiaddr_1.protocols.names[protoName];
        const protoBuf = varint_1.encode(protoMa.code);
        const maBuf = new Uint8Array(3 + ipByteLen + protoBuf.length);
        maBuf[0] = ipMa.code;
        maBuf.set(ipVal, 1);
        maBuf.set(protoBuf, 1 + ipByteLen);
        maBuf.set(protoVal, 1 + ipByteLen + protoBuf.length);
        return new multiaddr_1.Multiaddr(maBuf);
    }
    setLocationMultiaddr(multiaddr) {
        const protoNames = multiaddr.protoNames();
        if (protoNames.length !== 2 &&
            protoNames[1] !== 'udp' &&
            protoNames[1] !== 'tcp') {
            throw new Error('Invalid multiaddr');
        }
        const tuples = multiaddr.tuples();
        if (!tuples[0][1] || !tuples[1][1]) {
            throw new Error('Invalid multiaddr');
        }
        // IPv4
        if (tuples[0][0] === 4) {
            this.set('ip', tuples[0][1]);
            this.set(protoNames[1], tuples[1][1]);
        }
        else {
            this.set('ip6', tuples[0][1]);
            this.set(protoNames[1] + '6', tuples[1][1]);
        }
    }
    /**
     * Returns the full multiaddr from the ENR fields matching the provided
     * `protocol` parameter.
     * To return full multiaddrs from the `multiaddrs` ENR field,
     * use [[ENR.getFullMultiaddrs]]
     *
     * @param protocol
     */
    getFullMultiaddr(protocol) {
        const locationMultiaddr = this.getLocationMultiaddr(protocol);
        if (locationMultiaddr) {
            return locationMultiaddr.encapsulate(`/p2p/${this.peerId.toB58String()}`);
        }
        return;
    }
    /**
     * Returns the full multiaddrs from the `multiaddrs` ENR field.
     */
    getFullMultiaddrs() {
        if (this.multiaddrs) {
            return this.multiaddrs.map((ma) => {
                return ma.encapsulate(`/p2p/${this.peerId.toB58String()}`);
            });
        }
        return [];
    }
    verify(data, signature) {
        if (!this.get('id') || this.id !== 'v4') {
            throw new Error(constants_1.ERR_INVALID_ID);
        }
        if (!this.publicKey) {
            throw new Error('Failed to verify ENR: No public key');
        }
        return v4.verify(this.publicKey, data, signature);
    }
    sign(data, privateKey) {
        switch (this.id) {
            case 'v4':
                this.signature = v4.sign(privateKey, data);
                break;
            default:
                throw new Error(constants_1.ERR_INVALID_ID);
        }
        return this.signature;
    }
    encodeToValues(privateKey) {
        // sort keys and flatten into [k, v, k, v, ...]
        const content = Array.from(this.keys())
            .sort((a, b) => a.localeCompare(b))
            .map((k) => [k, this.get(k)])
            .flat();
        content.unshift(Number(this.seq));
        if (privateKey) {
            content.unshift(this.sign(RLP.encode(content), privateKey));
        }
        else {
            if (!this.signature) {
                throw new Error(constants_1.ERR_NO_SIGNATURE);
            }
            content.unshift(this.signature);
        }
        return content;
    }
    encode(privateKey) {
        const encoded = RLP.encode(this.encodeToValues(privateKey));
        if (encoded.length >= constants_1.MAX_RECORD_SIZE) {
            throw new Error('ENR must be less than 300 bytes');
        }
        return encoded;
    }
    encodeTxt(privateKey) {
        return ENR.RECORD_PREFIX + base64url_1.default.encode(this.encode(privateKey));
    }
}
exports.ENR = ENR;
ENR.RECORD_PREFIX = 'enr:';


/***/ }),

/***/ "./src/lib/enr/index.ts":
/*!******************************!*\
  !*** ./src/lib/enr/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.v4 = void 0;
const v4Crypto = __importStar(__webpack_require__(/*! ./v4 */ "./src/lib/enr/v4.ts"));
exports.v4 = v4Crypto;
__exportStar(__webpack_require__(/*! ./constants */ "./src/lib/enr/constants.ts"), exports);
__exportStar(__webpack_require__(/*! ./enr */ "./src/lib/enr/enr.ts"), exports);
__exportStar(__webpack_require__(/*! ./types */ "./src/lib/enr/types.ts"), exports);
__exportStar(__webpack_require__(/*! ./create */ "./src/lib/enr/create.ts"), exports);
__exportStar(__webpack_require__(/*! ./keypair */ "./src/lib/enr/keypair/index.ts"), exports);


/***/ }),

/***/ "./src/lib/enr/keypair/constants.ts":
/*!******************************************!*\
  !*** ./src/lib/enr/keypair/constants.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ERR_INVALID_KEYPAIR_TYPE = exports.ERR_TYPE_NOT_IMPLEMENTED = void 0;
exports.ERR_TYPE_NOT_IMPLEMENTED = 'Keypair type not implemented';
exports.ERR_INVALID_KEYPAIR_TYPE = 'Invalid keypair type';


/***/ }),

/***/ "./src/lib/enr/keypair/index.ts":
/*!**************************************!*\
  !*** ./src/lib/enr/keypair/index.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createKeypairFromPeerId = exports.createPeerIdFromKeypair = exports.createKeypair = exports.generateKeypair = void 0;
const libp2p_crypto_1 = __webpack_require__(/*! libp2p-crypto */ "./node_modules/libp2p-crypto/src/index.js");
const multihashes_1 = __importDefault(__webpack_require__(/*! multihashes */ "./node_modules/multihashes/src/index.js"));
const peer_id_1 = __importDefault(__webpack_require__(/*! peer-id */ "./node_modules/peer-id/src/index.js"));
const { keysPBM, supportedKeys } = libp2p_crypto_1.keys;
const constants_1 = __webpack_require__(/*! ./constants */ "./src/lib/enr/keypair/constants.ts");
const secp256k1_1 = __webpack_require__(/*! ./secp256k1 */ "./src/lib/enr/keypair/secp256k1.ts");
const types_1 = __webpack_require__(/*! ./types */ "./src/lib/enr/keypair/types.ts");
__exportStar(__webpack_require__(/*! ./types */ "./src/lib/enr/keypair/types.ts"), exports);
__exportStar(__webpack_require__(/*! ./secp256k1 */ "./src/lib/enr/keypair/secp256k1.ts"), exports);
async function generateKeypair(type) {
    switch (type) {
        case types_1.KeypairType.secp256k1:
            return await secp256k1_1.Secp256k1Keypair.generate();
        default:
            throw new Error(constants_1.ERR_TYPE_NOT_IMPLEMENTED);
    }
}
exports.generateKeypair = generateKeypair;
function createKeypair(type, privateKey, publicKey) {
    switch (type) {
        case types_1.KeypairType.secp256k1:
            return new secp256k1_1.Secp256k1Keypair(privateKey, publicKey);
        default:
            throw new Error(constants_1.ERR_TYPE_NOT_IMPLEMENTED);
    }
}
exports.createKeypair = createKeypair;
function createPeerIdFromKeypair(keypair) {
    switch (keypair.type) {
        case types_1.KeypairType.secp256k1: {
            // manually create a peer id to avoid expensive ops
            const privKey = keypair.hasPrivateKey()
                ? new supportedKeys.secp256k1.Secp256k1PrivateKey(keypair.privateKey, keypair.publicKey)
                : undefined;
            const pubKey = new supportedKeys.secp256k1.Secp256k1PublicKey(keypair.publicKey);
            const id = multihashes_1.default.encode(pubKey.bytes, 'identity');
            return new peer_id_1.default(id, privKey, pubKey);
        }
        default:
            throw new Error(constants_1.ERR_TYPE_NOT_IMPLEMENTED);
    }
}
exports.createPeerIdFromKeypair = createPeerIdFromKeypair;
function createKeypairFromPeerId(peerId) {
    // pub/private key bytes from peer-id are encoded in protobuf format
    const pub = keysPBM.PublicKey.decode(peerId.pubKey.bytes);
    return createKeypair(pub.Type, peerId.privKey ? Buffer.from(peerId.privKey.marshal()) : undefined, Buffer.from(pub.Data));
}
exports.createKeypairFromPeerId = createKeypairFromPeerId;


/***/ }),

/***/ "./src/lib/enr/keypair/secp256k1.ts":
/*!******************************************!*\
  !*** ./src/lib/enr/keypair/secp256k1.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Secp256k1Keypair = exports.secp256k1PublicKeyToRaw = exports.secp256k1PublicKeyToFull = exports.secp256k1PublicKeyToCompressed = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js"));
const secp256k1 = __importStar(__webpack_require__(/*! secp256k1 */ "./node_modules/secp256k1/elliptic.js"));
const types_1 = __webpack_require__(/*! ./types */ "./src/lib/enr/keypair/types.ts");
function secp256k1PublicKeyToCompressed(publicKey) {
    if (publicKey.length === 64) {
        publicKey = buffer_1.Buffer.concat([buffer_1.Buffer.from([4]), publicKey]);
    }
    return buffer_1.Buffer.from(secp256k1.publicKeyConvert(publicKey, true));
}
exports.secp256k1PublicKeyToCompressed = secp256k1PublicKeyToCompressed;
function secp256k1PublicKeyToFull(publicKey) {
    if (publicKey.length === 64) {
        return buffer_1.Buffer.concat([buffer_1.Buffer.from([4]), publicKey]);
    }
    return buffer_1.Buffer.from(secp256k1.publicKeyConvert(publicKey, false));
}
exports.secp256k1PublicKeyToFull = secp256k1PublicKeyToFull;
function secp256k1PublicKeyToRaw(publicKey) {
    return buffer_1.Buffer.from(secp256k1.publicKeyConvert(publicKey, false).slice(1));
}
exports.secp256k1PublicKeyToRaw = secp256k1PublicKeyToRaw;
const Secp256k1Keypair = class Secp256k1Keypair extends types_1.AbstractKeypair {
    constructor(privateKey, publicKey) {
        let pub = publicKey;
        if (pub) {
            pub = secp256k1PublicKeyToCompressed(pub);
        }
        super(privateKey, pub);
        this.type = types_1.KeypairType.secp256k1;
    }
    static async generate() {
        const privateKey = buffer_1.Buffer.from(await randomBytes(32));
        const publicKey = secp256k1.publicKeyCreate(privateKey);
        return new Secp256k1Keypair(privateKey, buffer_1.Buffer.from(publicKey));
    }
    privateKeyVerify(key = this._privateKey) {
        if (key) {
            return secp256k1.privateKeyVerify(key);
        }
        return true;
    }
    publicKeyVerify(key = this._publicKey) {
        if (key) {
            return secp256k1.publicKeyVerify(key);
        }
        return true;
    }
    sign(msg) {
        const { signature, recid } = secp256k1.ecdsaSign(msg, this.privateKey);
        return buffer_1.Buffer.concat([signature, buffer_1.Buffer.from([recid])]);
    }
    verify(msg, sig) {
        return secp256k1.ecdsaVerify(sig, msg, this.publicKey);
    }
};
exports.Secp256k1Keypair = Secp256k1Keypair;
function randomBytes(length) {
    if (typeof window !== 'undefined' && window && window.crypto) {
        const array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return array;
    }
    else {
        return crypto_1.default.randomBytes(length);
    }
}


/***/ }),

/***/ "./src/lib/enr/keypair/types.ts":
/*!**************************************!*\
  !*** ./src/lib/enr/keypair/types.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractKeypair = exports.KeypairType = void 0;
var KeypairType;
(function (KeypairType) {
    KeypairType[KeypairType["rsa"] = 0] = "rsa";
    KeypairType[KeypairType["ed25519"] = 1] = "ed25519";
    KeypairType[KeypairType["secp256k1"] = 2] = "secp256k1";
})(KeypairType = exports.KeypairType || (exports.KeypairType = {}));
class AbstractKeypair {
    constructor(privateKey, publicKey) {
        if ((this._privateKey = privateKey) && !this.privateKeyVerify()) {
            throw new Error('Invalid private key');
        }
        if ((this._publicKey = publicKey) && !this.publicKeyVerify()) {
            throw new Error('Invalid private key');
        }
    }
    get privateKey() {
        if (!this._privateKey) {
            throw new Error();
        }
        return this._privateKey;
    }
    get publicKey() {
        if (!this._publicKey) {
            throw new Error();
        }
        return this._publicKey;
    }
    privateKeyVerify() {
        return true;
    }
    publicKeyVerify() {
        return true;
    }
    hasPrivateKey() {
        return Boolean(this._privateKey);
    }
}
exports.AbstractKeypair = AbstractKeypair;


/***/ }),

/***/ "./src/lib/enr/types.ts":
/*!******************************!*\
  !*** ./src/lib/enr/types.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Custom and aliased types for ENRs
Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./src/lib/enr/v4.ts":
/*!***************************!*\
  !*** ./src/lib/enr/v4.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ENRKeyPair = exports.nodeId = exports.verify = exports.sign = exports.publicKey = exports.createPrivateKey = exports.hash = void 0;
const crypto_1 = __importDefault(__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js"));
const js_sha3_1 = __webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js");
const secp256k1 = __importStar(__webpack_require__(/*! secp256k1 */ "./node_modules/secp256k1/elliptic.js"));
const create_1 = __webpack_require__(/*! ./create */ "./src/lib/enr/create.ts");
function hash(input) {
    return Buffer.from(js_sha3_1.keccak256.arrayBuffer(input));
}
exports.hash = hash;
async function createPrivateKey() {
    return Buffer.from(await randomBytes(32));
}
exports.createPrivateKey = createPrivateKey;
function publicKey(privKey) {
    return Buffer.from(secp256k1.publicKeyCreate(privKey));
}
exports.publicKey = publicKey;
function sign(privKey, msg) {
    const { signature } = secp256k1.ecdsaSign(hash(msg), privKey);
    return Buffer.from(signature);
}
exports.sign = sign;
function verify(pubKey, msg, sig) {
    // Remove the recovery id if present (byte #65)
    return secp256k1.ecdsaVerify(sig.slice(0, 64), hash(msg), pubKey);
}
exports.verify = verify;
function nodeId(pubKey) {
    const uncompressedPubkey = secp256k1.publicKeyConvert(pubKey, false);
    return create_1.createNodeId(hash(uncompressedPubkey.slice(1)));
}
exports.nodeId = nodeId;
class ENRKeyPair {
    constructor(nodeId, privateKey, publicKey) {
        this.nodeId = nodeId;
        this.privateKey = privateKey;
        this.publicKey = publicKey;
    }
    static async create(privateKey) {
        if (privateKey) {
            if (!secp256k1.privateKeyVerify(privateKey)) {
                throw new Error('Invalid private key');
            }
        }
        const _privateKey = privateKey || (await createPrivateKey());
        const _publicKey = publicKey(_privateKey);
        const _nodeId = nodeId(_publicKey);
        return new ENRKeyPair(_nodeId, _privateKey, _publicKey);
    }
    sign(msg) {
        return sign(this.privateKey, msg);
    }
    verify(msg, sig) {
        return verify(this.publicKey, msg, sig);
    }
}
exports.ENRKeyPair = ENRKeyPair;
function randomBytes(length) {
    if (typeof window !== 'undefined' && window && window.crypto) {
        const array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return array;
    }
    else {
        return crypto_1.default.randomBytes(length);
    }
}


/***/ }),

/***/ "./src/lib/select_peer.ts":
/*!********************************!*\
  !*** ./src/lib/select_peer.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPeersForProtocol = exports.selectRandomPeer = void 0;
/**
 * Returns a pseudo-random peer that supports the given protocol.
 * Useful for protocols such as store and light push
 */
function selectRandomPeer(peers) {
    if (peers.length === 0)
        return;
    const index = Math.round(Math.random() * (peers.length - 1));
    return peers[index];
}
exports.selectRandomPeer = selectRandomPeer;
/**
 * Returns the list of peers that supports the given protocol.
 */
function getPeersForProtocol(libp2p, protocol) {
    return Array.from(libp2p.peerStore.peers.values()).filter((peer) => peer.protocols.includes(protocol));
}
exports.getPeersForProtocol = getPeersForProtocol;


/***/ }),

/***/ "./src/lib/utils.ts":
/*!**************************!*\
  !*** ./src/lib/utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keccak256Buf = exports.equalByteArrays = exports.bufToHex = exports.hexToBuf = void 0;
const js_sha3_1 = __webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js");
function hexToBuf(hex) {
    if (typeof hex === 'string') {
        return Buffer.from(hex.replace(/^0x/i, ''), 'hex');
    }
    else {
        return Buffer.from(hex);
    }
}
exports.hexToBuf = hexToBuf;
function bufToHex(buf) {
    const _buf = Buffer.from(buf);
    return _buf.toString('hex');
}
exports.bufToHex = bufToHex;
function equalByteArrays(a, b) {
    let aBuf;
    let bBuf;
    if (typeof a === 'string') {
        aBuf = hexToBuf(a);
    }
    else {
        aBuf = Buffer.from(a);
    }
    if (typeof b === 'string') {
        bBuf = hexToBuf(b);
    }
    else {
        bBuf = Buffer.from(b);
    }
    return aBuf.compare(bBuf) === 0;
}
exports.equalByteArrays = equalByteArrays;
function keccak256Buf(message) {
    return Buffer.from(js_sha3_1.keccak256.arrayBuffer(message));
}
exports.keccak256Buf = keccak256Buf;


/***/ }),

/***/ "./src/lib/waku.ts":
/*!*************************!*\
  !*** ./src/lib/waku.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Waku = exports.DefaultPubSubTopic = exports.DefaultRelayKeepAliveValueSecs = exports.DefaultPingKeepAliveValueSecs = void 0;
const noise_1 = __webpack_require__(/*! @chainsafe/libp2p-noise/dist/src/noise */ "./node_modules/@chainsafe/libp2p-noise/dist/src/noise.js");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const libp2p_1 = __importDefault(__webpack_require__(/*! libp2p */ "./node_modules/libp2p/src/index.js"));
const libp2p_bootstrap_1 = __importDefault(__webpack_require__(/*! libp2p-bootstrap */ "./node_modules/libp2p-bootstrap/src/index.js"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_mplex_1 = __importDefault(__webpack_require__(/*! libp2p-mplex */ "./node_modules/libp2p-mplex/src/index.js"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const libp2p_websockets_1 = __importDefault(__webpack_require__(/*! libp2p-websockets */ "./node_modules/libp2p-websockets/src/index.js"));
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
const filters_1 = __importDefault(__webpack_require__(/*! libp2p-websockets/src/filters */ "./node_modules/libp2p-websockets/src/filters.js"));
const ping_1 = __importDefault(__webpack_require__(/*! libp2p/src/ping */ "./node_modules/libp2p/src/ping/index.js"));
const multiaddr_1 = __webpack_require__(/*! multiaddr */ "./node_modules/multiaddr/src/index.js");
const peer_id_1 = __importDefault(__webpack_require__(/*! peer-id */ "./node_modules/peer-id/src/index.js"));
const discovery_1 = __webpack_require__(/*! ./discovery */ "./src/lib/discovery/index.ts");
const select_peer_1 = __webpack_require__(/*! ./select_peer */ "./src/lib/select_peer.ts");
const waku_light_push_1 = __webpack_require__(/*! ./waku_light_push */ "./src/lib/waku_light_push/index.ts");
const waku_message_1 = __webpack_require__(/*! ./waku_message */ "./src/lib/waku_message/index.ts");
const waku_relay_1 = __webpack_require__(/*! ./waku_relay */ "./src/lib/waku_relay/index.ts");
const constants_1 = __webpack_require__(/*! ./waku_relay/constants */ "./src/lib/waku_relay/constants.ts");
const waku_store_1 = __webpack_require__(/*! ./waku_store */ "./src/lib/waku_store/index.ts");
const websocketsTransportKey = libp2p_websockets_1.default.prototype[Symbol.toStringTag];
exports.DefaultPingKeepAliveValueSecs = 0;
exports.DefaultRelayKeepAliveValueSecs = 5 * 60;
/**
 * DefaultPubSubTopic is the default gossipsub topic to use for Waku.
 */
exports.DefaultPubSubTopic = '/waku/2/default-waku/proto';
const dbg = debug_1.default('waku:waku');
class Waku {
    constructor(options, libp2p, store, lightPush) {
        this.libp2p = libp2p;
        this.relay = libp2p.pubsub;
        this.store = store;
        this.lightPush = lightPush;
        this.pingKeepAliveTimers = {};
        this.relayKeepAliveTimers = {};
        const pingKeepAlive = options.pingKeepAlive || exports.DefaultPingKeepAliveValueSecs;
        const relayKeepAlive = options.relayKeepAlive || exports.DefaultRelayKeepAliveValueSecs;
        libp2p.connectionManager.on('peer:connect', (connection) => {
            this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);
        });
        libp2p.connectionManager.on('peer:disconnect', (connection) => {
            this.stopKeepAlive(connection.remotePeer);
        });
        options?.decryptionKeys?.forEach((key) => {
            this.addDecryptionKey(key);
        });
    }
    /**
     * Create new waku node
     *
     * @param options Takes the same options than `Libp2p`.
     */
    static async create(options) {
        // Get an object in case options or libp2p are undefined
        const libp2pOpts = Object.assign({}, options?.libp2p);
        // Default for Websocket filter is `all`:
        // Returns all TCP and DNS based addresses, both with ws or wss.
        libp2pOpts.config = Object.assign({
            transport: {
                [websocketsTransportKey]: {
                    filter: filters_1.default.all,
                },
            },
        }, options?.libp2p?.config);
        // Pass pubsub topic to relay
        if (options?.pubSubTopic) {
            libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);
        }
        libp2pOpts.modules = Object.assign({}, options?.libp2p?.modules);
        // Default transport for libp2p is Websockets
        libp2pOpts.modules = Object.assign({
            transport: [libp2p_websockets_1.default],
        }, options?.libp2p?.modules);
        // streamMuxer, connection encryption and pubsub are overridden
        // as those are the only ones currently supported by Waku nodes.
        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
            streamMuxer: [libp2p_mplex_1.default],
            connEncryption: [new noise_1.Noise(options?.staticNoiseKey)],
            pubsub: waku_relay_1.WakuRelay,
        });
        if (options?.bootstrap) {
            const bootstrap = new discovery_1.Bootstrap(options?.bootstrap);
            if (bootstrap.getBootstrapPeers !== undefined) {
                try {
                    const list = await bootstrap.getBootstrapPeers();
                    // Note: this overrides any other peer discover
                    libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                        peerDiscovery: [libp2p_bootstrap_1.default],
                    });
                    libp2pOpts.config.peerDiscovery = {
                        [libp2p_bootstrap_1.default.tag]: {
                            list,
                            enabled: true,
                        },
                    };
                }
                catch (e) {
                    dbg('Failed to retrieve bootstrap nodes', e);
                }
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore: modules property is correctly set thanks to voodoo
        const libp2p = await libp2p_1.default.create(libp2pOpts);
        const wakuStore = new waku_store_1.WakuStore(libp2p, {
            pubSubTopic: options?.pubSubTopic,
        });
        const wakuLightPush = new waku_light_push_1.WakuLightPush(libp2p);
        await libp2p.start();
        return new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush);
    }
    /**
     * Dials to the provided peer.
     *
     * @param peer The peer to dial
     */
    async dial(peer) {
        return this.libp2p.dialProtocol(peer, [waku_store_1.StoreCodec].concat(waku_relay_1.RelayCodecs));
    }
    /**
     * Add peer to address book, it will be auto-dialed in the background.
     */
    addPeerToAddressBook(peerId, multiaddrs) {
        let peer;
        if (typeof peerId === 'string') {
            peer = peer_id_1.default.createFromB58String(peerId);
        }
        else {
            peer = peerId;
        }
        const addresses = multiaddrs.map((addr) => {
            if (typeof addr === 'string') {
                return multiaddr_1.multiaddr(addr);
            }
            else {
                return addr;
            }
        });
        this.libp2p.peerStore.addressBook.set(peer, addresses);
    }
    async stop() {
        return this.libp2p.stop();
    }
    /**
     * Register a decryption key to attempt decryption of messages received via
     * [[WakuRelay]] and [[WakuStore]]. This can either be a private key for
     * asymmetric encryption or a symmetric key.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.relay.addDecryptionKey(key, options);
        this.store.addDecryptionKey(key, options);
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received via [[WakuRelay]] or [[WakuStore]].
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.relay.deleteDecryptionKey(key);
        this.store.deleteDecryptionKey(key);
    }
    /**
     * Return the local multiaddr with peer id on which libp2p is listening.
     * @throws if libp2p is not listening on localhost
     */
    getLocalMultiaddrWithID() {
        const localMultiaddr = this.libp2p.multiaddrs.find((addr) => addr.toString().match(/127\.0\.0\.1/));
        if (!localMultiaddr || localMultiaddr.toString() === '') {
            throw 'Not listening on localhost';
        }
        return localMultiaddr + '/p2p/' + this.libp2p.peerId.toB58String();
    }
    /**
     * Wait to be connected to a peer. Useful when using the [[CreateOptions.bootstrap]]
     * with [[Waku.create]]. The Promise resolves only once we are connected to a
     * Store peer, Relay peer and Light Push peer.
     */
    async waitForConnectedPeer() {
        const desiredProtocols = [[waku_store_1.StoreCodec], [waku_light_push_1.LightPushCodec], waku_relay_1.RelayCodecs];
        await Promise.all(desiredProtocols.map((desiredProtocolVersions) => {
            const peers = new Array();
            desiredProtocolVersions.forEach((proto) => {
                select_peer_1.getPeersForProtocol(this.libp2p, proto).forEach((peer) => peers.push(peer));
            });
            if (peers.length > 0) {
                return Promise.resolve();
            }
            else {
                // No peer available for this protocol, waiting to connect to one.
                return new Promise((resolve) => {
                    this.libp2p.peerStore.on('change:protocols', ({ protocols: connectedPeerProtocols }) => {
                        desiredProtocolVersions.forEach((desiredProto) => {
                            if (connectedPeerProtocols.includes(desiredProto)) {
                                dbg('Resolving for', desiredProto, connectedPeerProtocols);
                                resolve();
                            }
                        });
                    });
                });
            }
        }));
    }
    startKeepAlive(peerId, pingPeriodSecs, relayPeriodSecs) {
        // Just in case a timer already exist for this peer
        this.stopKeepAlive(peerId);
        const peerIdStr = peerId.toB58String();
        if (pingPeriodSecs !== 0) {
            this.pingKeepAliveTimers[peerIdStr] = setInterval(() => {
                ping_1.default(this.libp2p, peerId);
            }, pingPeriodSecs * 1000);
        }
        if (relayPeriodSecs !== 0) {
            this.relayKeepAliveTimers[peerIdStr] = setInterval(() => {
                waku_message_1.WakuMessage.fromBytes(new Uint8Array(), constants_1.RelayPingContentTopic).then((wakuMsg) => this.relay.send(wakuMsg));
            }, relayPeriodSecs * 1000);
        }
    }
    stopKeepAlive(peerId) {
        const peerIdStr = peerId.toB58String();
        if (this.pingKeepAliveTimers[peerIdStr]) {
            clearInterval(this.pingKeepAliveTimers[peerIdStr]);
            delete this.pingKeepAliveTimers[peerIdStr];
        }
        if (this.relayKeepAliveTimers[peerIdStr]) {
            clearInterval(this.relayKeepAliveTimers[peerIdStr]);
            delete this.relayKeepAliveTimers[peerIdStr];
        }
    }
}
exports.Waku = Waku;


/***/ }),

/***/ "./src/lib/waku_light_push/index.ts":
/*!******************************************!*\
  !*** ./src/lib/waku_light_push/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuLightPush = exports.PushResponse = exports.LightPushCodec = void 0;
const it_concat_1 = __importDefault(__webpack_require__(/*! it-concat */ "./node_modules/it-concat/index.js"));
const it_length_prefixed_1 = __importDefault(__webpack_require__(/*! it-length-prefixed */ "./node_modules/it-length-prefixed/src/index.js"));
const it_pipe_1 = __importDefault(__webpack_require__(/*! it-pipe */ "./node_modules/it-pipe/index.js"));
const light_push_1 = __webpack_require__(/*! ../../proto/waku/v2/light_push */ "./src/proto/waku/v2/light_push.ts");
Object.defineProperty(exports, "PushResponse", ({ enumerable: true, get: function () { return light_push_1.PushResponse; } }));
const select_peer_1 = __webpack_require__(/*! ../select_peer */ "./src/lib/select_peer.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const push_rpc_1 = __webpack_require__(/*! ./push_rpc */ "./src/lib/waku_light_push/push_rpc.ts");
exports.LightPushCodec = '/vac/waku/lightpush/2.0.0-beta1';
/**
 * Implements the [Waku v2 Light Push protocol](https://rfc.vac.dev/spec/19/).
 */
class WakuLightPush {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options?.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = waku_1.DefaultPubSubTopic;
        }
    }
    async push(message, opts) {
        let peer;
        if (opts?.peerId) {
            peer = this.libp2p.peerStore.get(opts.peerId);
            if (!peer)
                throw 'Peer is unknown';
        }
        else {
            peer = this.randomPeer;
        }
        if (!peer)
            throw 'No peer available';
        if (!peer.protocols.includes(exports.LightPushCodec))
            throw 'Peer does not register waku light push protocol';
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection)
            throw 'Failed to get a connection to the peer';
        const { stream } = await connection.newStream(exports.LightPushCodec);
        try {
            const pubSubTopic = opts?.pubSubTopic
                ? opts.pubSubTopic
                : this.pubSubTopic;
            const query = push_rpc_1.PushRPC.createRequest(message, pubSubTopic);
            const res = await it_pipe_1.default([query.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);
            try {
                const response = push_rpc_1.PushRPC.decode(res.slice()).response;
                if (!response) {
                    console.log('No response in PushRPC');
                    return null;
                }
                return response;
            }
            catch (err) {
                console.log('Failed to decode push reply', err);
            }
        }
        catch (err) {
            console.log('Failed to send waku light push request', err);
        }
        return null;
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * light push protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        return select_peer_1.getPeersForProtocol(this.libp2p, exports.LightPushCodec);
    }
    /**
     * Returns a random peer that supports light push protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return select_peer_1.selectRandomPeer(this.peers);
    }
}
exports.WakuLightPush = WakuLightPush;


/***/ }),

/***/ "./src/lib/waku_light_push/push_rpc.ts":
/*!*********************************************!*\
  !*** ./src/lib/waku_light_push/push_rpc.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushRPC = void 0;
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const proto = __importStar(__webpack_require__(/*! ../../proto/waku/v2/light_push */ "./src/proto/waku/v2/light_push.ts"));
class PushRPC {
    constructor(proto) {
        this.proto = proto;
    }
    static createRequest(message, pubSubTopic) {
        return new PushRPC({
            requestId: uuid_1.v4(),
            request: {
                message: message.proto,
                pubSubTopic: pubSubTopic,
            },
            response: undefined,
        });
    }
    static decode(bytes) {
        const res = proto.PushRPC.decode(minimal_1.Reader.create(bytes));
        return new PushRPC(res);
    }
    encode() {
        return proto.PushRPC.encode(this.proto).finish();
    }
    get query() {
        return this.proto.request;
    }
    get response() {
        return this.proto.response;
    }
}
exports.PushRPC = PushRPC;


/***/ }),

/***/ "./src/lib/waku_message/index.ts":
/*!***************************************!*\
  !*** ./src/lib/waku_message/index.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuMessage = exports.DecryptionMethod = void 0;
// Ensure that this class matches the proto interface while
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
// Protecting the user from protobuf oddities
const proto = __importStar(__webpack_require__(/*! ../../proto/waku/v2/message */ "./src/proto/waku/v2/message.ts"));
const version_1 = __importStar(__webpack_require__(/*! ./version_1 */ "./src/lib/waku_message/version_1.ts"));
const DefaultVersion = 0;
const dbg = debug_1.default('waku:message');
var DecryptionMethod;
(function (DecryptionMethod) {
    DecryptionMethod["Asymmetric"] = "asymmetric";
    DecryptionMethod["Symmetric"] = "symmetric";
})(DecryptionMethod = exports.DecryptionMethod || (exports.DecryptionMethod = {}));
class WakuMessage {
    constructor(proto, _signaturePublicKey, _signature) {
        this.proto = proto;
        this._signaturePublicKey = _signaturePublicKey;
        this._signature = _signature;
    }
    /**
     * Create Message with an utf-8 string as payload.
     */
    static async fromUtf8String(utf8, contentTopic, opts) {
        const payload = buffer_1.Buffer.from(utf8, 'utf-8');
        return WakuMessage.fromBytes(payload, contentTopic, opts);
    }
    /**
     * Create a Waku Message with the given payload.
     *
     * By default, the payload is kept clear (version 0).
     * If `opts.encPublicKey` is passed, the payload is encrypted using
     * asymmetric encryption (version 1).
     *
     * If `opts.sigPrivKey` is passed and version 1 is used, the payload is signed
     * before encryption.
     *
     * @throws if both `opts.encPublicKey` and `opt.symKey` are passed
     */
    static async fromBytes(payload, contentTopic, opts) {
        const { timestamp, encPublicKey, symKey, sigPrivKey } = Object.assign({ timestamp: new Date() }, opts ? opts : {});
        let _payload = payload;
        let version = DefaultVersion;
        let sig;
        if (encPublicKey && symKey) {
            throw 'Pass either `encPublicKey` or `symKey`, not both.';
        }
        if (encPublicKey) {
            const enc = version_1.clearEncode(_payload, sigPrivKey);
            _payload = await version_1.encryptAsymmetric(enc.payload, encPublicKey);
            sig = enc.sig;
            version = 1;
        }
        else if (symKey) {
            const enc = version_1.clearEncode(_payload, sigPrivKey);
            _payload = await version_1.encryptSymmetric(enc.payload, symKey);
            sig = enc.sig;
            version = 1;
        }
        return new WakuMessage({
            payload: _payload,
            timestamp: timestamp.valueOf() / 1000,
            version,
            contentTopic,
        }, sig?.publicKey, sig?.signature);
    }
    /**
     * Decode a byte array into Waku Message.
     *
     * @params bytes The message encoded using protobuf as defined in [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/).
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are run out.
     */
    static async decode(bytes, decryptionKeys) {
        const protoBuf = proto.WakuMessage.decode(minimal_1.Reader.create(bytes));
        return WakuMessage.decodeProto(protoBuf, decryptionKeys);
    }
    /**
     * Decode and decrypt Waku Message Protobuf Object into Waku Message.
     *
     * @params protoBuf The message to decode and decrypt.
     * @params decryptionKeys If the payload is encrypted (version = 1), then the
     * keys are used to attempt decryption of the message. The passed key can either
     * be asymmetric private keys or symmetric keys, both method are tried for each
     * key until the message is decrypted or combinations are run out.
     */
    static async decodeProto(protoBuf, decryptionKeys) {
        if (protoBuf.payload === undefined) {
            dbg('Payload is undefined');
            return;
        }
        const payload = protoBuf.payload;
        let signaturePublicKey;
        let signature;
        if (protoBuf.version === 1 && protoBuf.payload) {
            if (decryptionKeys === undefined) {
                dbg('Payload is encrypted but no private keys have been provided.');
                return;
            }
            // Returns a bunch of `undefined` and hopefully one decrypted result
            const allResults = await Promise.all(decryptionKeys.map(async ({ key, method, contentTopics }) => {
                if (!contentTopics ||
                    (protoBuf.contentTopic &&
                        contentTopics.includes(protoBuf.contentTopic))) {
                    switch (method) {
                        case DecryptionMethod.Asymmetric:
                            try {
                                return await version_1.decryptAsymmetric(payload, key);
                            }
                            catch (e) {
                                dbg('Failed to decrypt message using symmetric encryption despite decryption method being specified', e);
                                return;
                            }
                        case DecryptionMethod.Symmetric:
                            try {
                                return await version_1.decryptSymmetric(payload, key);
                            }
                            catch (e) {
                                dbg('Failed to decrypt message using asymmetric encryption despite decryption method being specified', e);
                                return;
                            }
                        default:
                            try {
                                return await version_1.decryptSymmetric(payload, key);
                            }
                            catch (e) {
                                dbg('Failed to decrypt message using symmetric encryption', e);
                                try {
                                    return await version_1.decryptAsymmetric(payload, key);
                                }
                                catch (e) {
                                    dbg('Failed to decrypt message using asymmetric encryption', e);
                                    return;
                                }
                            }
                    }
                }
                else {
                    // No key available for this content topic
                    return;
                }
            }));
            const isDefined = (dec) => {
                return !!dec;
            };
            const decodedResults = allResults.filter(isDefined);
            if (decodedResults.length === 0) {
                dbg('Failed to decrypt payload.');
                return;
            }
            const dec = decodedResults[0];
            const res = await version_1.clearDecode(dec);
            if (!res) {
                dbg('Failed to decode payload.');
                return;
            }
            Object.assign(protoBuf, { payload: res.payload });
            signaturePublicKey = res.sig?.publicKey;
            signature = res.sig?.signature;
        }
        return new WakuMessage(protoBuf, signaturePublicKey, signature);
    }
    encode() {
        return proto.WakuMessage.encode(this.proto).finish();
    }
    get payloadAsUtf8() {
        if (!this.proto.payload) {
            return '';
        }
        return buffer_1.Buffer.from(this.proto.payload).toString('utf-8');
    }
    get payload() {
        return this.proto.payload;
    }
    get contentTopic() {
        return this.proto.contentTopic;
    }
    get version() {
        return this.proto.version;
    }
    get timestamp() {
        if (this.proto.timestamp) {
            return new Date(this.proto.timestamp * 1000);
        }
        return;
    }
    /**
     * The public key used to sign the message.
     *
     * MAY be present if the message is version 1.
     */
    get signaturePublicKey() {
        return this._signaturePublicKey;
    }
    /**
     * The signature of the message.
     *
     * MAY be present if the message is version 1.
     */
    get signature() {
        return this._signature;
    }
}
exports.WakuMessage = WakuMessage;


/***/ }),

/***/ "./src/lib/waku_message/symmetric/browser.ts":
/*!***************************************************!*\
  !*** ./src/lib/waku_message/symmetric/browser.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateIv = exports.decrypt = exports.encrypt = void 0;
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/waku_message/symmetric/index.ts");
const crypto = window.crypto || window.msCrypto;
const subtle = crypto.subtle || crypto.webkitSubtle;
const Algorithm = { name: 'AES-GCM', length: 128 };
if (subtle === undefined) {
    throw new Error('Failed to load Subtle CryptoAPI');
}
async function encrypt(iv, key, clearText) {
    return subtle
        .importKey('raw', key, Algorithm, false, ['encrypt'])
        .then((cryptoKey) => subtle.encrypt({ iv, ...Algorithm }, cryptoKey, clearText))
        .then(Buffer.from);
}
exports.encrypt = encrypt;
async function decrypt(iv, key, cipherText) {
    return subtle
        .importKey('raw', key, Algorithm, false, ['decrypt'])
        .then((cryptoKey) => subtle.decrypt({ iv, ...Algorithm }, cryptoKey, cipherText))
        .then(Buffer.from);
}
exports.decrypt = decrypt;
function generateIv() {
    const iv = new Uint8Array(index_1.IvSize);
    crypto.getRandomValues(iv);
    return iv;
}
exports.generateIv = generateIv;


/***/ }),

/***/ "./src/lib/waku_message/symmetric/index.ts":
/*!*************************************************!*\
  !*** ./src/lib/waku_message/symmetric/index.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.symmetric = exports.TagSize = exports.IvSize = exports.SymmetricKeySize = void 0;
exports.SymmetricKeySize = 32;
exports.IvSize = 12;
exports.TagSize = 16;
exports.symmetric = {};
Promise.resolve().then(() => __importStar(__webpack_require__(/*! ./browser */ "./src/lib/waku_message/symmetric/browser.ts"))).then((mod) => {
    exports.symmetric = mod;
})
    .catch((eBrowser) => {
    Promise.resolve().then(() => __importStar(__webpack_require__(/*! ./node */ "./src/lib/waku_message/symmetric/node.ts"))).then((mod) => {
        exports.symmetric = mod;
    })
        .catch((eNode) => {
        throw `Could not load any symmetric crypto modules: ${eBrowser}, ${eNode}`;
    });
});


/***/ }),

/***/ "./src/lib/waku_message/symmetric/node.ts":
/*!************************************************!*\
  !*** ./src/lib/waku_message/symmetric/node.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateIv = exports.decrypt = exports.encrypt = void 0;
const crypto_1 = __webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js");
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/waku_message/symmetric/index.ts");
const Algorithm = 'aes-256-gcm';
async function encrypt(iv, key, clearText) {
    const cipher = crypto_1.createCipheriv(Algorithm, key, iv);
    const a = cipher.update(clearText);
    const b = cipher.final();
    const tag = cipher.getAuthTag();
    return Buffer.concat([a, b, tag]);
}
exports.encrypt = encrypt;
async function decrypt(iv, key, data) {
    const tagStart = data.length - index_1.TagSize;
    const cipherText = data.slice(0, tagStart);
    const tag = data.slice(tagStart);
    const decipher = crypto_1.createDecipheriv(Algorithm, key, iv);
    decipher.setAuthTag(tag);
    const a = decipher.update(cipherText);
    const b = decipher.final();
    return Buffer.concat([a, b]);
}
exports.decrypt = decrypt;
function generateIv() {
    return crypto_1.randomBytes(index_1.IvSize);
}
exports.generateIv = generateIv;


/***/ }),

/***/ "./src/lib/waku_message/version_1.ts":
/*!*******************************************!*\
  !*** ./src/lib/waku_message/version_1.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPublicKey = exports.generateSymmetricKey = exports.generatePrivateKey = exports.decryptSymmetric = exports.encryptSymmetric = exports.decryptAsymmetric = exports.encryptAsymmetric = exports.clearDecode = exports.clearEncode = exports.PrivateKeySize = void 0;
const buffer_1 = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");
const crypto = __importStar(__webpack_require__(/*! crypto */ "./node_modules/crypto-browserify/index.js"));
const ecies = __importStar(__webpack_require__(/*! ecies-geth */ "./node_modules/ecies-geth/dist/lib/src/typescript/browser.js"));
const js_sha3_1 = __webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js");
const secp256k1 = __importStar(__webpack_require__(/*! secp256k1 */ "./node_modules/secp256k1/elliptic.js"));
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const symmetric_1 = __webpack_require__(/*! ./symmetric */ "./src/lib/waku_message/symmetric/index.ts");
const FlagsLength = 1;
const FlagMask = 3; // 0011
const IsSignedMask = 4; // 0100
const PaddingTarget = 256;
const SignatureLength = 65;
exports.PrivateKeySize = 32;
/**
 * Encode the payload pre-encryption.
 *
 * @internal
 * @param messagePayload: The payload to include in the message
 * @param sigPrivKey: If set, a signature using this private key is added.
 * @returns The encoded payload, ready for encryption using {@link encryptAsymmetric}
 * or {@link encryptSymmetric}.
 */
function clearEncode(messagePayload, sigPrivKey) {
    let envelope = buffer_1.Buffer.from([0]); // No flags
    envelope = addPayloadSizeField(envelope, messagePayload);
    envelope = buffer_1.Buffer.concat([envelope, buffer_1.Buffer.from(messagePayload)]);
    // Calculate padding:
    let rawSize = FlagsLength +
        getSizeOfPayloadSizeField(messagePayload) +
        messagePayload.length;
    if (sigPrivKey) {
        rawSize += SignatureLength;
    }
    const remainder = rawSize % PaddingTarget;
    const paddingSize = PaddingTarget - remainder;
    const pad = buffer_1.Buffer.from(randomBytes(paddingSize));
    if (!validateDataIntegrity(pad, paddingSize)) {
        throw new Error('failed to generate random padding of size ' + paddingSize);
    }
    envelope = buffer_1.Buffer.concat([envelope, pad]);
    let sig;
    if (sigPrivKey) {
        envelope[0] |= IsSignedMask;
        const hash = js_sha3_1.keccak256(envelope);
        const s = secp256k1.ecdsaSign(utils_1.hexToBuf(hash), sigPrivKey);
        envelope = buffer_1.Buffer.concat([envelope, s.signature, buffer_1.Buffer.from([s.recid])]);
        sig = {
            signature: buffer_1.Buffer.from(s.signature),
            publicKey: getPublicKey(sigPrivKey),
        };
    }
    return { payload: envelope, sig };
}
exports.clearEncode = clearEncode;
/**
 * Decode a decrypted payload.
 *
 * @internal
 */
function clearDecode(message) {
    const buf = buffer_1.Buffer.from(message);
    let start = 1;
    let sig;
    const sizeOfPayloadSizeField = buf.readUIntLE(0, 1) & FlagMask;
    if (sizeOfPayloadSizeField === 0)
        return;
    const payloadSize = buf.readUIntLE(start, sizeOfPayloadSizeField);
    start += sizeOfPayloadSizeField;
    const payload = buf.slice(start, start + payloadSize);
    const isSigned = (buf.readUIntLE(0, 1) & IsSignedMask) == IsSignedMask;
    if (isSigned) {
        const signature = getSignature(buf);
        const hash = getHash(buf, isSigned);
        const publicKey = ecRecoverPubKey(hash, signature);
        sig = { signature, publicKey };
    }
    return { payload, sig };
}
exports.clearDecode = clearDecode;
/**
 * Proceed with Asymmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The data MUST be flags | payload-length | payload | [signature].
 * The returned result can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptAsymmetric(data, publicKey) {
    return ecies.encrypt(utils_1.hexToBuf(publicKey), buffer_1.Buffer.from(data));
}
exports.encryptAsymmetric = encryptAsymmetric;
/**
 * Proceed with Asymmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 * The return data is expect to be flags | payload-length | payload | [signature].
 *
 * @internal
 */
async function decryptAsymmetric(payload, privKey) {
    return ecies.decrypt(buffer_1.Buffer.from(privKey), buffer_1.Buffer.from(payload));
}
exports.decryptAsymmetric = decryptAsymmetric;
/**
 * Proceed with Symmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param data The data to encrypt, expected to be `flags | payload-length | payload | [signature]`.
 * @param key The key to use for encryption.
 * @returns The decrypted data, `cipherText | tag | iv` and can be set to `WakuMessage.payload`.
 *
 * @internal
 */
async function encryptSymmetric(data, key) {
    const iv = symmetric_1.symmetric.generateIv();
    // Returns `cipher | tag`
    const cipher = await symmetric_1.symmetric.encrypt(iv, utils_1.hexToBuf(key), buffer_1.Buffer.from(data));
    return buffer_1.Buffer.concat([cipher, buffer_1.Buffer.from(iv)]);
}
exports.encryptSymmetric = encryptSymmetric;
/**
 * Proceed with Symmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 *
 * @param payload The cipher data, it is expected to be `cipherText | tag | iv`.
 * @param key The key to use for decryption.
 * @returns The decrypted data, expected to be `flags | payload-length | payload | [signature]`.
 *
 * @internal
 */
async function decryptSymmetric(payload, key) {
    const data = buffer_1.Buffer.from(payload);
    const ivStart = data.length - symmetric_1.IvSize;
    const cipher = data.slice(0, ivStart);
    const iv = data.slice(ivStart);
    return symmetric_1.symmetric.decrypt(iv, utils_1.hexToBuf(key), cipher);
}
exports.decryptSymmetric = decryptSymmetric;
/**
 * Generate a new private key to be used for asymmetric encryption.
 *
 * Use {@link getPublicKey} to get the corresponding Public Key.
 */
function generatePrivateKey() {
    return randomBytes(exports.PrivateKeySize);
}
exports.generatePrivateKey = generatePrivateKey;
/**
 * Generate a new symmetric key to be used for symmetric encryption.
 */
function generateSymmetricKey() {
    return randomBytes(symmetric_1.SymmetricKeySize);
}
exports.generateSymmetricKey = generateSymmetricKey;
/**
 * Return the public key for the given private key, to be used for asymmetric
 * encryption.
 */
function getPublicKey(privateKey) {
    return secp256k1.publicKeyCreate(privateKey, false);
}
exports.getPublicKey = getPublicKey;
/**
 * Computes the flags & auxiliary-field as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).
 */
function addPayloadSizeField(msg, payload) {
    const fieldSize = getSizeOfPayloadSizeField(payload);
    let field = buffer_1.Buffer.alloc(4);
    field.writeUInt32LE(payload.length, 0);
    field = field.slice(0, fieldSize);
    msg = buffer_1.Buffer.concat([msg, field]);
    msg[0] |= fieldSize;
    return msg;
}
/**
 * Returns the size of the auxiliary-field which in turns contains the payload size
 */
function getSizeOfPayloadSizeField(payload) {
    let s = 1;
    for (let i = payload.length; i >= 256; i /= 256) {
        s++;
    }
    return s;
}
function validateDataIntegrity(value, expectedSize) {
    if (value.length !== expectedSize) {
        return false;
    }
    return !(expectedSize > 3 && buffer_1.Buffer.from(value).equals(buffer_1.Buffer.alloc(value.length)));
}
function getSignature(message) {
    return message.slice(message.length - SignatureLength, message.length);
}
function getHash(message, isSigned) {
    if (isSigned) {
        return js_sha3_1.keccak256(message.slice(0, message.length - SignatureLength));
    }
    return js_sha3_1.keccak256(message);
}
function ecRecoverPubKey(messageHash, signature) {
    const recovery = signature.slice(64).readIntBE(0, 1);
    return secp256k1.ecdsaRecover(signature.slice(0, 64), recovery, utils_1.hexToBuf(messageHash), false);
}
function randomBytes(length) {
    if (typeof window !== 'undefined' && window && window.crypto) {
        const array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return array;
    }
    else {
        return crypto.randomBytes(length);
    }
}


/***/ }),

/***/ "./src/lib/waku_relay/constants.ts":
/*!*****************************************!*\
  !*** ./src/lib/waku_relay/constants.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelayMaxIHaveLength = exports.RelayOpportunisticGraftPeers = exports.RelayOpportunisticGraftTicks = exports.RelayFanoutTTL = exports.RelayPruneBackoff = exports.RelayPrunePeers = exports.RelayHeartbeatInterval = exports.RelayHeartbeatInitialDelay = exports.RelayGossipFactor = exports.RelayPingContentTopic = exports.RelayCodecs = exports.minute = exports.second = void 0;
exports.second = 1000;
exports.minute = 60 * exports.second;
/**
 * RelayCodec is the libp2p identifier for the waku relay protocol
 */
exports.RelayCodecs = [
    '/vac/waku/relay/2.0.0-beta2',
    '/vac/waku/relay/2.0.0',
];
exports.RelayPingContentTopic = '/relay-ping/1/ping/null';
/**
 * RelayGossipFactor affects how many peers we will emit gossip to at each heartbeat.
 * We will send gossip to RelayGossipFactor * (total number of non-mesh peers), or
 * RelayDlazy, whichever is greater.
 */
exports.RelayGossipFactor = 0.25;
/**
 * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins
 * after the router is initialized.
 */
exports.RelayHeartbeatInitialDelay = 100;
/**
 * RelayHeartbeatInterval controls the time between heartbeats.
 */
exports.RelayHeartbeatInterval = exports.second;
/**
 * RelayPrunePeers controls the number of peers to include in prune Peer eXchange.
 * When we prune a peer that's eligible for PX (has a good score, etc), we will try to
 * send them signed peer records for up to RelayPrunePeers other peers that we
 * know of.
 */
exports.RelayPrunePeers = 16;
/**
 * RelayPruneBackoff controls the backoff time for pruned peers. This is how long
 * a peer must wait before attempting to graft into our mesh again after being pruned.
 * When pruning a peer, we send them our value of RelayPruneBackoff so they know
 * the minimum time to wait. Peers running older versions may not send a backoff time,
 * so if we receive a prune message without one, we will wait at least RelayPruneBackoff
 * before attempting to re-graft.
 */
exports.RelayPruneBackoff = exports.minute;
/**
 * RelayFanoutTTL controls how long we keep track of the fanout state. If it's been
 * RelayFanoutTTL since we've published to a topic that we're not subscribed to,
 * we'll delete the fanout map for that topic.
 */
exports.RelayFanoutTTL = exports.minute;
/**
 * RelayOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh
 * with opportunistic grafting. Every RelayOpportunisticGraftTicks we will attempt to select some
 * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls
 * below a threshold
 */
exports.RelayOpportunisticGraftTicks = 60;
/**
 * RelayOpportunisticGraftPeers is the number of peers to opportunistically graft.
 */
exports.RelayOpportunisticGraftPeers = 2;
/**
 * RelayMaxIHaveLength is the maximum number of messages to include in an IHAVE message.
 * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a
 * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the
 * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;
 * with the defaults this is 1666 messages/s.
 */
exports.RelayMaxIHaveLength = 5000;


/***/ }),

/***/ "./src/lib/waku_relay/get_relay_peers.ts":
/*!***********************************************!*\
  !*** ./src/lib/waku_relay/get_relay_peers.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRelayPeers = void 0;
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const index_1 = __webpack_require__(/*! ./index */ "./src/lib/waku_relay/index.ts");
/**
 * Given a topic, returns up to count peers subscribed to that topic
 * that pass an optional filter function
 *
 * @param {Gossipsub} router
 * @param {String} topic
 * @param {Number} count
 * @param {Function} [filter] a function to filter acceptable peers
 * @returns {Set<string>}
 *
 */
function getRelayPeers(router, topic, count, filter = () => true) {
    const peersInTopic = router.topics.get(topic);
    if (!peersInTopic) {
        return new Set();
    }
    // Adds all peers using our protocol
    // that also pass the filter function
    let peers = [];
    peersInTopic.forEach((id) => {
        const peerStreams = router.peers.get(id);
        if (!peerStreams) {
            return;
        }
        if (index_1.RelayCodecs.includes(peerStreams.protocol) && filter(id)) {
            peers.push(id);
        }
    });
    // Pseudo-randomly shuffles peers
    peers = utils_1.shuffle(peers);
    if (count > 0 && peers.length > count) {
        peers = peers.slice(0, count);
    }
    return new Set(peers);
}
exports.getRelayPeers = getRelayPeers;


/***/ }),

/***/ "./src/lib/waku_relay/index.ts":
/*!*************************************!*\
  !*** ./src/lib/waku_relay/index.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuRelay = exports.RelayCodecs = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const libp2p_gossipsub_1 = __importDefault(__webpack_require__(/*! libp2p-gossipsub */ "./node_modules/libp2p-gossipsub/src/index.js"));
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const signature_policy_1 = __webpack_require__(/*! libp2p-interfaces/src/pubsub/signature-policy */ "./node_modules/libp2p-interfaces/src/pubsub/signature-policy.js");
const peer_id_1 = __importDefault(__webpack_require__(/*! peer-id */ "./node_modules/peer-id/src/index.js"));
const utils_2 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const waku_message_1 = __webpack_require__(/*! ../waku_message */ "./src/lib/waku_message/index.ts");
const constants = __importStar(__webpack_require__(/*! ./constants */ "./src/lib/waku_relay/constants.ts"));
const constants_1 = __webpack_require__(/*! ./constants */ "./src/lib/waku_relay/constants.ts");
Object.defineProperty(exports, "RelayCodecs", ({ enumerable: true, get: function () { return constants_1.RelayCodecs; } }));
const get_relay_peers_1 = __webpack_require__(/*! ./get_relay_peers */ "./src/lib/waku_relay/get_relay_peers.ts");
const relay_heartbeat_1 = __webpack_require__(/*! ./relay_heartbeat */ "./src/lib/waku_relay/relay_heartbeat.ts");
const dbg = debug_1.default('waku:relay');
/**
 * Implements the [Waku v2 Relay protocol]{@link https://rfc.vac.dev/spec/11/}.
 * Must be passed as a `pubsub` module to a {Libp2p} instance.
 *
 * @implements {require('libp2p-interfaces/src/pubsub')}
 * @noInheritDoc
 */
class WakuRelay extends libp2p_gossipsub_1.default {
    constructor(libp2p, options) {
        super(libp2p, Object.assign(options, {
            // Ensure that no signature is included nor expected in the messages.
            globalSignaturePolicy: signature_policy_1.SignaturePolicy.StrictNoSign,
        }));
        this.heartbeat = new relay_heartbeat_1.RelayHeartbeat(this);
        this.observers = {};
        this.decryptionKeys = new Map();
        const multicodecs = constants.RelayCodecs;
        Object.assign(this, { multicodecs });
        this.pubSubTopic = options?.pubSubTopic || waku_1.DefaultPubSubTopic;
        options?.decryptionKeys?.forEach((key) => {
            this.addDecryptionKey(key);
        });
    }
    /**
     * Mounts the gossipsub protocol onto the libp2p node
     * and subscribes to the default topic.
     *
     * @override
     * @returns {void}
     */
    start() {
        super.start();
        this.subscribe(this.pubSubTopic);
    }
    /**
     * Send Waku message.
     *
     * @param {WakuMessage} message
     * @returns {Promise<void>}
     */
    async send(message) {
        const msg = message.encode();
        await super.publish(this.pubSubTopic, Buffer.from(msg));
    }
    /**
     * Register a decryption key to attempt decryption of received messages.
     * This can either be a private key for asymmetric encryption or a symmetric
     * key. `WakuRelay` will attempt to decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set(utils_2.hexToBuf(key), options ?? {});
    }
    /**
     * Delete a decryption key that was used to attempt decryption of received
     * messages.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete(utils_2.hexToBuf(key));
    }
    /**
     * Register an observer of new messages received via waku relay
     *
     * @param callback called when a new message is received via waku relay
     * @param contentTopics Content Topics for which the callback with be called,
     * all of them if undefined, [] or ["",..] is passed.
     * @returns {void}
     */
    addObserver(callback, contentTopics = []) {
        if (contentTopics.length === 0) {
            if (!this.observers['']) {
                this.observers[''] = new Set();
            }
            this.observers[''].add(callback);
        }
        else {
            contentTopics.forEach((contentTopic) => {
                if (!this.observers[contentTopic]) {
                    this.observers[contentTopic] = new Set();
                }
                this.observers[contentTopic].add(callback);
            });
        }
    }
    /**
     * Remove an observer of new messages received via waku relay.
     * Useful to ensure the same observer is not registered several time
     * (e.g when loading React components)
     */
    deleteObserver(callback, contentTopics = []) {
        if (contentTopics.length === 0) {
            if (this.observers['']) {
                this.observers[''].delete(callback);
            }
        }
        else {
            contentTopics.forEach((contentTopic) => {
                if (this.observers[contentTopic]) {
                    this.observers[contentTopic].delete(callback);
                }
            });
        }
    }
    /**
     * Return the relay peers we are connected to and we would publish a message to
     */
    getPeers() {
        return get_relay_peers_1.getRelayPeers(this, this.pubSubTopic, this._options.D, (id) => {
            // Filter peers we would not publish to
            return (this.score.score(id) >= this._options.scoreThresholds.publishThreshold);
        });
    }
    /**
     * Subscribe to a pubsub topic and start emitting Waku messages to observers.
     *
     * @override
     */
    subscribe(pubSubTopic) {
        this.on(pubSubTopic, (event) => {
            const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
                return {
                    key,
                    method,
                    contentTopics,
                };
            });
            dbg(`Message received on ${pubSubTopic}`);
            waku_message_1.WakuMessage.decode(event.data, decryptionKeys)
                .then((wakuMsg) => {
                if (!wakuMsg) {
                    dbg('Failed to decode Waku Message');
                    return;
                }
                if (this.observers['']) {
                    this.observers[''].forEach((callbackFn) => {
                        callbackFn(wakuMsg);
                    });
                }
                if (wakuMsg.contentTopic) {
                    if (this.observers[wakuMsg.contentTopic]) {
                        this.observers[wakuMsg.contentTopic].forEach((callbackFn) => {
                            callbackFn(wakuMsg);
                        });
                    }
                }
            })
                .catch((e) => {
                dbg('Failed to decode Waku Message', e);
            });
        });
        super.subscribe(pubSubTopic);
    }
    /**
     * Join pubsub topic.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @internal
     * @param {string} topic
     * @returns {void}
     * @override
     */
    join(topic) {
        if (!this.started) {
            throw new Error('WakuRelayPubSub has not started');
        }
        const fanoutPeers = this.fanout.get(topic);
        if (fanoutPeers) {
            // these peers have a score above the publish threshold, which may be negative
            // so drop the ones with a negative score
            fanoutPeers.forEach((id) => {
                if (this.score.score(id) < 0) {
                    fanoutPeers.delete(id);
                }
            });
            if (fanoutPeers.size < this._options.D) {
                // we need more peers; eager, as this would get fixed in the next heartbeat
                get_relay_peers_1.getRelayPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {
                    // filter our current peers, direct peers, and peers with negative scores
                    return (!fanoutPeers.has(id) &&
                        !this.direct.has(id) &&
                        this.score.score(id) >= 0);
                }).forEach((id) => fanoutPeers.add(id));
            }
            this.mesh.set(topic, fanoutPeers);
            this.fanout.delete(topic);
            this.lastpub.delete(topic);
        }
        else {
            const peers = get_relay_peers_1.getRelayPeers(this, topic, this._options.D, (id) => {
                // filter direct peers and peers with negative score
                return !this.direct.has(id) && this.score.score(id) >= 0;
            });
            this.mesh.set(topic, peers);
        }
        this.mesh.get(topic)?.forEach((id) => {
            this.log('JOIN: Add mesh link to %s in %s', id, topic);
            this._sendGraft(id, topic);
        });
    }
    /**
     * Publish messages.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {InMessage} msg
     * @returns {void}
     */
    async _publish(msg) {
        if (msg.receivedFrom !== this.peerId.toB58String()) {
            this.score.deliverMessage(msg);
            this.gossipTracer.deliverMessage(msg);
        }
        const msgID = await this.getMsgId(msg);
        const msgIdStr = utils_1.messageIdToString(msgID);
        // put in seen cache
        this.seenCache.put(msgIdStr);
        this.messageCache.put(msg);
        const toSend = new Set();
        msg.topicIDs.forEach((topic) => {
            const peersInTopic = this.topics.get(topic);
            if (!peersInTopic) {
                return;
            }
            // direct peers
            this.direct.forEach((id) => {
                toSend.add(id);
            });
            let meshPeers = this.mesh.get(topic);
            if (!meshPeers || !meshPeers.size) {
                // We are not in the mesh for topic, use fanout peers
                meshPeers = this.fanout.get(topic);
                if (!meshPeers) {
                    // If we are not in the fanout, then pick peers in topic above the publishThreshold
                    const peers = get_relay_peers_1.getRelayPeers(this, topic, this._options.D, (id) => {
                        return (this.score.score(id) >=
                            this._options.scoreThresholds.publishThreshold);
                    });
                    if (peers.size > 0) {
                        meshPeers = peers;
                        this.fanout.set(topic, peers);
                    }
                    else {
                        meshPeers = new Set();
                    }
                }
                // Store the latest publishing time
                this.lastpub.set(topic, this._now());
            }
            meshPeers?.forEach((peer) => {
                toSend.add(peer);
            });
        });
        // Publish messages to peers
        const rpc = utils_1.createGossipRpc([libp2p_gossipsub_1.default.utils.normalizeOutRpcMessage(msg)]);
        toSend.forEach((id) => {
            if (id === msg.from) {
                return;
            }
            this._sendRpc(id, rpc);
        });
    }
    /**
     * Emits gossip to peers in a particular topic.
     *
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {string} topic
     * @param {Set<string>} exclude peers to exclude
     * @returns {void}
     */
    _emitGossip(topic, exclude) {
        const messageIDs = this.messageCache.getGossipIDs(topic);
        if (!messageIDs.length) {
            return;
        }
        // shuffle to emit in random order
        utils_1.shuffle(messageIDs);
        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list
        if (messageIDs.length > constants.RelayMaxIHaveLength) {
            // we do the truncation (with shuffling) per peer below
            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);
        }
        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy
        // First we collect the peers above gossipThreshold that are not in the exclude set
        // and then randomly select from that set
        // We also exclude direct peers, as there is no reason to emit gossip to them
        const peersToGossip = [];
        const topicPeers = this.topics.get(topic);
        if (!topicPeers) {
            // no topic peers, no gossip
            return;
        }
        topicPeers.forEach((id) => {
            const peerStreams = this.peers.get(id);
            if (!peerStreams) {
                return;
            }
            if (!exclude.has(id) &&
                !this.direct.has(id) &&
                constants.RelayCodecs.includes(peerStreams.protocol) &&
                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {
                peersToGossip.push(id);
            }
        });
        let target = this._options.Dlazy;
        const factor = constants.RelayGossipFactor * peersToGossip.length;
        if (factor > target) {
            target = factor;
        }
        if (target > peersToGossip.length) {
            target = peersToGossip.length;
        }
        else {
            utils_1.shuffle(peersToGossip);
        }
        // Emit the IHAVE gossip to the selected peers up to the target
        peersToGossip.slice(0, target).forEach((id) => {
            let peerMessageIDs = messageIDs;
            if (messageIDs.length > constants.RelayMaxIHaveLength) {
                // shuffle and slice message IDs per peer so that we emit a different set for each peer
                // we have enough redundancy in the system that this will significantly increase the message
                // coverage when we do truncate
                peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.RelayMaxIHaveLength);
            }
            this._pushGossip(id, {
                topicID: topic,
                messageIDs: peerMessageIDs,
            });
        });
    }
    /**
     * Make a PRUNE control message for a peer in a topic.
     * This is present to override the behavior of Gossipsub and should not
     * be used by API Consumers
     *
     * @ignore
     * @override
     * @param {string} id
     * @param {string} topic
     * @param {boolean} doPX
     * @returns {RPC.IControlPrune}
     */
    _makePrune(id, topic, doPX) {
        // backoff is measured in seconds
        // RelayPruneBackoff is measured in milliseconds
        const backoff = constants.RelayPruneBackoff / 1000;
        const px = [];
        if (doPX) {
            // select peers for Peer eXchange
            const peers = get_relay_peers_1.getRelayPeers(this, topic, constants.RelayPrunePeers, (xid) => {
                return xid !== id && this.score.score(xid) >= 0;
            });
            peers.forEach((p) => {
                // see if we have a signed record to send back; if we don't, just send
                // the peer ID and let the pruned peer find them in the DHT -- we can't trust
                // unsigned address records through PX anyways
                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p
                const peerId = peer_id_1.default.createFromB58String(p);
                px.push({
                    peerID: peerId.toBytes(),
                    signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId),
                });
            });
        }
        return {
            topicID: topic,
            peers: px,
            backoff: backoff,
        };
    }
}
exports.WakuRelay = WakuRelay;


/***/ }),

/***/ "./src/lib/waku_relay/relay_heartbeat.ts":
/*!***********************************************!*\
  !*** ./src/lib/waku_relay/relay_heartbeat.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * @hidden
 * @module
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RelayHeartbeat = void 0;
const heartbeat_1 = __webpack_require__(/*! libp2p-gossipsub/src/heartbeat */ "./node_modules/libp2p-gossipsub/src/heartbeat.js");
const utils_1 = __webpack_require__(/*! libp2p-gossipsub/src/utils */ "./node_modules/libp2p-gossipsub/src/utils/index.js");
const constants = __importStar(__webpack_require__(/*! ./constants */ "./src/lib/waku_relay/constants.ts"));
const get_relay_peers_1 = __webpack_require__(/*! ./get_relay_peers */ "./src/lib/waku_relay/get_relay_peers.ts");
class RelayHeartbeat extends heartbeat_1.Heartbeat {
    /**
     * @param {Object} gossipsub
     * @constructor
     */
    constructor(gossipsub) {
        super(gossipsub);
    }
    start() {
        if (this._heartbeatTimer) {
            return;
        }
        const heartbeat = this._heartbeat.bind(this);
        const timeout = setTimeout(() => {
            heartbeat();
            this._heartbeatTimer?.runPeriodically(heartbeat, constants.RelayHeartbeatInterval);
        }, constants.RelayHeartbeatInitialDelay);
        this._heartbeatTimer = {
            _intervalId: undefined,
            runPeriodically: (fn, period) => {
                // this._heartbeatTimer cannot be null, it is being assigned.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this._heartbeatTimer._intervalId = setInterval(fn, period);
            },
            cancel: () => {
                clearTimeout(timeout);
                clearInterval(this._heartbeatTimer?._intervalId);
            },
        };
    }
    /**
     * Unmounts the gossipsub protocol and shuts down every connection
     * @override
     * @returns {void}
     */
    stop() {
        if (!this._heartbeatTimer) {
            return;
        }
        this._heartbeatTimer.cancel();
        this._heartbeatTimer = null;
    }
    /**
     * Maintains the mesh and fanout maps in gossipsub.
     *
     * @returns {void}
     */
    _heartbeat() {
        const { D, Dlo, Dhi, Dscore, Dout } = this.gossipsub._options;
        this.gossipsub.heartbeatTicks++;
        // cache scores through the heartbeat
        const scores = new Map();
        const getScore = (id) => {
            let s = scores.get(id);
            if (s === undefined) {
                s = this.gossipsub.score.score(id);
                scores.set(id, s);
            }
            return s;
        };
        // peer id => topic[]
        const toGraft = new Map();
        // peer id => topic[]
        const toPrune = new Map();
        // peer id => don't px
        const noPX = new Map();
        // clean up expired backoffs
        this.gossipsub._clearBackoff();
        // clean up peerhave/iasked counters
        this.gossipsub.peerhave.clear();
        this.gossipsub.iasked.clear();
        // apply IWANT request penalties
        this.gossipsub._applyIwantPenalties();
        // ensure direct peers are connected
        this.gossipsub._directConnect();
        // maintain the mesh for topics we have joined
        this.gossipsub.mesh.forEach((peers, topic) => {
            // prune/graft helper functions (defined per topic)
            const prunePeer = (id) => {
                this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic);
                // update peer score
                this.gossipsub.score.prune(id, topic);
                // add prune backoff record
                this.gossipsub._addBackoff(id, topic);
                // remove peer from mesh
                peers.delete(id);
                // add to toPrune
                const topics = toPrune.get(id);
                if (!topics) {
                    toPrune.set(id, [topic]);
                }
                else {
                    topics.push(topic);
                }
            };
            const graftPeer = (id) => {
                this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic);
                // update peer score
                this.gossipsub.score.graft(id, topic);
                // add peer to mesh
                peers.add(id);
                // add to toGraft
                const topics = toGraft.get(id);
                if (!topics) {
                    toGraft.set(id, [topic]);
                }
                else {
                    topics.push(topic);
                }
            };
            // drop all peers with negative score, without PX
            peers.forEach((id) => {
                const score = getScore(id);
                if (score < 0) {
                    this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);
                    prunePeer(id);
                    noPX.set(id, true);
                }
            });
            // do we have enough peers?
            if (peers.size < Dlo) {
                const backoff = this.gossipsub.backoff.get(topic);
                const ineed = D - peers.size;
                const peersSet = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {
                    // filter out mesh peers, direct peers, peers we are backing off, peers with negative score
                    return (!peers.has(id) &&
                        !this.gossipsub.direct.has(id) &&
                        (!backoff || !backoff.has(id)) &&
                        getScore(id) >= 0);
                });
                peersSet.forEach(graftPeer);
            }
            // do we have to many peers?
            if (peers.size > Dhi) {
                let peersArray = Array.from(peers);
                // sort by score
                peersArray.sort((a, b) => getScore(b) - getScore(a));
                // We keep the first D_score peers by score and the remaining up to D randomly
                // under the constraint that we keep D_out peers in the mesh (if we have that many)
                peersArray = peersArray
                    .slice(0, Dscore)
                    .concat(utils_1.shuffle(peersArray.slice(Dscore)));
                // count the outbound peers we are keeping
                let outbound = 0;
                peersArray.slice(0, D).forEach((p) => {
                    if (this.gossipsub.outbound.get(p)) {
                        outbound++;
                    }
                });
                // if it's less than D_out, bubble up some outbound peers from the random selection
                if (outbound < Dout) {
                    const rotate = (i) => {
                        // rotate the peersArray to the right and put the ith peer in the front
                        const p = peersArray[i];
                        for (let j = i; j > 0; j--) {
                            peersArray[j] = peersArray[j - 1];
                        }
                        peersArray[0] = p;
                    };
                    // first bubble up all outbound peers already in the selection to the front
                    if (outbound > 0) {
                        let ihave = outbound;
                        for (let i = 1; i < D && ihave > 0; i++) {
                            if (this.gossipsub.outbound.get(peersArray[i])) {
                                rotate(i);
                                ihave--;
                            }
                        }
                    }
                    // now bubble up enough outbound peers outside the selection to the front
                    let ineed = D - outbound;
                    for (let i = D; i < peersArray.length && ineed > 0; i++) {
                        if (this.gossipsub.outbound.get(peersArray[i])) {
                            rotate(i);
                            ineed--;
                        }
                    }
                }
                // prune the excess peers
                peersArray.slice(D).forEach(prunePeer);
            }
            // do we have enough outbound peers?
            if (peers.size >= Dlo) {
                // count the outbound peers we have
                let outbound = 0;
                peers.forEach((p) => {
                    if (this.gossipsub.outbound.get(p)) {
                        outbound++;
                    }
                });
                // if it's less than D_out, select some peers with outbound connections and graft them
                if (outbound < Dout) {
                    const ineed = Dout - outbound;
                    const backoff = this.gossipsub.backoff.get(topic);
                    get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {
                        // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score
                        return (!peers.has(id) &&
                            !this.gossipsub.direct.has(id) &&
                            (!backoff || !backoff.has(id)) &&
                            getScore(id) >= 0);
                    }).forEach(graftPeer);
                }
            }
            // should we try to improve the mesh with opportunistic grafting?
            if (this.gossipsub.heartbeatTicks %
                constants.RelayOpportunisticGraftTicks ===
                0 &&
                peers.size > 1) {
                // Opportunistic grafting works as follows: we check the median score of peers in the
                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at
                // random with score over the median.
                // The intention is to (slowly) improve an under performing mesh by introducing good
                // scoring peers that may have been gossiping at us. This allows us to get out of sticky
                // situations where we are stuck with poor peers and also recover from churn of good peers.
                // now compute the median peer score in the mesh
                const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
                const medianIndex = Math.floor(peers.size / 2);
                const medianScore = getScore(peersList[medianIndex]);
                // if the median score is below the threshold, select a better peer (if any) and GRAFT
                if (medianScore <
                    this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {
                    const backoff = this.gossipsub.backoff.get(topic);
                    const peersToGraft = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, constants.RelayOpportunisticGraftPeers, (id) => {
                        // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold
                        return (peers.has(id) &&
                            !this.gossipsub.direct.has(id) &&
                            (!backoff || !backoff.has(id)) &&
                            getScore(id) > medianScore);
                    });
                    peersToGraft.forEach((id) => {
                        this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);
                        graftPeer(id);
                    });
                }
            }
            // 2nd arg are mesh peers excluded from gossip. We have already pushed
            // messages to them, so its redundant to gossip IHAVEs.
            this.gossipsub._emitGossip(topic, peers);
        });
        // expire fanout for topics we haven't published to in a while
        const now = this.gossipsub._now();
        this.gossipsub.lastpub.forEach((lastpub, topic) => {
            if (lastpub + constants.RelayFanoutTTL < now) {
                this.gossipsub.fanout.delete(topic);
                this.gossipsub.lastpub.delete(topic);
            }
        });
        // maintain our fanout for topics we are publishing but we have not joined
        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {
            // checks whether our peers are still in the topic and have a score above the publish threshold
            const topicPeers = this.gossipsub.topics.get(topic);
            fanoutPeers.forEach((id) => {
                if (!topicPeers?.has(id) ||
                    getScore(id) <
                        this.gossipsub._options.scoreThresholds.publishThreshold) {
                    fanoutPeers.delete(id);
                }
            });
            // do we need more peers?
            if (fanoutPeers.size < D) {
                const ineed = D - fanoutPeers.size;
                const peersSet = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {
                    // filter out existing fanout peers, direct peers, and peers with score above the publish threshold
                    return (!fanoutPeers.has(id) &&
                        !this.gossipsub.direct.has(id) &&
                        getScore(id) >=
                            this.gossipsub._options.scoreThresholds.publishThreshold);
                });
                peersSet.forEach((id) => {
                    fanoutPeers.add(id);
                });
            }
            // 2nd arg are fanout peers excluded from gossip.
            // We have already pushed messages to them, so its redundant to gossip IHAVEs
            this.gossipsub._emitGossip(topic, fanoutPeers);
        });
        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)
        this.gossipsub._sendGraftPrune(toGraft, toPrune, noPX);
        // flush pending gossip that wasn't piggybacked above
        this.gossipsub._flush();
        // advance the message history window
        this.gossipsub.messageCache.shift();
        this.gossipsub.emit('gossipsub:heartbeat');
    }
}
exports.RelayHeartbeat = RelayHeartbeat;


/***/ }),

/***/ "./src/lib/waku_store/history_rpc.ts":
/*!*******************************************!*\
  !*** ./src/lib/waku_store/history_rpc.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryRPC = exports.PageDirection = void 0;
const minimal_1 = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/esm-browser/index.js");
const proto = __importStar(__webpack_require__(/*! ../../proto/waku/v2/store */ "./src/proto/waku/v2/store.ts"));
var PageDirection;
(function (PageDirection) {
    PageDirection["BACKWARD"] = "backward";
    PageDirection["FORWARD"] = "forward";
})(PageDirection = exports.PageDirection || (exports.PageDirection = {}));
class HistoryRPC {
    constructor(proto) {
        this.proto = proto;
    }
    /**
     * Create History Query.
     */
    static createQuery(params) {
        const direction = directionToProto(params.pageDirection);
        const pagingInfo = {
            pageSize: params.pageSize,
            cursor: params.cursor,
            direction,
        };
        const contentFilters = params.contentTopics.map((contentTopic) => {
            return { contentTopic };
        });
        return new HistoryRPC({
            requestId: uuid_1.v4(),
            query: {
                pubSubTopic: params.pubSubTopic,
                contentFilters,
                pagingInfo,
                startTime: params.startTime,
                endTime: params.endTime,
            },
            response: undefined,
        });
    }
    static decode(bytes) {
        const res = proto.HistoryRPC.decode(minimal_1.Reader.create(bytes));
        return new HistoryRPC(res);
    }
    encode() {
        return proto.HistoryRPC.encode(this.proto).finish();
    }
    get query() {
        return this.proto.query;
    }
    get response() {
        return this.proto.response;
    }
}
exports.HistoryRPC = HistoryRPC;
function directionToProto(pageDirection) {
    switch (pageDirection) {
        case PageDirection.BACKWARD:
            return proto.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
        case PageDirection.FORWARD:
            return proto.PagingInfo_Direction.DIRECTION_FORWARD;
        default:
            return proto.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
    }
}


/***/ }),

/***/ "./src/lib/waku_store/index.ts":
/*!*************************************!*\
  !*** ./src/lib/waku_store/index.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuStore = exports.PageDirection = exports.DefaultPageSize = exports.StoreCodec = void 0;
const debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/debug/src/browser.js"));
const it_concat_1 = __importDefault(__webpack_require__(/*! it-concat */ "./node_modules/it-concat/index.js"));
const it_length_prefixed_1 = __importDefault(__webpack_require__(/*! it-length-prefixed */ "./node_modules/it-length-prefixed/src/index.js"));
const it_pipe_1 = __importDefault(__webpack_require__(/*! it-pipe */ "./node_modules/it-pipe/index.js"));
const proto_1 = __webpack_require__(/*! ../../proto */ "./src/proto/index.ts");
const select_peer_1 = __webpack_require__(/*! ../select_peer */ "./src/lib/select_peer.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/lib/utils.ts");
const waku_1 = __webpack_require__(/*! ../waku */ "./src/lib/waku.ts");
const waku_message_1 = __webpack_require__(/*! ../waku_message */ "./src/lib/waku_message/index.ts");
const history_rpc_1 = __webpack_require__(/*! ./history_rpc */ "./src/lib/waku_store/history_rpc.ts");
Object.defineProperty(exports, "PageDirection", ({ enumerable: true, get: function () { return history_rpc_1.PageDirection; } }));
const dbg = debug_1.default('waku:store');
exports.StoreCodec = '/vac/waku/store/2.0.0-beta3';
exports.DefaultPageSize = 10;
/**
 * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).
 */
class WakuStore {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options?.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = waku_1.DefaultPubSubTopic;
        }
        this.decryptionKeys = new Map();
    }
    /**
     * Do a History Query to a Waku Store.
     *
     * @param contentTopics The content topics to pass to the query, leave empty to
     * retrieve all messages.
     *
     * @throws If not able to reach a Waku Store peer to query
     * or if an error is encountered when processing the reply.
     */
    async queryHistory(contentTopics, options) {
        let startTime, endTime;
        if (options?.timeFilter) {
            startTime = options.timeFilter.startTime.getTime() / 1000;
            endTime = options.timeFilter.endTime.getTime() / 1000;
        }
        const opts = Object.assign({
            pubSubTopic: this.pubSubTopic,
            pageDirection: history_rpc_1.PageDirection.BACKWARD,
            pageSize: exports.DefaultPageSize,
        }, options, {
            startTime,
            endTime,
        }, { contentTopics });
        dbg('Querying history with the following options', options);
        let peer;
        if (opts.peerId) {
            peer = this.libp2p.peerStore.get(opts.peerId);
            if (!peer)
                throw `Failed to retrieve connection details for provided peer in peer store: ${opts.peerId.toB58String()}`;
        }
        else {
            peer = this.randomPeer;
            if (!peer)
                throw 'Failed to find known peer that registers waku store protocol';
        }
        if (!peer.protocols.includes(exports.StoreCodec))
            throw `Peer does not register waku store protocol: ${peer.id.toB58String()}`;
        const connection = this.libp2p.connectionManager.get(peer.id);
        if (!connection)
            throw 'Failed to get a connection to the peer';
        const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
            return {
                key,
                method,
                contentTopics,
            };
        });
        // Add the decryption keys passed to this function against the
        // content topics also passed to this function.
        if (opts.decryptionKeys) {
            opts.decryptionKeys.forEach((key) => {
                decryptionKeys.push({
                    key: utils_1.hexToBuf(key),
                    contentTopics: contentTopics.length ? contentTopics : undefined,
                    method: undefined,
                });
            });
        }
        const messages = [];
        let cursor = undefined;
        while (true) {
            const { stream } = await connection.newStream(exports.StoreCodec);
            const queryOpts = Object.assign(opts, { cursor });
            const historyRpcQuery = history_rpc_1.HistoryRPC.createQuery(queryOpts);
            dbg('Querying store peer', connection.remoteAddr.toString());
            const res = await it_pipe_1.default([historyRpcQuery.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);
            const reply = history_rpc_1.HistoryRPC.decode(res.slice());
            const response = reply.response;
            if (!response) {
                throw 'History response misses response field';
            }
            if (response.error &&
                response.error === proto_1.HistoryResponse_Error.ERROR_INVALID_CURSOR) {
                throw 'History response contains an Error: INVALID CURSOR';
            }
            if (!response.messages || !response.messages.length) {
                // No messages left (or stored)
                console.log('No messages present in HistoryRPC response');
                return messages;
            }
            dbg(`${response.messages.length} messages retrieved for pubsub topic ${opts.pubSubTopic}`);
            const pageMessages = [];
            await Promise.all(response.messages.map(async (protoMsg) => {
                const msg = await waku_message_1.WakuMessage.decodeProto(protoMsg, decryptionKeys);
                if (msg) {
                    messages.push(msg);
                    pageMessages.push(msg);
                }
            }));
            let abort = false;
            if (opts.callback) {
                abort = Boolean(opts.callback(pageMessages));
            }
            const responsePageSize = response.pagingInfo?.pageSize;
            const queryPageSize = historyRpcQuery.query?.pagingInfo?.pageSize;
            if (abort ||
                // Response page size smaller than query, meaning this is the last page
                (responsePageSize && queryPageSize && responsePageSize < queryPageSize)) {
                return messages;
            }
            cursor = response.pagingInfo?.cursor;
            if (cursor === undefined) {
                // If the server does not return cursor then there is an issue,
                // Need to abort or we end up in an infinite loop
                console.log('No cursor returned by peer.');
                return messages;
            }
        }
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[queryHistory]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set(utils_1.hexToBuf(key), options ?? {});
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received in subsequent [[queryHistory]] calls.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete(utils_1.hexToBuf(key));
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * store protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        return select_peer_1.getPeersForProtocol(this.libp2p, exports.StoreCodec);
    }
    /**
     * Returns a random peer that supports store protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return select_peer_1.selectRandomPeer(this.peers);
    }
}
exports.WakuStore = WakuStore;


/***/ }),

/***/ "./src/proto/index.ts":
/*!****************************!*\
  !*** ./src/proto/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryRPC = exports.HistoryResponse_Error = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo_Direction = exports.PagingInfo = exports.Index = exports.WakuMessage = void 0;
var message_1 = __webpack_require__(/*! ./waku/v2/message */ "./src/proto/waku/v2/message.ts");
Object.defineProperty(exports, "WakuMessage", ({ enumerable: true, get: function () { return message_1.WakuMessage; } }));
var store_1 = __webpack_require__(/*! ./waku/v2/store */ "./src/proto/waku/v2/store.ts");
Object.defineProperty(exports, "Index", ({ enumerable: true, get: function () { return store_1.Index; } }));
Object.defineProperty(exports, "PagingInfo", ({ enumerable: true, get: function () { return store_1.PagingInfo; } }));
Object.defineProperty(exports, "PagingInfo_Direction", ({ enumerable: true, get: function () { return store_1.PagingInfo_Direction; } }));
Object.defineProperty(exports, "ContentFilter", ({ enumerable: true, get: function () { return store_1.ContentFilter; } }));
Object.defineProperty(exports, "HistoryQuery", ({ enumerable: true, get: function () { return store_1.HistoryQuery; } }));
Object.defineProperty(exports, "HistoryResponse", ({ enumerable: true, get: function () { return store_1.HistoryResponse; } }));
Object.defineProperty(exports, "HistoryResponse_Error", ({ enumerable: true, get: function () { return store_1.HistoryResponse_Error; } }));
Object.defineProperty(exports, "HistoryRPC", ({ enumerable: true, get: function () { return store_1.HistoryRPC; } }));


/***/ }),

/***/ "./src/proto/waku/v2/light_push.ts":
/*!*****************************************!*\
  !*** ./src/proto/waku/v2/light_push.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushRPC = exports.PushResponse = exports.PushRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
const message_1 = __webpack_require__(/*! ../../waku/v2/message */ "./src/proto/waku/v2/message.ts");
exports.protobufPackage = 'waku.v2';
function createBasePushRequest() {
    return { pubSubTopic: '', message: undefined };
}
exports.PushRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubSubTopic !== '') {
            writer.uint32(10).string(message.pubSubTopic);
        }
        if (message.message !== undefined) {
            message_1.WakuMessage.encode(message.message, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pubSubTopic = reader.string();
                    break;
                case 2:
                    message.message = message_1.WakuMessage.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pubSubTopic: isSet(object.pubSubTopic) ? String(object.pubSubTopic) : '',
            message: isSet(object.message)
                ? message_1.WakuMessage.fromJSON(object.message)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pubSubTopic !== undefined &&
            (obj.pubSubTopic = message.pubSubTopic);
        message.message !== undefined &&
            (obj.message = message.message
                ? message_1.WakuMessage.toJSON(message.message)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushRequest();
        message.pubSubTopic = object.pubSubTopic ?? '';
        message.message =
            object.message !== undefined && object.message !== null
                ? message_1.WakuMessage.fromPartial(object.message)
                : undefined;
        return message;
    },
};
function createBasePushResponse() {
    return { isSuccess: false, info: '' };
}
exports.PushResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isSuccess === true) {
            writer.uint32(8).bool(message.isSuccess);
        }
        if (message.info !== '') {
            writer.uint32(18).string(message.info);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isSuccess = reader.bool();
                    break;
                case 2:
                    message.info = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            isSuccess: isSet(object.isSuccess) ? Boolean(object.isSuccess) : false,
            info: isSet(object.info) ? String(object.info) : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.isSuccess !== undefined && (obj.isSuccess = message.isSuccess);
        message.info !== undefined && (obj.info = message.info);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushResponse();
        message.isSuccess = object.isSuccess ?? false;
        message.info = object.info ?? '';
        return message;
    },
};
function createBasePushRPC() {
    return { requestId: '', request: undefined, response: undefined };
}
exports.PushRPC = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestId !== '') {
            writer.uint32(10).string(message.requestId);
        }
        if (message.request !== undefined) {
            exports.PushRequest.encode(message.request, writer.uint32(18).fork()).ldelim();
        }
        if (message.response !== undefined) {
            exports.PushResponse.encode(message.response, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePushRPC();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.request = exports.PushRequest.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = exports.PushResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            requestId: isSet(object.requestId) ? String(object.requestId) : '',
            request: isSet(object.request)
                ? exports.PushRequest.fromJSON(object.request)
                : undefined,
            response: isSet(object.response)
                ? exports.PushResponse.fromJSON(object.response)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.request !== undefined &&
            (obj.request = message.request
                ? exports.PushRequest.toJSON(message.request)
                : undefined);
        message.response !== undefined &&
            (obj.response = message.response
                ? exports.PushResponse.toJSON(message.response)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBasePushRPC();
        message.requestId = object.requestId ?? '';
        message.request =
            object.request !== undefined && object.request !== null
                ? exports.PushRequest.fromPartial(object.request)
                : undefined;
        message.response =
            object.response !== undefined && object.response !== null
                ? exports.PushResponse.fromPartial(object.response)
                : undefined;
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}


/***/ }),

/***/ "./src/proto/waku/v2/message.ts":
/*!**************************************!*\
  !*** ./src/proto/waku/v2/message.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WakuMessage = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
exports.protobufPackage = 'waku.v2';
function createBaseWakuMessage() {
    return {
        payload: undefined,
        contentTopic: undefined,
        version: undefined,
        timestamp: undefined,
    };
}
exports.WakuMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.payload !== undefined) {
            writer.uint32(10).bytes(message.payload);
        }
        if (message.contentTopic !== undefined) {
            writer.uint32(18).string(message.contentTopic);
        }
        if (message.version !== undefined) {
            writer.uint32(24).uint32(message.version);
        }
        if (message.timestamp !== undefined) {
            writer.uint32(33).double(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWakuMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.payload = reader.bytes();
                    break;
                case 2:
                    message.contentTopic = reader.string();
                    break;
                case 3:
                    message.version = reader.uint32();
                    break;
                case 4:
                    message.timestamp = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            payload: isSet(object.payload)
                ? bytesFromBase64(object.payload)
                : undefined,
            contentTopic: isSet(object.contentTopic)
                ? String(object.contentTopic)
                : undefined,
            version: isSet(object.version) ? Number(object.version) : undefined,
            timestamp: isSet(object.timestamp) ? Number(object.timestamp) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.payload !== undefined &&
            (obj.payload =
                message.payload !== undefined
                    ? base64FromBytes(message.payload)
                    : undefined);
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        message.version !== undefined &&
            (obj.version = Math.round(message.version));
        message.timestamp !== undefined && (obj.timestamp = message.timestamp);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseWakuMessage();
        message.payload = object.payload ?? undefined;
        message.contentTopic = object.contentTopic ?? undefined;
        message.version = object.version ?? undefined;
        message.timestamp = object.timestamp ?? undefined;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== 'undefined')
        return globalThis;
    if (typeof self !== 'undefined')
        return self;
    if (typeof window !== 'undefined')
        return window;
    if (typeof __webpack_require__.g !== 'undefined')
        return __webpack_require__.g;
    throw 'Unable to locate global object';
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(''));
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}


/***/ }),

/***/ "./src/proto/waku/v2/store.ts":
/*!************************************!*\
  !*** ./src/proto/waku/v2/store.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryRPC = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo = exports.Index = exports.historyResponse_ErrorToJSON = exports.historyResponse_ErrorFromJSON = exports.HistoryResponse_Error = exports.pagingInfo_DirectionToJSON = exports.pagingInfo_DirectionFromJSON = exports.PagingInfo_Direction = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(__webpack_require__(/*! long */ "./node_modules/long/src/long.js"));
const minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js"));
const message_1 = __webpack_require__(/*! ../../waku/v2/message */ "./src/proto/waku/v2/message.ts");
exports.protobufPackage = 'waku.v2';
var PagingInfo_Direction;
(function (PagingInfo_Direction) {
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_BACKWARD_UNSPECIFIED"] = 0] = "DIRECTION_BACKWARD_UNSPECIFIED";
    PagingInfo_Direction[PagingInfo_Direction["DIRECTION_FORWARD"] = 1] = "DIRECTION_FORWARD";
    PagingInfo_Direction[PagingInfo_Direction["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PagingInfo_Direction = exports.PagingInfo_Direction || (exports.PagingInfo_Direction = {}));
function pagingInfo_DirectionFromJSON(object) {
    switch (object) {
        case 0:
        case 'DIRECTION_BACKWARD_UNSPECIFIED':
            return PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;
        case 1:
        case 'DIRECTION_FORWARD':
            return PagingInfo_Direction.DIRECTION_FORWARD;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return PagingInfo_Direction.UNRECOGNIZED;
    }
}
exports.pagingInfo_DirectionFromJSON = pagingInfo_DirectionFromJSON;
function pagingInfo_DirectionToJSON(object) {
    switch (object) {
        case PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED:
            return 'DIRECTION_BACKWARD_UNSPECIFIED';
        case PagingInfo_Direction.DIRECTION_FORWARD:
            return 'DIRECTION_FORWARD';
        default:
            return 'UNKNOWN';
    }
}
exports.pagingInfo_DirectionToJSON = pagingInfo_DirectionToJSON;
var HistoryResponse_Error;
(function (HistoryResponse_Error) {
    HistoryResponse_Error[HistoryResponse_Error["ERROR_NONE_UNSPECIFIED"] = 0] = "ERROR_NONE_UNSPECIFIED";
    HistoryResponse_Error[HistoryResponse_Error["ERROR_INVALID_CURSOR"] = 1] = "ERROR_INVALID_CURSOR";
    HistoryResponse_Error[HistoryResponse_Error["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HistoryResponse_Error = exports.HistoryResponse_Error || (exports.HistoryResponse_Error = {}));
function historyResponse_ErrorFromJSON(object) {
    switch (object) {
        case 0:
        case 'ERROR_NONE_UNSPECIFIED':
            return HistoryResponse_Error.ERROR_NONE_UNSPECIFIED;
        case 1:
        case 'ERROR_INVALID_CURSOR':
            return HistoryResponse_Error.ERROR_INVALID_CURSOR;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return HistoryResponse_Error.UNRECOGNIZED;
    }
}
exports.historyResponse_ErrorFromJSON = historyResponse_ErrorFromJSON;
function historyResponse_ErrorToJSON(object) {
    switch (object) {
        case HistoryResponse_Error.ERROR_NONE_UNSPECIFIED:
            return 'ERROR_NONE_UNSPECIFIED';
        case HistoryResponse_Error.ERROR_INVALID_CURSOR:
            return 'ERROR_INVALID_CURSOR';
        default:
            return 'UNKNOWN';
    }
}
exports.historyResponse_ErrorToJSON = historyResponse_ErrorToJSON;
function createBaseIndex() {
    return { digest: new Uint8Array(), receivedTime: 0, senderTime: 0 };
}
exports.Index = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.digest.length !== 0) {
            writer.uint32(10).bytes(message.digest);
        }
        if (message.receivedTime !== 0) {
            writer.uint32(17).double(message.receivedTime);
        }
        if (message.senderTime !== 0) {
            writer.uint32(25).double(message.senderTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIndex();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.digest = reader.bytes();
                    break;
                case 2:
                    message.receivedTime = reader.double();
                    break;
                case 3:
                    message.senderTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            digest: isSet(object.digest)
                ? bytesFromBase64(object.digest)
                : new Uint8Array(),
            receivedTime: isSet(object.receivedTime)
                ? Number(object.receivedTime)
                : 0,
            senderTime: isSet(object.senderTime) ? Number(object.senderTime) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.digest !== undefined &&
            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));
        message.receivedTime !== undefined &&
            (obj.receivedTime = message.receivedTime);
        message.senderTime !== undefined && (obj.senderTime = message.senderTime);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseIndex();
        message.digest = object.digest ?? new Uint8Array();
        message.receivedTime = object.receivedTime ?? 0;
        message.senderTime = object.senderTime ?? 0;
        return message;
    },
};
function createBasePagingInfo() {
    return { pageSize: 0, cursor: undefined, direction: 0 };
}
exports.PagingInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pageSize !== 0) {
            writer.uint32(8).uint64(message.pageSize);
        }
        if (message.cursor !== undefined) {
            exports.Index.encode(message.cursor, writer.uint32(18).fork()).ldelim();
        }
        if (message.direction !== 0) {
            writer.uint32(24).int32(message.direction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePagingInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pageSize = longToNumber(reader.uint64());
                    break;
                case 2:
                    message.cursor = exports.Index.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.direction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pageSize: isSet(object.pageSize) ? Number(object.pageSize) : 0,
            cursor: isSet(object.cursor) ? exports.Index.fromJSON(object.cursor) : undefined,
            direction: isSet(object.direction)
                ? pagingInfo_DirectionFromJSON(object.direction)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pageSize !== undefined &&
            (obj.pageSize = Math.round(message.pageSize));
        message.cursor !== undefined &&
            (obj.cursor = message.cursor ? exports.Index.toJSON(message.cursor) : undefined);
        message.direction !== undefined &&
            (obj.direction = pagingInfo_DirectionToJSON(message.direction));
        return obj;
    },
    fromPartial(object) {
        const message = createBasePagingInfo();
        message.pageSize = object.pageSize ?? 0;
        message.cursor =
            object.cursor !== undefined && object.cursor !== null
                ? exports.Index.fromPartial(object.cursor)
                : undefined;
        message.direction = object.direction ?? 0;
        return message;
    },
};
function createBaseContentFilter() {
    return { contentTopic: '' };
}
exports.ContentFilter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.contentTopic !== '') {
            writer.uint32(10).string(message.contentTopic);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContentFilter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.contentTopic = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            contentTopic: isSet(object.contentTopic)
                ? String(object.contentTopic)
                : '',
        };
    },
    toJSON(message) {
        const obj = {};
        message.contentTopic !== undefined &&
            (obj.contentTopic = message.contentTopic);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseContentFilter();
        message.contentTopic = object.contentTopic ?? '';
        return message;
    },
};
function createBaseHistoryQuery() {
    return {
        pubSubTopic: undefined,
        contentFilters: [],
        pagingInfo: undefined,
        startTime: undefined,
        endTime: undefined,
    };
}
exports.HistoryQuery = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pubSubTopic !== undefined) {
            writer.uint32(18).string(message.pubSubTopic);
        }
        for (const v of message.contentFilters) {
            exports.ContentFilter.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(34).fork()).ldelim();
        }
        if (message.startTime !== undefined) {
            writer.uint32(41).double(message.startTime);
        }
        if (message.endTime !== undefined) {
            writer.uint32(49).double(message.endTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoryQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.pubSubTopic = reader.string();
                    break;
                case 3:
                    message.contentFilters.push(exports.ContentFilter.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.startTime = reader.double();
                    break;
                case 6:
                    message.endTime = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            pubSubTopic: isSet(object.pubSubTopic)
                ? String(object.pubSubTopic)
                : undefined,
            contentFilters: Array.isArray(object?.contentFilters)
                ? object.contentFilters.map((e) => exports.ContentFilter.fromJSON(e))
                : [],
            pagingInfo: isSet(object.pagingInfo)
                ? exports.PagingInfo.fromJSON(object.pagingInfo)
                : undefined,
            startTime: isSet(object.startTime) ? Number(object.startTime) : undefined,
            endTime: isSet(object.endTime) ? Number(object.endTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.pubSubTopic !== undefined &&
            (obj.pubSubTopic = message.pubSubTopic);
        if (message.contentFilters) {
            obj.contentFilters = message.contentFilters.map((e) => e ? exports.ContentFilter.toJSON(e) : undefined);
        }
        else {
            obj.contentFilters = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.startTime !== undefined && (obj.startTime = message.startTime);
        message.endTime !== undefined && (obj.endTime = message.endTime);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHistoryQuery();
        message.pubSubTopic = object.pubSubTopic ?? undefined;
        message.contentFilters =
            object.contentFilters?.map((e) => exports.ContentFilter.fromPartial(e)) || [];
        message.pagingInfo =
            object.pagingInfo !== undefined && object.pagingInfo !== null
                ? exports.PagingInfo.fromPartial(object.pagingInfo)
                : undefined;
        message.startTime = object.startTime ?? undefined;
        message.endTime = object.endTime ?? undefined;
        return message;
    },
};
function createBaseHistoryResponse() {
    return { messages: [], pagingInfo: undefined, error: 0 };
}
exports.HistoryResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
            message_1.WakuMessage.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagingInfo !== undefined) {
            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(26).fork()).ldelim();
        }
        if (message.error !== 0) {
            writer.uint32(32).int32(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.messages.push(message_1.WakuMessage.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.error = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            messages: Array.isArray(object?.messages)
                ? object.messages.map((e) => message_1.WakuMessage.fromJSON(e))
                : [],
            pagingInfo: isSet(object.pagingInfo)
                ? exports.PagingInfo.fromJSON(object.pagingInfo)
                : undefined,
            error: isSet(object.error)
                ? historyResponse_ErrorFromJSON(object.error)
                : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.messages) {
            obj.messages = message.messages.map((e) => e ? message_1.WakuMessage.toJSON(e) : undefined);
        }
        else {
            obj.messages = [];
        }
        message.pagingInfo !== undefined &&
            (obj.pagingInfo = message.pagingInfo
                ? exports.PagingInfo.toJSON(message.pagingInfo)
                : undefined);
        message.error !== undefined &&
            (obj.error = historyResponse_ErrorToJSON(message.error));
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHistoryResponse();
        message.messages =
            object.messages?.map((e) => message_1.WakuMessage.fromPartial(e)) || [];
        message.pagingInfo =
            object.pagingInfo !== undefined && object.pagingInfo !== null
                ? exports.PagingInfo.fromPartial(object.pagingInfo)
                : undefined;
        message.error = object.error ?? 0;
        return message;
    },
};
function createBaseHistoryRPC() {
    return { requestId: '', query: undefined, response: undefined };
}
exports.HistoryRPC = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestId !== '') {
            writer.uint32(10).string(message.requestId);
        }
        if (message.query !== undefined) {
            exports.HistoryQuery.encode(message.query, writer.uint32(18).fork()).ldelim();
        }
        if (message.response !== undefined) {
            exports.HistoryResponse.encode(message.response, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoryRPC();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.string();
                    break;
                case 2:
                    message.query = exports.HistoryQuery.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.response = exports.HistoryResponse.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        return {
            requestId: isSet(object.requestId) ? String(object.requestId) : '',
            query: isSet(object.query)
                ? exports.HistoryQuery.fromJSON(object.query)
                : undefined,
            response: isSet(object.response)
                ? exports.HistoryResponse.fromJSON(object.response)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        message.requestId !== undefined && (obj.requestId = message.requestId);
        message.query !== undefined &&
            (obj.query = message.query
                ? exports.HistoryQuery.toJSON(message.query)
                : undefined);
        message.response !== undefined &&
            (obj.response = message.response
                ? exports.HistoryResponse.toJSON(message.response)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = createBaseHistoryRPC();
        message.requestId = object.requestId ?? '';
        message.query =
            object.query !== undefined && object.query !== null
                ? exports.HistoryQuery.fromPartial(object.query)
                : undefined;
        message.response =
            object.response !== undefined && object.response !== null
                ? exports.HistoryResponse.fromPartial(object.response)
                : undefined;
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== 'undefined')
        return globalThis;
    if (typeof self !== 'undefined')
        return self;
    if (typeof window !== 'undefined')
        return window;
    if (typeof __webpack_require__.g !== 'undefined')
        return __webpack_require__.g;
    throw 'Unable to locate global object';
})();
const atob = globalThis.atob ||
    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));
function bytesFromBase64(b64) {
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
        arr[i] = bin.charCodeAt(i);
    }
    return arr;
}
const btoa = globalThis.btoa ||
    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));
function base64FromBytes(arr) {
    const bin = [];
    for (const byte of arr) {
        bin.push(String.fromCharCode(byte));
    }
    return btoa(bin.join(''));
}
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isSet(value) {
    return value !== null && value !== undefined;
}


/***/ }),

/***/ "?18f2":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?0b7d":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?25ed":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8131":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?3fc0":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?f9d4":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?7a28":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?e4dd":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?887c":
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?2961":
/*!*********************************!*\
  !*** @motrix/nat-api (ignored) ***!
  \*********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?7d1a":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b254":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?ed1b":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?d17e":
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b3ef":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"js-waku": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = this["webpackChunkjswaku"] = this["webpackChunkjswaku"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors"], () => (__webpack_require__("./src/index.ts")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ0pBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNLHFCQUFxQjtXQUMzQjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTs7Ozs7VUVoREE7VUFDQTtVQUNBO1VBQ0E7VUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZGlzY292ZXJ5L2Jvb3RzdHJhcC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Rpc2NvdmVyeS9kbnMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9kaXNjb3ZlcnkvZG5zX292ZXJfaHR0cHMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9kaXNjb3ZlcnkvZW5ydHJlZS50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Rpc2NvdmVyeS9ob3N0ZWRfanNvbi50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Rpc2NvdmVyeS9pbmRleC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Vuci9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9lbnIvY3JlYXRlLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZW5yL2Vuci50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Vuci9pbmRleC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Vuci9rZXlwYWlyL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL2Vuci9rZXlwYWlyL2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZW5yL2tleXBhaXIvc2VjcDI1NmsxLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvZW5yL2tleXBhaXIvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9lbnIvdHlwZXMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9lbnIvdjQudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi9zZWxlY3RfcGVlci50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3V0aWxzLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdS50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfbGlnaHRfcHVzaC9pbmRleC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfbGlnaHRfcHVzaC9wdXNoX3JwYy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfbWVzc2FnZS9pbmRleC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfbWVzc2FnZS9zeW1tZXRyaWMvYnJvd3Nlci50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfbWVzc2FnZS9zeW1tZXRyaWMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X21lc3NhZ2Uvc3ltbWV0cmljL25vZGUudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X21lc3NhZ2UvdmVyc2lvbl8xLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9saWIvd2FrdV9yZWxheS9jb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X3JlbGF5L2dldF9yZWxheV9wZWVycy50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3VfcmVsYXkvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X3JlbGF5L3JlbGF5X2hlYXJ0YmVhdC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvbGliL3dha3Vfc3RvcmUvaGlzdG9yeV9ycGMudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL2xpYi93YWt1X3N0b3JlL2luZGV4LnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9wcm90by9pbmRleC50cyIsIndlYnBhY2s6Ly9qc3dha3UvLi9zcmMvcHJvdG8vd2FrdS92Mi9saWdodF9wdXNoLnRzIiwid2VicGFjazovL2pzd2FrdS8uL3NyYy9wcm90by93YWt1L3YyL21lc3NhZ2UudHMiLCJ3ZWJwYWNrOi8vanN3YWt1Ly4vc3JjL3Byb3RvL3dha3UvdjIvc3RvcmUudHMiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvQG5vYmxlL2VkMjU1MTkvbGlifGNyeXB0byIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcm95ZXIvc3JjL3N0YXR1cy1pbS9qcy13YWt1L25vZGVfbW9kdWxlcy9Abm9ibGUvc2VjcDI1NmsxL2xpYnxjcnlwdG8iLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvQHN0YWJsZWxpYi9yYW5kb20vbGliL3NvdXJjZXxjcnlwdG8iLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvYm4uanMvbGlifGJ1ZmZlciIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcm95ZXIvc3JjL3N0YXR1cy1pbS9qcy13YWt1L25vZGVfbW9kdWxlcy9icm9yYW5kfGNyeXB0byIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcm95ZXIvc3JjL3N0YXR1cy1pbS9qcy13YWt1L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXJzYS9ub2RlX21vZHVsZXMvYm4uanMvbGlifGJ1ZmZlciIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcm95ZXIvc3JjL3N0YXR1cy1pbS9qcy13YWt1L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5LXNpZ24vbm9kZV9tb2R1bGVzL2JuLmpzL2xpYnxidWZmZXIiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvY2xlYW4tc3RhY2t8b3MiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvaXQtd3N8d3MiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvbGlicDJwL3NyY3xAbW90cml4L25hdC1hcGkiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvbm9kZS1mb3JnZS9saWJ8YnVmZmVyIiwid2VicGFjazovL2pzd2FrdS9pZ25vcmVkfC9ob21lL2Zyb3llci9zcmMvc3RhdHVzLWltL2pzLXdha3Uvbm9kZV9tb2R1bGVzL25vZGUtZm9yZ2UvbGlifGNyeXB0byIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcm95ZXIvc3JjL3N0YXR1cy1pbS9qcy13YWt1L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXN8dXRpbCIsIndlYnBhY2s6Ly9qc3dha3UvaWdub3JlZHwvaG9tZS9mcm95ZXIvc3JjL3N0YXR1cy1pbS9qcy13YWt1L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGlifHV0aWwiLCJ3ZWJwYWNrOi8vanN3YWt1L2lnbm9yZWR8L2hvbWUvZnJveWVyL3NyYy9zdGF0dXMtaW0vanMtd2FrdS9ub2RlX21vZHVsZXMvcmxwL25vZGVfbW9kdWxlcy9ibi5qcy9saWJ8YnVmZmVyIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9qc3dha3Uvd2VicGFjay9ydW50aW1lL2FtZCBvcHRpb25zIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL3J1bnRpbWUvY2h1bmsgbG9hZGVkIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svcnVudGltZS9qc29ucCBjaHVuayBsb2FkaW5nIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL2pzd2FrdS93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vanN3YWt1L3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJqc3dha3VcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wianN3YWt1XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiZXhwb3J0IHsgZ2V0Tm9kZXNGcm9tSG9zdGVkSnNvbiB9IGZyb20gJy4vbGliL2Rpc2NvdmVyeSc7XG5leHBvcnQgKiBhcyBkaXNjb3ZlcnkgZnJvbSAnLi9saWIvZGlzY292ZXJ5JztcblxuZXhwb3J0ICogYXMgZW5yIGZyb20gJy4vbGliL2Vucic7XG5cbmV4cG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vbGliL3V0aWxzJztcblxuZXhwb3J0ICogYXMgd2FrdSBmcm9tICcuL2xpYi93YWt1JztcbmV4cG9ydCB7IFdha3UsIERlZmF1bHRQdWJTdWJUb3BpYyB9IGZyb20gJy4vbGliL3dha3UnO1xuXG5leHBvcnQgKiBhcyB3YWt1X21lc3NhZ2UgZnJvbSAnLi9saWIvd2FrdV9tZXNzYWdlJztcbmV4cG9ydCB7IFdha3VNZXNzYWdlIH0gZnJvbSAnLi9saWIvd2FrdV9tZXNzYWdlJztcblxuZXhwb3J0IHtcbiAgZ2VuZXJhdGVQcml2YXRlS2V5LFxuICBnZW5lcmF0ZVN5bW1ldHJpY0tleSxcbiAgZ2V0UHVibGljS2V5LFxufSBmcm9tICcuL2xpYi93YWt1X21lc3NhZ2UvdmVyc2lvbl8xJztcblxuZXhwb3J0ICogYXMgd2FrdV9saWdodF9wdXNoIGZyb20gJy4vbGliL3dha3VfbGlnaHRfcHVzaCc7XG5leHBvcnQge1xuICBXYWt1TGlnaHRQdXNoLFxuICBMaWdodFB1c2hDb2RlYyxcbiAgUHVzaFJlc3BvbnNlLFxufSBmcm9tICcuL2xpYi93YWt1X2xpZ2h0X3B1c2gnO1xuXG5leHBvcnQgKiBhcyB3YWt1X3JlbGF5IGZyb20gJy4vbGliL3dha3VfcmVsYXknO1xuZXhwb3J0IHsgV2FrdVJlbGF5LCBSZWxheUNvZGVjcyB9IGZyb20gJy4vbGliL3dha3VfcmVsYXknO1xuXG5leHBvcnQgKiBhcyB3YWt1X3N0b3JlIGZyb20gJy4vbGliL3dha3Vfc3RvcmUnO1xuZXhwb3J0IHsgUGFnZURpcmVjdGlvbiwgV2FrdVN0b3JlLCBTdG9yZUNvZGVjIH0gZnJvbSAnLi9saWIvd2FrdV9zdG9yZSc7XG5cbmV4cG9ydCAqIGFzIHByb3RvIGZyb20gJy4vcHJvdG8nO1xuIiwiaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IE11bHRpYWRkciB9IGZyb20gJ211bHRpYWRkcic7XG5cbmltcG9ydCB7IERuc05vZGVEaXNjb3ZlcnkgfSBmcm9tICcuL2Rucyc7XG5cbmltcG9ydCB7IGdldE5vZGVzRnJvbUhvc3RlZEpzb24sIGdldFBzZXVkb1JhbmRvbVN1YnNldCB9IGZyb20gJy4vaW5kZXgnO1xuXG5jb25zdCBkYmcgPSBkZWJ1Zygnd2FrdTpkaXNjb3Zlcnk6Ym9vdHN0cmFwJyk7XG5cbi8qKlxuICogU2V0dXAgZGlzY292ZXJ5IG1ldGhvZCB1c2VkIHRvIGJvb3RzdHJhcC5cbiAqXG4gKiBPbmx5IG9uZSBtZXRob2QgaXMgdXNlZC4gYGRlZmF1bHRgLCBgcGVlcnNgLCBgZ2V0UGVlcnNgIGFuZCBgZW5yYCBvcHRpb25zIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQm9vdHN0cmFwT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBvZiBwZWVycyB0byBjb25uZWN0IHRvIGFzIHBhcnQgb2YgdGhlIGJvb3RzdHJhcCBwcm9jZXNzLlxuICAgKlxuICAgKiBAZGVmYXVsdCBbW0Jvb3RzdHJhcC5EZWZhdWx0TWF4UGVlcnNdXVxuICAgKi9cbiAgbWF4UGVlcnM/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBVc2UgdGhlIGRlZmF1bHQgZGlzY292ZXJ5IG1ldGhvZC4gT3ZlcnJpZGVzIGFsbCBvdGhlciBvcHRpb25zIGJ1dCBgbWF4UGVlcnNgXG4gICAqXG4gICAqIFRoZSBkZWZhdWx0IGRpc2NvdmVyeSBtZXRob2QgaXMgbGlrZWx5IHRvIGNoYW5nZSBvdmVydGltZSBhcyBuZXcgZGlzY292ZXJ5XG4gICAqIG1ldGhvZHMgYXJlIGltcGxlbWVudGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZGVmYXVsdD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBNdWx0aWFkZHJzIG9mIHBlZXJzIHRvIGNvbm5lY3QgdG8uXG4gICAqL1xuICBwZWVycz86IHN0cmluZ1tdO1xuICAvKipcbiAgICogR2V0dGVyIHRoYXQgcmV0cmlldmUgbXVsdGlhZGRycyBvZiBwZWVycyB0byBjb25uZWN0IHRvLlxuICAgKi9cbiAgZ2V0UGVlcnM/OiAoKSA9PiBQcm9taXNlPHN0cmluZ1tdIHwgTXVsdGlhZGRyW10+O1xuICAvKipcbiAgICogQW4gRUlQLTE0NTkgRU5SIFRyZWUgVVJMLiBGb3IgZXhhbXBsZTpcbiAgICogXCJlbnJ0cmVlOi8vQU9GVElDVTJYV0RVTE5MWkdSTVFTNFJJWlBBWkVIWU1WNEZZSEFQVzU2M0hOUkFPRVJQN0NAdGVzdC5ub2Rlcy52YWMuZGV2XCJcbiAgICovXG4gIGVuclVybD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBQYXJzZSBvcHRpb25zIGFuZCBleHBvc2UgZnVuY3Rpb24gdG8gcmV0dXJuIGJvb3RzdHJhcCBwZWVyIGFkZHJlc3Nlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJvb3RzdHJhcCB7XG4gIHB1YmxpYyBzdGF0aWMgRGVmYXVsdE1heFBlZXJzID0gMTtcblxuICBwdWJsaWMgcmVhZG9ubHkgZ2V0Qm9vdHN0cmFwUGVlcnM6ICgoKSA9PiBQcm9taXNlPE11bHRpYWRkcltdPikgfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3Iob3B0czogQm9vdHN0cmFwT3B0aW9ucykge1xuICAgIGNvbnN0IG1heFBlZXJzID0gb3B0cy5tYXhQZWVycyA/PyBCb290c3RyYXAuRGVmYXVsdE1heFBlZXJzO1xuXG4gICAgaWYgKG9wdHMuZGVmYXVsdCkge1xuICAgICAgZGJnKCdVc2UgaG9zdGVkIGxpc3Qgb2YgcGVlcnMuJyk7XG5cbiAgICAgIHRoaXMuZ2V0Qm9vdHN0cmFwUGVlcnMgPSBnZXROb2Rlc0Zyb21Ib3N0ZWRKc29uLmJpbmQoXG4gICAgICAgIHt9LFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgbWF4UGVlcnNcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChvcHRzLnBlZXJzICE9PSB1bmRlZmluZWQgJiYgb3B0cy5wZWVycy5sZW5ndGggPiAwKSB7XG4gICAgICBkYmcoJ1VzZSBwcm92aWRlZCBsaXN0IG9mIHBlZXJzLicpO1xuXG4gICAgICBjb25zdCBhbGxQZWVyczogTXVsdGlhZGRyW10gPSBvcHRzLnBlZXJzLm1hcChcbiAgICAgICAgKG5vZGU6IHN0cmluZykgPT4gbmV3IE11bHRpYWRkcihub2RlKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHBlZXJzID0gZ2V0UHNldWRvUmFuZG9tU3Vic2V0KGFsbFBlZXJzLCBtYXhQZWVycyk7XG4gICAgICB0aGlzLmdldEJvb3RzdHJhcFBlZXJzID0gKCk6IFByb21pc2U8TXVsdGlhZGRyW10+ID0+XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShwZWVycyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5nZXRQZWVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZGJnKCdCb290c3RyYXA6IFVzZSBwcm92aWRlZCBnZXRQZWVycyBmdW5jdGlvbi4nKTtcbiAgICAgIGNvbnN0IGdldFBlZXJzID0gb3B0cy5nZXRQZWVycztcblxuICAgICAgdGhpcy5nZXRCb290c3RyYXBQZWVycyA9IGFzeW5jICgpOiBQcm9taXNlPE11bHRpYWRkcltdPiA9PiB7XG4gICAgICAgIGNvbnN0IGFsbFBlZXJzID0gYXdhaXQgZ2V0UGVlcnMoKTtcbiAgICAgICAgcmV0dXJuIGdldFBzZXVkb1JhbmRvbVN1YnNldDxzdHJpbmcgfCBNdWx0aWFkZHI+KFxuICAgICAgICAgIGFsbFBlZXJzLFxuICAgICAgICAgIG1heFBlZXJzXG4gICAgICAgICkubWFwKChub2RlKSA9PiBuZXcgTXVsdGlhZGRyKG5vZGUpKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChvcHRzLmVuclVybCkge1xuICAgICAgY29uc3QgZW5yVXJsID0gb3B0cy5lbnJVcmw7XG4gICAgICBkYmcoJ1VzZSBwcm92aWRlZCBFSVAtMTQ1OSBFTlIgVHJlZSBVUkwuJyk7XG5cbiAgICAgIGNvbnN0IGRucyA9IERuc05vZGVEaXNjb3ZlcnkuZG5zT3Zlckh0dHAoKTtcblxuICAgICAgdGhpcy5nZXRCb290c3RyYXBQZWVycyA9IGFzeW5jICgpOiBQcm9taXNlPE11bHRpYWRkcltdPiA9PiB7XG4gICAgICAgIGNvbnN0IGVucnMgPSBhd2FpdCBkbnMuZ2V0UGVlcnMobWF4UGVlcnMsIFtlbnJVcmxdKTtcbiAgICAgICAgZGJnKGBGb3VuZCAke2VucnMubGVuZ3RofSBwZWVyc2ApO1xuICAgICAgICByZXR1cm4gZW5ycy5tYXAoKGVucikgPT4gZW5yLmdldEZ1bGxNdWx0aWFkZHJzKCkpLmZsYXQoKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRiZygnTm8gYm9vdHN0cmFwIG1ldGhvZCBzcGVjaWZpZWQsIG5vIHBlZXIgd2lsbCBiZSByZXR1cm5lZCcpO1xuICAgICAgdGhpcy5nZXRCb290c3RyYXBQZWVycyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuaW1wb3J0IHsgZGVidWcgfSBmcm9tICdkZWJ1Zyc7XG5cbmltcG9ydCB7IEVOUiB9IGZyb20gJy4uL2Vucic7XG5cbmltcG9ydCB7IERuc092ZXJIdHRwcywgRW5kcG9pbnRzIH0gZnJvbSAnLi9kbnNfb3Zlcl9odHRwcyc7XG5pbXBvcnQgeyBFTlJUcmVlIH0gZnJvbSAnLi9lbnJ0cmVlJztcblxuY29uc3QgZGJnID0gZGVidWcoJ3dha3U6ZGlzY292ZXJ5OmRucycpO1xuXG5leHBvcnQgdHlwZSBTZWFyY2hDb250ZXh0ID0ge1xuICBkb21haW46IHN0cmluZztcbiAgcHVibGljS2V5OiBzdHJpbmc7XG4gIHZpc2l0czogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH07XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIERuc0NsaWVudCB7XG4gIHJlc29sdmVUWFQ6IChkb21haW46IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmdbXT47XG59XG5cbmV4cG9ydCBjbGFzcyBEbnNOb2RlRGlzY292ZXJ5IHtcbiAgcHJpdmF0ZSByZWFkb25seSBkbnM6IERuc0NsaWVudDtcbiAgcHJpdmF0ZSByZWFkb25seSBfRE5TVHJlZUNhY2hlOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9O1xuICBwcml2YXRlIHJlYWRvbmx5IF9lcnJvclRvbGVyYW5jZTogbnVtYmVyID0gMTA7XG5cbiAgcHVibGljIHN0YXRpYyBkbnNPdmVySHR0cChlbmRwb2ludHM/OiBFbmRwb2ludHMpOiBEbnNOb2RlRGlzY292ZXJ5IHtcbiAgICBjb25zdCBkbnNDbGllbnQgPSBuZXcgRG5zT3Zlckh0dHBzKGVuZHBvaW50cyk7XG4gICAgcmV0dXJuIG5ldyBEbnNOb2RlRGlzY292ZXJ5KGRuc0NsaWVudCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgdmVyaWZpZWQgcGVlcnMgbGlzdGVkIGluIGFuIEVJUC0xNDU5IEROUyB0cmVlLiBNZXRob2QgbWF5XG4gICAqIHJldHVybiBmZXdlciBwZWVycyB0aGFuIHJlcXVlc3RlZCBpZiBgbWF4UXVhbnRpdHlgIGlzIGxhcmdlciB0aGFuIHRoZSBudW1iZXJcbiAgICogb2YgRU5SIHJlY29yZHMgb3IgdGhlIG51bWJlciBvZiBlcnJvcnMvZHVwbGljYXRlIHBlZXJzIGVuY291bnRlcmVkIGJ5IHJhbmRvbWl6ZWRcbiAgICogc2VhcmNoIGV4Y2VlZHMgYG1heFF1YW50aXR5YCBwbHVzIHRoZSBgZXJyb3JUb2xlcmFuY2VgIGZhY3Rvci5cbiAgICovXG4gIGFzeW5jIGdldFBlZXJzKG1heFF1YW50aXR5OiBudW1iZXIsIGVuclRyZWVVcmxzOiBzdHJpbmdbXSk6IFByb21pc2U8RU5SW10+IHtcbiAgICBsZXQgdG90YWxTZWFyY2hlcyA9IDA7XG4gICAgY29uc3QgcGVlcnM6IEVOUltdID0gW107XG5cbiAgICBjb25zdCBuZXR3b3JrSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBlbnJUcmVlVXJscy5sZW5ndGgpO1xuICAgIGNvbnN0IHsgcHVibGljS2V5LCBkb21haW4gfSA9IEVOUlRyZWUucGFyc2VUcmVlKGVuclRyZWVVcmxzW25ldHdvcmtJbmRleF0pO1xuXG4gICAgd2hpbGUgKFxuICAgICAgcGVlcnMubGVuZ3RoIDwgbWF4UXVhbnRpdHkgJiZcbiAgICAgIHRvdGFsU2VhcmNoZXMgPCBtYXhRdWFudGl0eSArIHRoaXMuX2Vycm9yVG9sZXJhbmNlXG4gICAgKSB7XG4gICAgICBjb25zdCBjb250ZXh0OiBTZWFyY2hDb250ZXh0ID0ge1xuICAgICAgICBkb21haW4sXG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgdmlzaXRzOiB7fSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBlZXIgPSBhd2FpdCB0aGlzLl9zZWFyY2goZG9tYWluLCBjb250ZXh0KTtcblxuICAgICAgaWYgKHBlZXIgJiYgaXNOZXdQZWVyKHBlZXIsIHBlZXJzKSkge1xuICAgICAgICBwZWVycy5wdXNoKHBlZXIpO1xuICAgICAgICBkYmcoXG4gICAgICAgICAgYGdvdCBuZXcgcGVlciBjYW5kaWRhdGUgZnJvbSBETlMgYWRkcmVzcz0ke3BlZXIubm9kZUlkfUAke3BlZXIuaXB9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB0b3RhbFNlYXJjaGVzKys7XG4gICAgfVxuICAgIHJldHVybiBwZWVycztcbiAgfVxuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihkbnM6IERuc0NsaWVudCkge1xuICAgIHRoaXMuX0ROU1RyZWVDYWNoZSA9IHt9O1xuICAgIHRoaXMuZG5zID0gZG5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgYSByZWN1cnNpdmUsIHJhbmRvbWl6ZWQgZGVzY2VudCBvZiB0aGUgRE5TIHRyZWUgdG8gcmV0cmlldmUgYSBzaW5nbGVcbiAgICogRU5SIHJlY29yZCBhcyBhbiBFTlIuIFJldHVybnMgbnVsbCBpZiBwYXJzaW5nIG9yIEROUyByZXNvbHV0aW9uIGZhaWxzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfc2VhcmNoKFxuICAgIHN1YmRvbWFpbjogc3RyaW5nLFxuICAgIGNvbnRleHQ6IFNlYXJjaENvbnRleHRcbiAgKTogUHJvbWlzZTxFTlIgfCBudWxsPiB7XG4gICAgY29uc3QgZW50cnkgPSBhd2FpdCB0aGlzLl9nZXRUWFRSZWNvcmQoc3ViZG9tYWluLCBjb250ZXh0KTtcbiAgICBjb250ZXh0LnZpc2l0c1tzdWJkb21haW5dID0gdHJ1ZTtcblxuICAgIGxldCBuZXh0OiBzdHJpbmc7XG4gICAgbGV0IGJyYW5jaGVzOiBzdHJpbmdbXTtcblxuICAgIGNvbnN0IGVudHJ5VHlwZSA9IGdldEVudHJ5VHlwZShlbnRyeSk7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAoZW50cnlUeXBlKSB7XG4gICAgICAgIGNhc2UgRU5SVHJlZS5ST09UX1BSRUZJWDpcbiAgICAgICAgICBuZXh0ID0gRU5SVHJlZS5wYXJzZUFuZFZlcmlmeVJvb3QoZW50cnksIGNvbnRleHQucHVibGljS2V5KTtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2VhcmNoKG5leHQsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIEVOUlRyZWUuQlJBTkNIX1BSRUZJWDpcbiAgICAgICAgICBicmFuY2hlcyA9IEVOUlRyZWUucGFyc2VCcmFuY2goZW50cnkpO1xuICAgICAgICAgIG5leHQgPSBzZWxlY3RSYW5kb21QYXRoKGJyYW5jaGVzLCBjb250ZXh0KTtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2VhcmNoKG5leHQsIGNvbnRleHQpO1xuICAgICAgICBjYXNlIEVOUlRyZWUuUkVDT1JEX1BSRUZJWDpcbiAgICAgICAgICByZXR1cm4gRU5SLmRlY29kZVR4dChlbnRyeSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRiZyhcbiAgICAgICAgYEZhaWxlZCB0byBzZWFyY2ggRE5TIHRyZWUgJHtlbnRyeVR5cGV9IGF0IHN1YmRvbWFpbiAke3N1YmRvbWFpbn06ICR7ZXJyb3J9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIFRYVCByZWNvcmQgc3RvcmVkIGF0IGEgbG9jYXRpb24gZnJvbSBlaXRoZXJcbiAgICogdGhpcyBETlMgdHJlZSBjYWNoZSBvciB2aWEgRE5TIHF1ZXJ5XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9nZXRUWFRSZWNvcmQoXG4gICAgc3ViZG9tYWluOiBzdHJpbmcsXG4gICAgY29udGV4dDogU2VhcmNoQ29udGV4dFxuICApOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGlmICh0aGlzLl9ETlNUcmVlQ2FjaGVbc3ViZG9tYWluXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX0ROU1RyZWVDYWNoZVtzdWJkb21haW5dO1xuICAgIH1cblxuICAgIC8vIExvY2F0aW9uIGlzIGVpdGhlciB0aGUgdG9wIGxldmVsIHRyZWUgZW50cnkgaG9zdCBvciBhIHN1YmRvbWFpbiBvZiBpdC5cbiAgICBjb25zdCBsb2NhdGlvbiA9XG4gICAgICBzdWJkb21haW4gIT09IGNvbnRleHQuZG9tYWluXG4gICAgICAgID8gYCR7c3ViZG9tYWlufS4ke2NvbnRleHQuZG9tYWlufWBcbiAgICAgICAgOiBjb250ZXh0LmRvbWFpbjtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5kbnMucmVzb2x2ZVRYVChsb2NhdGlvbik7XG5cbiAgICBhc3NlcnQoXG4gICAgICByZXNwb25zZS5sZW5ndGgsXG4gICAgICAnUmVjZWl2ZWQgZW1wdHkgcmVzdWx0IGFycmF5IHdoaWxlIGZldGNoaW5nIFRYVCByZWNvcmQnXG4gICAgKTtcbiAgICBhc3NlcnQocmVzcG9uc2VbMF0ubGVuZ3RoLCAnUmVjZWl2ZWQgZW1wdHkgVFhUIHJlY29yZCcpO1xuXG4gICAgLy8gQnJhbmNoIGVudHJpZXMgY2FuIGJlIGFuIGFycmF5IG9mIHN0cmluZ3Mgb2YgY29tbWEgZGVsaW1pdGVkIHN1YmRvbWFpbnMsIHdpdGhcbiAgICAvLyBzb21lIHN1YmRvbWFpbiBzdHJpbmdzIHNwbGl0IGFjcm9zcyB0aGUgYXJyYXkgZWxlbWVudHNcbiAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZS5qb2luKCcnKTtcblxuICAgIHRoaXMuX0ROU1RyZWVDYWNoZVtzdWJkb21haW5dID0gcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RW50cnlUeXBlKGVudHJ5OiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoZW50cnkuc3RhcnRzV2l0aChFTlJUcmVlLlJPT1RfUFJFRklYKSkgcmV0dXJuIEVOUlRyZWUuUk9PVF9QUkVGSVg7XG4gIGlmIChlbnRyeS5zdGFydHNXaXRoKEVOUlRyZWUuQlJBTkNIX1BSRUZJWCkpIHJldHVybiBFTlJUcmVlLkJSQU5DSF9QUkVGSVg7XG4gIGlmIChlbnRyeS5zdGFydHNXaXRoKEVOUlRyZWUuUkVDT1JEX1BSRUZJWCkpIHJldHVybiBFTlJUcmVlLlJFQ09SRF9QUkVGSVg7XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb21seSBzZWxlY3RlZCBzdWJkb21haW4gc3RyaW5nIGZyb20gdGhlIGxpc3QgcHJvdmlkZWQgYnkgYSBicmFuY2hcbiAqIGVudHJ5IHJlY29yZC5cbiAqXG4gKiBUaGUgY2xpZW50IG11c3QgdHJhY2sgc3ViZG9tYWlucyB3aGljaCBhcmUgYWxyZWFkeSByZXNvbHZlZCB0byBhdm9pZFxuICogZ29pbmcgaW50byBhbiBpbmZpbml0ZSBsb29wIGIvYyBicmFuY2ggZW50cmllcyBjYW4gY29udGFpblxuICogY2lyY3VsYXIgcmVmZXJlbmNlcy4gSXTigJlzIGluIHRoZSBjbGllbnTigJlzIGJlc3QgaW50ZXJlc3QgdG8gdHJhdmVyc2UgdGhlXG4gKiB0cmVlIGluIHJhbmRvbSBvcmRlci5cbiAqL1xuZnVuY3Rpb24gc2VsZWN0UmFuZG9tUGF0aChicmFuY2hlczogc3RyaW5nW10sIGNvbnRleHQ6IFNlYXJjaENvbnRleHQpOiBzdHJpbmcge1xuICAvLyBJZGVudGlmeSBkb21haW5zIGFscmVhZHkgdmlzaXRlZCBpbiB0aGlzIHRyYXZlcnNhbCBvZiB0aGUgRE5TIHRyZWUuXG4gIC8vIFRoZW4gZmlsdGVyIGFnYWluc3QgdGhlbSB0byBwcmV2ZW50IGN5Y2xlcy5cbiAgY29uc3QgY2lyY3VsYXJSZWZzOiB7IFtrZXk6IG51bWJlcl06IGJvb2xlYW4gfSA9IHt9O1xuICBmb3IgKGNvbnN0IFtpZHgsIHN1YmRvbWFpbl0gb2YgYnJhbmNoZXMuZW50cmllcygpKSB7XG4gICAgaWYgKGNvbnRleHQudmlzaXRzW3N1YmRvbWFpbl0pIHtcbiAgICAgIGNpcmN1bGFyUmVmc1tpZHhdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gSWYgYWxsIHBvc3NpYmxlIHBhdGhzIGFyZSBjaXJjdWxhci4uLlxuICBpZiAoT2JqZWN0LmtleXMoY2lyY3VsYXJSZWZzKS5sZW5ndGggPT09IGJyYW5jaGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5yZXNvbHZhYmxlIGNpcmN1bGFyIHBhdGggZGV0ZWN0ZWQnKTtcbiAgfVxuXG4gIC8vIFJhbmRvbWx5IHNlbGVjdCBhIHZpYWJsZSBwYXRoXG4gIGxldCBpbmRleDtcbiAgZG8ge1xuICAgIGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYnJhbmNoZXMubGVuZ3RoKTtcbiAgfSB3aGlsZSAoY2lyY3VsYXJSZWZzW2luZGV4XSk7XG5cbiAgcmV0dXJuIGJyYW5jaGVzW2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyBmYWxzZSBpZiBjYW5kaWRhdGUgcGVlciBhbHJlYWR5IGV4aXN0cyBpbiB0aGVcbiAqICAgICAgICAgY3VycmVudCBjb2xsZWN0aW9uIG9mIHBlZXJzIGJhc2VkIG9uIHRoZSBub2RlIGlkIHZhbHVlO1xuICogICAgICAgICB0cnVlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNOZXdQZWVyKHBlZXI6IEVOUiB8IG51bGwsIHBlZXJzOiBFTlJbXSk6IGJvb2xlYW4ge1xuICBpZiAoIXBlZXIgfHwgIXBlZXIubm9kZUlkKSByZXR1cm4gZmFsc2U7XG5cbiAgZm9yIChjb25zdCBleGlzdGluZ1BlZXIgb2YgcGVlcnMpIHtcbiAgICBpZiAocGVlci5ub2RlSWQgPT09IGV4aXN0aW5nUGVlci5ub2RlSWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCB7IFR4dEFuc3dlciB9IGZyb20gJ2Rucy1wYWNrZXQnO1xuaW1wb3J0IHtcbiAgZW5kcG9pbnRzIGFzIGRlZmF1bHRFbmRwb2ludHMsXG4gIEVuZHBvaW50LFxuICBFbmRwb2ludFByb3BzLFxuICBxdWVyeSxcbn0gZnJvbSAnZG5zLXF1ZXJ5JztcblxuaW1wb3J0IHsgRG5zQ2xpZW50IH0gZnJvbSAnLi9kbnMnO1xuXG5jb25zdCB7IGNsb3VkZmxhcmUsIGdvb2dsZSwgb3BlbmRucyB9ID0gZGVmYXVsdEVuZHBvaW50cztcblxuZXhwb3J0IHR5cGUgRW5kcG9pbnRzID1cbiAgfCAnZG9oJ1xuICB8ICdkbnMnXG4gIHwgSXRlcmFibGU8RW5kcG9pbnQgfCBFbmRwb2ludFByb3BzIHwgc3RyaW5nPjtcblxuZXhwb3J0IGNsYXNzIERuc092ZXJIdHRwcyBpbXBsZW1lbnRzIERuc0NsaWVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgbmV3IERucy1PdmVyLUh0dHAgRE5TIGNsaWVudC5cbiAgICpcbiAgICogQHBhcmFtIGVuZHBvaW50cyBUaGUgZW5kcG9pbnRzIGZvciBEbnMtT3Zlci1IdHRwcyBxdWVyaWVzLlxuICAgKiBTZWUgW2Rucy1xdWVyeV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvZG5zLXF1ZXJ5KSBmb3IgZGV0YWlscy5cbiAgICogRGVmYXVsdHMgdG8gY2xvdWRmbGFyZSwgZ29vZ2xlIGFuZCBvcGVuZG5zLlxuICAgKlxuICAgKiBAdGhyb3dzIHtjb2RlOiBzdHJpbmd9IElmIEROUyBxdWVyeSBmYWlscy5cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgZW5kcG9pbnRzOiBFbmRwb2ludHMgPSBbY2xvdWRmbGFyZSwgZ29vZ2xlLCBvcGVuZG5zXVxuICApIHt9XG5cbiAgYXN5bmMgcmVzb2x2ZVRYVChkb21haW46IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHF1ZXJ5KHtcbiAgICAgIHF1ZXN0aW9uczogW3sgdHlwZTogJ1RYVCcsIG5hbWU6IGRvbWFpbiB9XSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGFuc3dlcnMgPSByZXNwb25zZS5hbnN3ZXJzIGFzIFR4dEFuc3dlcltdO1xuXG4gICAgY29uc3QgZGF0YSA9IGFuc3dlcnMubWFwKChhKSA9PiBhLmRhdGEpO1xuXG4gICAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZGF0YS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGQpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGQpKSB7XG4gICAgICAgIGQuZm9yRWFjaCgoc2QpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChCdWZmZXIuZnJvbShzZCkudG9TdHJpbmcoJ3V0Zi04JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChCdWZmZXIuZnJvbShkKS50b1N0cmluZygndXRmLTgnKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG4iLCJpbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmltcG9ydCBiYXNlNjR1cmwgZnJvbSAnYmFzZTY0dXJsJztcbmltcG9ydCAqIGFzIGJhc2UzMiBmcm9tICdoaS1iYXNlMzInO1xuaW1wb3J0IHsgZWNkc2FWZXJpZnkgfSBmcm9tICdzZWNwMjU2azEnO1xuXG5pbXBvcnQgeyBFTlIgfSBmcm9tICcuLi9lbnInO1xuaW1wb3J0IHsga2VjY2FrMjU2QnVmIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgdHlwZSBFTlJSb290VmFsdWVzID0ge1xuICBlUm9vdDogc3RyaW5nO1xuICBsUm9vdDogc3RyaW5nO1xuICBzZXE6IG51bWJlcjtcbiAgc2lnbmF0dXJlOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgdHlwZSBFTlJUcmVlVmFsdWVzID0ge1xuICBwdWJsaWNLZXk6IHN0cmluZztcbiAgZG9tYWluOiBzdHJpbmc7XG59O1xuXG5leHBvcnQgY2xhc3MgRU5SVHJlZSB7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUkVDT1JEX1BSRUZJWCA9IEVOUi5SRUNPUkRfUFJFRklYO1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFRSRUVfUFJFRklYID0gJ2VucnRyZWU6JztcbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBCUkFOQ0hfUFJFRklYID0gJ2VucnRyZWUtYnJhbmNoOic7XG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUk9PVF9QUkVGSVggPSAnZW5ydHJlZS1yb290Oic7XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBicmFuY2ggc3ViZG9tYWluIHJlZmVyZW5jZWQgYnkgYSBETlMgdHJlZSByb290IHN0cmluZyBhZnRlciB2ZXJpZnlpbmdcbiAgICogdGhlIHJvb3QgcmVjb3JkIHNpZ25hdHVyZSB3aXRoIGl0cyBiYXNlMzIgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICAgKi9cbiAgc3RhdGljIHBhcnNlQW5kVmVyaWZ5Um9vdChyb290OiBzdHJpbmcsIHB1YmxpY0tleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBhc3NlcnQoXG4gICAgICByb290LnN0YXJ0c1dpdGgodGhpcy5ST09UX1BSRUZJWCksXG4gICAgICBgRU5SVHJlZSByb290IGVudHJ5IG11c3Qgc3RhcnQgd2l0aCAnJHt0aGlzLlJPT1RfUFJFRklYfSdgXG4gICAgKTtcblxuICAgIGNvbnN0IHJvb3RWYWx1ZXMgPSBFTlJUcmVlLnBhcnNlUm9vdFZhbHVlcyhyb290KTtcbiAgICBjb25zdCBkZWNvZGVkUHVibGljS2V5ID0gYmFzZTMyLmRlY29kZS5hc0J5dGVzKHB1YmxpY0tleSk7XG5cbiAgICAvLyBUaGUgc2lnbmF0dXJlIGlzIGEgNjUtYnl0ZSBzZWNwMjU2azEgb3ZlciB0aGUga2VjY2FrMjU2IGhhc2hcbiAgICAvLyBvZiB0aGUgcmVjb3JkIGNvbnRlbnQsIGV4Y2x1ZGluZyB0aGUgYHNpZz1gIHBhcnQsIGVuY29kZWQgYXMgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ1xuICAgIC8vIChUcmFpbGluZyByZWNvdmVyeSBiaXQgbXVzdCBiZSB0cmltbWVkIHRvIHBhc3MgYGVjZHNhVmVyaWZ5YCBtZXRob2QpXG4gICAgY29uc3Qgc2lnbmVkQ29tcG9uZW50ID0gcm9vdC5zcGxpdCgnIHNpZycpWzBdO1xuICAgIGNvbnN0IHNpZ25lZENvbXBvbmVudEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNpZ25lZENvbXBvbmVudCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0gYmFzZTY0dXJsXG4gICAgICAudG9CdWZmZXIocm9vdFZhbHVlcy5zaWduYXR1cmUpXG4gICAgICAuc2xpY2UoMCwgNjQpO1xuICAgIGNvbnN0IGtleUJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRlY29kZWRQdWJsaWNLZXkpO1xuXG4gICAgY29uc3QgaXNWZXJpZmllZCA9IGVjZHNhVmVyaWZ5KFxuICAgICAgc2lnbmF0dXJlQnVmZmVyLFxuICAgICAga2VjY2FrMjU2QnVmKHNpZ25lZENvbXBvbmVudEJ1ZmZlciksXG4gICAgICBrZXlCdWZmZXJcbiAgICApO1xuXG4gICAgYXNzZXJ0KGlzVmVyaWZpZWQsICdVbmFibGUgdG8gdmVyaWZ5IEVOUlRyZWUgcm9vdCBzaWduYXR1cmUnKTtcblxuICAgIHJldHVybiByb290VmFsdWVzLmVSb290O1xuICB9XG5cbiAgc3RhdGljIHBhcnNlUm9vdFZhbHVlcyh0eHQ6IHN0cmluZyk6IEVOUlJvb3RWYWx1ZXMge1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0eHQubWF0Y2goXG4gICAgICAvXmVucnRyZWUtcm9vdDp2MSBlPShbXiBdKykgbD0oW14gXSspIHNlcT0oXFxkKykgc2lnPShbXiBdKykkL1xuICAgICk7XG5cbiAgICBhc3NlcnQub2soQXJyYXkuaXNBcnJheShtYXRjaGVzKSwgJ0NvdWxkIG5vdCBwYXJzZSBFTlJUcmVlIHJvb3QgZW50cnknKTtcblxuICAgIG1hdGNoZXMuc2hpZnQoKTsgLy8gVGhlIGZpcnN0IGVudHJ5IGlzIHRoZSBmdWxsIG1hdGNoXG4gICAgY29uc3QgW2VSb290LCBsUm9vdCwgc2VxLCBzaWduYXR1cmVdID0gbWF0Y2hlcztcblxuICAgIGFzc2VydC5vayhlUm9vdCwgXCJDb3VsZCBub3QgcGFyc2UgJ2UnIHZhbHVlIGZyb20gRU5SVHJlZSByb290IGVudHJ5XCIpO1xuICAgIGFzc2VydC5vayhsUm9vdCwgXCJDb3VsZCBub3QgcGFyc2UgJ2wnIHZhbHVlIGZyb20gRU5SVHJlZSByb290IGVudHJ5XCIpO1xuICAgIGFzc2VydC5vayhzZXEsIFwiQ291bGQgbm90IHBhcnNlICdzZXEnIHZhbHVlIGZyb20gRU5SVHJlZSByb290IGVudHJ5XCIpO1xuICAgIGFzc2VydC5vayhzaWduYXR1cmUsIFwiQ291bGQgbm90IHBhcnNlICdzaWcnIHZhbHVlIGZyb20gRU5SVHJlZSByb290IGVudHJ5XCIpO1xuXG4gICAgcmV0dXJuIHsgZVJvb3QsIGxSb290LCBzZXE6IE51bWJlcihzZXEpLCBzaWduYXR1cmUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwdWJsaWMga2V5IGFuZCB0b3AgbGV2ZWwgZG9tYWluIG9mIGFuIEVOUiB0cmVlIGVudHJ5LlxuICAgKiBUaGUgZG9tYWluIGlzIHRoZSBzdGFydGluZyBwb2ludCBmb3IgdHJhdmVyc2luZyBhIHNldCBvZiBsaW5rZWQgRE5TIFRYVCByZWNvcmRzXG4gICAqIGFuZCB0aGUgcHVibGljIGtleSBpcyB1c2VkIHRvIHZlcmlmeSB0aGUgcm9vdCBlbnRyeSByZWNvcmRcbiAgICovXG4gIHN0YXRpYyBwYXJzZVRyZWUodHJlZTogc3RyaW5nKTogRU5SVHJlZVZhbHVlcyB7XG4gICAgYXNzZXJ0KFxuICAgICAgdHJlZS5zdGFydHNXaXRoKHRoaXMuVFJFRV9QUkVGSVgpLFxuICAgICAgYEVOUlRyZWUgdHJlZSBlbnRyeSBtdXN0IHN0YXJ0IHdpdGggJyR7dGhpcy5UUkVFX1BSRUZJWH0nYFxuICAgICk7XG5cbiAgICBjb25zdCBtYXRjaGVzID0gdHJlZS5tYXRjaCgvXmVucnRyZWU6XFwvXFwvKFteQF0rKUAoLispJC8pO1xuXG4gICAgYXNzZXJ0Lm9rKEFycmF5LmlzQXJyYXkobWF0Y2hlcyksICdDb3VsZCBub3QgcGFyc2UgRU5SVHJlZSB0cmVlIGVudHJ5Jyk7XG5cbiAgICBtYXRjaGVzLnNoaWZ0KCk7IC8vIFRoZSBmaXJzdCBlbnRyeSBpcyB0aGUgZnVsbCBtYXRjaFxuICAgIGNvbnN0IFtwdWJsaWNLZXksIGRvbWFpbl0gPSBtYXRjaGVzO1xuXG4gICAgYXNzZXJ0Lm9rKHB1YmxpY0tleSwgJ0NvdWxkIG5vdCBwYXJzZSBwdWJsaWMga2V5IGZyb20gRU5SVHJlZSB0cmVlIGVudHJ5Jyk7XG4gICAgYXNzZXJ0Lm9rKGRvbWFpbiwgJ0NvdWxkIG5vdCBwYXJzZSBkb21haW4gZnJvbSBFTlJUcmVlIHRyZWUgZW50cnknKTtcblxuICAgIHJldHVybiB7IHB1YmxpY0tleSwgZG9tYWluIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzdWJkb21haW5zIGxpc3RlZCBpbiBhbiBFTlIgYnJhbmNoIGVudHJ5LiBUaGVzZSBpbiB0dXJuIGxlYWQgdG9cbiAgICogZWl0aGVyIGZ1cnRoZXIgYnJhbmNoIGVudHJpZXMgb3IgRU5SIHJlY29yZHMuXG4gICAqL1xuICBzdGF0aWMgcGFyc2VCcmFuY2goYnJhbmNoOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgYXNzZXJ0KFxuICAgICAgYnJhbmNoLnN0YXJ0c1dpdGgodGhpcy5CUkFOQ0hfUFJFRklYKSxcbiAgICAgIGBFTlJUcmVlIGJyYW5jaCBlbnRyeSBtdXN0IHN0YXJ0IHdpdGggJyR7dGhpcy5CUkFOQ0hfUFJFRklYfSdgXG4gICAgKTtcblxuICAgIHJldHVybiBicmFuY2guc3BsaXQodGhpcy5CUkFOQ0hfUFJFRklYKVsxXS5zcGxpdCgnLCcpO1xuICB9XG59XG4iLCIvKipcbiAqIEdFVCBsaXN0IG9mIG5vZGVzIGZyb20gcmVtb3RlIEhUVFAgaG9zdC5cbiAqXG4gKiBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHJldHVybiBub2RlcyBob3N0ZWQgYnkgU3RhdHVzLlxuICpcbiAqIEBwYXJhbSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIGFjY2VzcyB0aGUgbm9kZSBsaXN0LiBUaGUgcmVzdWx0IHNob3VsZCBiZVxuICogYSBzdHJpbmcsIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC4gSWYgdGhlIHJlc3VsdCBpcyBhbiBvYmplY3QgdGhlbiB0aGVcbiAqIHZhbHVlcyBvZiB0aGUgb2JqZWN0cyBhcmUgdXNlZCBhcyBtdWx0aWFkZHJlc3Nlcy4gRm9yIGV4YW1wbGUsIGlmIHRoZSBHRVRcbiAqIHJlcXVlc3QgcmV0dXJucyBgeyBmb286IHsgYmFyOiBbYWRkcmVzczEsIGFkZHJlc3MyXSB9IH1gIHRoZW4gYHBhdGhgIHNob3VsZCBiZVxuICogYFsgXCJmb29cIiwgXCJiYXJcIiBdYC5cbiAqIEBwYXJhbSB1cmwgUmVtb3RlIGhvc3QgY29udGFpbmluZyBib290c3RyYXAgcGVlcnMgaW4gSlNPTiBmb3JtYXQuXG4gKiBAcGFyYW0gd2FudGVkTnVtYmVyIFRoZSBudW1iZXIgb2YgY29ubmVjdGlvbnMgZGVzaXJlZC4gRGVmYXVsdHMgdG8gW0RlZmF1bHRXYW50ZWROdW1iZXJdLlxuICpcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG11bHRpYWRkcmVzc2VzLlxuICogQHRocm93cyBJZiB0aGUgcmVtb3RlIGhvc3QgaXMgdW5yZWFjaGFibGUgb3IgdGhlIHJlc3BvbnNlIGNhbm5vdCBiZSBwYXJzZWRcbiAqIGFjY29yZGluZyB0byB0aGUgcGFzc2VkIF9wYXRoXy5cbiAqL1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5pbXBvcnQgeyBNdWx0aWFkZHIgfSBmcm9tICdtdWx0aWFkZHInO1xuXG5pbXBvcnQgeyBnZXRQc2V1ZG9SYW5kb21TdWJzZXQgfSBmcm9tICcuL2luZGV4JztcbmNvbnN0IGRiZyA9IGRlYnVnKCd3YWt1OmRpc2NvdmVyeScpO1xuXG5jb25zdCBEZWZhdWx0V2FudGVkTnVtYmVyID0gMTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE5vZGVzRnJvbUhvc3RlZEpzb24oXG4gIHBhdGg6IHN0cmluZ1tdID0gWydmbGVldHMnLCAnd2FrdXYyLnByb2QnLCAnd2FrdS13ZWJzb2NrZXQnXSxcbiAgdXJsID0gJ2h0dHBzOi8vZmxlZXRzLnN0YXR1cy5pbS8nLFxuICB3YW50ZWROdW1iZXI6IG51bWJlciA9IERlZmF1bHRXYW50ZWROdW1iZXJcbik6IFByb21pc2U8TXVsdGlhZGRyW10+IHtcbiAgaWYgKHdhbnRlZE51bWJlciA8PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgcmVzID0gYXdhaXQgYXhpb3MuZ2V0KHVybCwge1xuICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICB9KTtcblxuICBsZXQgbm9kZXMgPSByZXMuZGF0YTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2YgcGF0aCkge1xuICAgIGlmIChub2Rlc1twcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYmcoXG4gICAgICAgIGBGYWlsZWQgdG8gcmV0cmlldmUgYm9vdHN0cmFwIG5vZGVzOiAke3Byb3B9IGRvZXMgbm90IGV4aXN0IG9uIGAsXG4gICAgICAgIG5vZGVzXG4gICAgICApO1xuICAgICAgdGhyb3cgYEZhaWxlZCB0byByZXRyaWV2ZSBib290c3RyYXAgbm9kZXM6ICR7cHJvcH0gZG9lcyBub3QgZXhpc3Qgb24gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgbm9kZXNcbiAgICAgICl9YDtcbiAgICB9XG4gICAgbm9kZXMgPSBub2Rlc1twcm9wXTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgIHJldHVybiBnZXRQc2V1ZG9SYW5kb21TdWJzZXQobm9kZXMsIHdhbnRlZE51bWJlcikubWFwKFxuICAgICAgKG5vZGU6IHN0cmluZykgPT4gbmV3IE11bHRpYWRkcihub2RlKVxuICAgICk7XG4gIH1cblxuICBpZiAodHlwZW9mIG5vZGVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBbbmV3IE11bHRpYWRkcihub2RlcyldO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBub2RlcyA9PT0gJ29iamVjdCcpIHtcbiAgICBub2RlcyA9IE9iamVjdC52YWx1ZXMobm9kZXMpIGFzIHN0cmluZ1tdO1xuICAgIG5vZGVzID0gbm9kZXMubWFwKChub2RlOiBzdHJpbmcpID0+IG5ldyBNdWx0aWFkZHIobm9kZSkpO1xuICAgIHJldHVybiBnZXRQc2V1ZG9SYW5kb21TdWJzZXQobm9kZXMsIHdhbnRlZE51bWJlcik7XG4gIH1cblxuICB0aHJvdyBgRmFpbGVkIHRvIHJldHJpZXZlIGJvb3RzdHJhcCBub2RlczogcmVzcG9uc2UgZm9ybWF0IGlzIG5vdCBzdXBwb3J0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgbm9kZXNcbiAgKX1gO1xufVxuIiwiaW1wb3J0IHsgc2h1ZmZsZSB9IGZyb20gJ2xpYnAycC1nb3NzaXBzdWIvc3JjL3V0aWxzJztcblxuZXhwb3J0IHsgZ2V0Tm9kZXNGcm9tSG9zdGVkSnNvbiB9IGZyb20gJy4vaG9zdGVkX2pzb24nO1xuZXhwb3J0IHsgQm9vdHN0cmFwLCBCb290c3RyYXBPcHRpb25zIH0gZnJvbSAnLi9ib290c3RyYXAnO1xuZXhwb3J0IHsgRG5zQ2xpZW50LCBEbnNOb2RlRGlzY292ZXJ5LCBTZWFyY2hDb250ZXh0IH0gZnJvbSAnLi9kbnMnO1xuZXhwb3J0IHsgRW5kcG9pbnRzLCBEbnNPdmVySHR0cHMgfSBmcm9tICcuL2Ruc19vdmVyX2h0dHBzJztcbmV4cG9ydCB7IEVOUlRyZWUsIEVOUlRyZWVWYWx1ZXMsIEVOUlJvb3RWYWx1ZXMgfSBmcm9tICcuL2VucnRyZWUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHNldWRvUmFuZG9tU3Vic2V0PFQ+KFxuICB2YWx1ZXM6IFRbXSxcbiAgd2FudGVkTnVtYmVyOiBudW1iZXJcbik6IFRbXSB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoIDw9IHdhbnRlZE51bWJlcikge1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICByZXR1cm4gc2h1ZmZsZSh2YWx1ZXMpLnNsaWNlKDAsIHdhbnRlZE51bWJlcik7XG59XG4iLCIvLyBNYXhpbXVtIGVuY29kZWQgc2l6ZSBvZiBhbiBFTlJcbmV4cG9ydCBjb25zdCBNQVhfUkVDT1JEX1NJWkUgPSAzMDA7XG5cbmV4cG9ydCBjb25zdCBFUlJfSU5WQUxJRF9JRCA9ICdJbnZhbGlkIHJlY29yZCBpZCc7XG5cbmV4cG9ydCBjb25zdCBFUlJfTk9fU0lHTkFUVVJFID0gJ05vIHZhbGlkIHNpZ25hdHVyZSBmb3VuZCc7XG5cbi8vIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiBieXRlIHNpemUgb2YgYSBtdWx0aWFkZHIgdG8gZW5jb2RlIGluIHRoZSBgbXVsdGlhZGRyYCBmaWVsZFxuLy8gVGhlIHNpemUgaXMgYSBiaWcgZW5kaWFuIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyXG5leHBvcnQgY29uc3QgTVVMVElBRERSX0xFTkdUSF9TSVpFID0gMjtcbiIsImltcG9ydCB7IGJ1ZlRvSGV4IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBOb2RlSWQgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vZGVJZChidWZmZXI6IEJ1ZmZlcik6IE5vZGVJZCB7XG4gIGlmIChidWZmZXIubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm9kZUlkIG11c3QgYmUgMzIgYnl0ZXMgaW4gbGVuZ3RoJyk7XG4gIH1cbiAgcmV0dXJuIGJ1ZlRvSGV4KGJ1ZmZlcik7XG59XG4iLCJpbXBvcnQgYmFzZTY0dXJsIGZyb20gJ2Jhc2U2NHVybCc7XG5pbXBvcnQgeyB0b0JpZ0ludEJFIH0gZnJvbSAnYmlnaW50LWJ1ZmZlcic7XG5pbXBvcnQgeyBNdWx0aWFkZHIsIHByb3RvY29scyB9IGZyb20gJ211bHRpYWRkcic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4vLyBAdHMtaWdub3JlOiBObyB0eXBlcyBhdmFpbGFibGVcbmltcG9ydCBtdUNvbnZlcnQgZnJvbSAnbXVsdGlhZGRyL3NyYy9jb252ZXJ0JztcbmltcG9ydCBQZWVySWQgZnJvbSAncGVlci1pZCc7XG5pbXBvcnQgKiBhcyBSTFAgZnJvbSAncmxwJztcbmltcG9ydCB7IGVuY29kZSBhcyB2YXJpbnRFbmNvZGUgfSBmcm9tICd2YXJpbnQnO1xuXG5pbXBvcnQge1xuICBFUlJfSU5WQUxJRF9JRCxcbiAgRVJSX05PX1NJR05BVFVSRSxcbiAgTUFYX1JFQ09SRF9TSVpFLFxuICBNVUxUSUFERFJfTEVOR1RIX1NJWkUsXG59IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7XG4gIGNyZWF0ZUtleXBhaXIsXG4gIGNyZWF0ZUtleXBhaXJGcm9tUGVlcklkLFxuICBjcmVhdGVQZWVySWRGcm9tS2V5cGFpcixcbiAgSUtleXBhaXIsXG4gIEtleXBhaXJUeXBlLFxufSBmcm9tICcuL2tleXBhaXInO1xuaW1wb3J0IHsgRU5SS2V5LCBFTlJWYWx1ZSwgTm9kZUlkLCBTZXF1ZW5jZU51bWJlciB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0ICogYXMgdjQgZnJvbSAnLi92NCc7XG5cbmV4cG9ydCBjbGFzcyBFTlIgZXh0ZW5kcyBNYXA8RU5SS2V5LCBFTlJWYWx1ZT4ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFJFQ09SRF9QUkVGSVggPSAnZW5yOic7XG4gIHB1YmxpYyBzZXE6IFNlcXVlbmNlTnVtYmVyO1xuICBwdWJsaWMgc2lnbmF0dXJlOiBCdWZmZXIgfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGt2czogUmVjb3JkPEVOUktleSwgRU5SVmFsdWU+ID0ge30sXG4gICAgc2VxOiBTZXF1ZW5jZU51bWJlciA9IDFuLFxuICAgIHNpZ25hdHVyZTogQnVmZmVyIHwgbnVsbCA9IG51bGxcbiAgKSB7XG4gICAgc3VwZXIoT2JqZWN0LmVudHJpZXMoa3ZzKSk7XG4gICAgdGhpcy5zZXEgPSBzZXE7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlVjQocHVibGljS2V5OiBCdWZmZXIsIGt2czogUmVjb3JkPEVOUktleSwgRU5SVmFsdWU+ID0ge30pOiBFTlIge1xuICAgIHJldHVybiBuZXcgRU5SKHtcbiAgICAgIC4uLmt2cyxcbiAgICAgIGlkOiBCdWZmZXIuZnJvbSgndjQnKSxcbiAgICAgIHNlY3AyNTZrMTogcHVibGljS2V5LFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZUZyb21QZWVySWQoXG4gICAgcGVlcklkOiBQZWVySWQsXG4gICAga3ZzOiBSZWNvcmQ8RU5SS2V5LCBFTlJWYWx1ZT4gPSB7fVxuICApOiBFTlIge1xuICAgIGNvbnN0IGtleXBhaXIgPSBjcmVhdGVLZXlwYWlyRnJvbVBlZXJJZChwZWVySWQpO1xuICAgIHN3aXRjaCAoa2V5cGFpci50eXBlKSB7XG4gICAgICBjYXNlIEtleXBhaXJUeXBlLnNlY3AyNTZrMTpcbiAgICAgICAgcmV0dXJuIEVOUi5jcmVhdGVWNChrZXlwYWlyLnB1YmxpY0tleSwga3ZzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGVGcm9tVmFsdWVzKGRlY29kZWQ6IEJ1ZmZlcltdKTogRU5SIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGVjb2RlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlZCBFTlIgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIH1cbiAgICBpZiAoZGVjb2RlZC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29kZWQgRU5SIG11c3QgaGF2ZSBhbiBldmVuIG51bWJlciBvZiBlbGVtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCBbc2lnbmF0dXJlLCBzZXEsIC4uLmt2c10gPSBkZWNvZGVkO1xuICAgIGlmICghc2lnbmF0dXJlIHx8IEFycmF5LmlzQXJyYXkoc2lnbmF0dXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvZGVkIEVOUiBpbnZhbGlkIHNpZ25hdHVyZTogbXVzdCBiZSBhIGJ5dGUgYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKCFzZXEgfHwgQXJyYXkuaXNBcnJheShzZXEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdEZWNvZGVkIEVOUiBpbnZhbGlkIHNlcXVlbmNlIG51bWJlcjogbXVzdCBiZSBhIGJ5dGUgYXJyYXknXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvYmo6IFJlY29yZDxFTlJLZXksIEVOUlZhbHVlPiA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga3ZzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBvYmpba3ZzW2ldLnRvU3RyaW5nKCldID0gQnVmZmVyLmZyb20oa3ZzW2kgKyAxXSk7XG4gICAgfVxuICAgIGNvbnN0IGVuciA9IG5ldyBFTlIob2JqLCB0b0JpZ0ludEJFKHNlcSksIHNpZ25hdHVyZSk7XG5cbiAgICBpZiAoIWVuci52ZXJpZnkoUkxQLmVuY29kZShbc2VxLCAuLi5rdnNdKSwgc2lnbmF0dXJlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gdmVyaWZ5IEVOUiBzaWduYXR1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGVucjtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGUoZW5jb2RlZDogQnVmZmVyKTogRU5SIHtcbiAgICBjb25zdCBkZWNvZGVkID0gUkxQLmRlY29kZShlbmNvZGVkKSBhcyB1bmtub3duIGFzIEJ1ZmZlcltdO1xuICAgIHJldHVybiBFTlIuZGVjb2RlRnJvbVZhbHVlcyhkZWNvZGVkKTtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGVUeHQoZW5jb2RlZDogc3RyaW5nKTogRU5SIHtcbiAgICBpZiAoIWVuY29kZWQuc3RhcnRzV2l0aCh0aGlzLlJFQ09SRF9QUkVGSVgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBcInN0cmluZyBlbmNvZGVkIEVOUiBtdXN0IHN0YXJ0IHdpdGggJyR7dGhpcy5SRUNPUkRfUFJFRklYfSdgXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gRU5SLmRlY29kZShiYXNlNjR1cmwudG9CdWZmZXIoZW5jb2RlZC5zbGljZSg0KSkpO1xuICB9XG5cbiAgc2V0KGs6IEVOUktleSwgdjogRU5SVmFsdWUpOiB0aGlzIHtcbiAgICB0aGlzLnNpZ25hdHVyZSA9IG51bGw7XG4gICAgdGhpcy5zZXErKztcbiAgICByZXR1cm4gc3VwZXIuc2V0KGssIHYpO1xuICB9XG5cbiAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdldCgnaWQnKSBhcyBCdWZmZXI7XG4gICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKCdpZCBub3QgZm91bmQuJyk7XG4gICAgcmV0dXJuIGlkLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cblxuICBnZXQga2V5cGFpclR5cGUoKTogS2V5cGFpclR5cGUge1xuICAgIHN3aXRjaCAodGhpcy5pZCkge1xuICAgICAgY2FzZSAndjQnOlxuICAgICAgICByZXR1cm4gS2V5cGFpclR5cGUuc2VjcDI1NmsxO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9JTlZBTElEX0lEKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcHVibGljS2V5KCk6IEJ1ZmZlciB7XG4gICAgc3dpdGNoICh0aGlzLmlkKSB7XG4gICAgICBjYXNlICd2NCc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldCgnc2VjcDI1NmsxJykgYXMgQnVmZmVyO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9JTlZBTElEX0lEKTtcbiAgICB9XG4gIH1cblxuICBnZXQga2V5cGFpcigpOiBJS2V5cGFpciB7XG4gICAgcmV0dXJuIGNyZWF0ZUtleXBhaXIodGhpcy5rZXlwYWlyVHlwZSwgdW5kZWZpbmVkLCB0aGlzLnB1YmxpY0tleSk7XG4gIH1cblxuICBnZXQgcGVlcklkKCk6IFBlZXJJZCB7XG4gICAgcmV0dXJuIGNyZWF0ZVBlZXJJZEZyb21LZXlwYWlyKHRoaXMua2V5cGFpcik7XG4gIH1cblxuICBnZXQgbm9kZUlkKCk6IE5vZGVJZCB7XG4gICAgc3dpdGNoICh0aGlzLmlkKSB7XG4gICAgICBjYXNlICd2NCc6XG4gICAgICAgIHJldHVybiB2NC5ub2RlSWQodGhpcy5wdWJsaWNLZXkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9JTlZBTElEX0lEKTtcbiAgICB9XG4gIH1cblxuICBnZXQgaXAoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByYXcgPSB0aGlzLmdldCgnaXAnKTtcbiAgICBpZiAocmF3KSB7XG4gICAgICByZXR1cm4gbXVDb252ZXJ0LnRvU3RyaW5nKHByb3RvY29scy5uYW1lcy5pcDQuY29kZSwgcmF3KSBhcyBzdHJpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgc2V0IGlwKGlwOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXApIHtcbiAgICAgIHRoaXMuc2V0KCdpcCcsIG11Q29udmVydC50b0J5dGVzKHByb3RvY29scy5uYW1lcy5pcDQuY29kZSwgaXApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWxldGUoJ2lwJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHRjcCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuZ2V0KCd0Y3AnKTtcbiAgICBpZiAocmF3KSB7XG4gICAgICByZXR1cm4gTnVtYmVyKG11Q29udmVydC50b1N0cmluZyhwcm90b2NvbHMubmFtZXMudGNwLmNvZGUsIHJhdykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHNldCB0Y3AocG9ydDogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kZWxldGUoJ3RjcCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldCgndGNwJywgbXVDb252ZXJ0LnRvQnl0ZXMocHJvdG9jb2xzLm5hbWVzLnRjcC5jb2RlLCBwb3J0KSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHVkcCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuZ2V0KCd1ZHAnKTtcbiAgICBpZiAocmF3KSB7XG4gICAgICByZXR1cm4gTnVtYmVyKG11Q29udmVydC50b1N0cmluZyhwcm90b2NvbHMubmFtZXMudWRwLmNvZGUsIHJhdykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHNldCB1ZHAocG9ydDogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kZWxldGUoJ3VkcCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldCgndWRwJywgbXVDb252ZXJ0LnRvQnl0ZXMocHJvdG9jb2xzLm5hbWVzLnVkcC5jb2RlLCBwb3J0KSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlwNigpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuZ2V0KCdpcDYnKTtcbiAgICBpZiAocmF3KSB7XG4gICAgICByZXR1cm4gbXVDb252ZXJ0LnRvU3RyaW5nKHByb3RvY29scy5uYW1lcy5pcDYuY29kZSwgcmF3KSBhcyBzdHJpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgc2V0IGlwNihpcDogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlwKSB7XG4gICAgICB0aGlzLnNldCgnaXA2JywgbXVDb252ZXJ0LnRvQnl0ZXMocHJvdG9jb2xzLm5hbWVzLmlwNi5jb2RlLCBpcCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlbGV0ZSgnaXA2Jyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHRjcDYoKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByYXcgPSB0aGlzLmdldCgndGNwNicpO1xuICAgIGlmIChyYXcpIHtcbiAgICAgIHJldHVybiBOdW1iZXIobXVDb252ZXJ0LnRvU3RyaW5nKHByb3RvY29scy5uYW1lcy50Y3AuY29kZSwgcmF3KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgc2V0IHRjcDYocG9ydDogbnVtYmVyIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5kZWxldGUoJ3RjcDYnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoJ3RjcDYnLCBtdUNvbnZlcnQudG9CeXRlcyhwcm90b2NvbHMubmFtZXMudGNwLmNvZGUsIHBvcnQpKTtcbiAgICB9XG4gIH1cblxuICBnZXQgdWRwNigpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHJhdyA9IHRoaXMuZ2V0KCd1ZHA2Jyk7XG4gICAgaWYgKHJhdykge1xuICAgICAgcmV0dXJuIE51bWJlcihtdUNvbnZlcnQudG9TdHJpbmcocHJvdG9jb2xzLm5hbWVzLnVkcC5jb2RlLCByYXcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBzZXQgdWRwNihwb3J0OiBudW1iZXIgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAocG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmRlbGV0ZSgndWRwNicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldCgndWRwNicsIG11Q29udmVydC50b0J5dGVzKHByb3RvY29scy5uYW1lcy51ZHAuY29kZSwgcG9ydCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGBtdWx0aWFkZHJzYCBmaWVsZCBmcm9tIEVOUi5cbiAgICpcbiAgICogVGhpcyBmaWVsZCBpcyB1c2VkIHRvIHN0b3JlIG11bHRpYWRkcmVzc2VzIHRoYXQgY2Fubm90IGJlIHN0b3JlZCB3aXRoIHRoZSBjdXJyZW50IEVOUiBwcmUtZGVmaW5lZCBrZXlzLlxuICAgKiBUaGVzZSBjYW4gYmUgYSBtdWx0aWFkZHJlc3NlcyB0aGF0IGluY2x1ZGUgZW5jYXBzdWxhdGlvbiAoZS5nLiB3c3MpIG9yIGRvIG5vdCB1c2UgYGlwNGAgbm9yIGBpcDZgIGZvciB0aGUgaG9zdFxuICAgKiBhZGRyZXNzIChlLmcuIGBkbnM0YCwgYGRuc2FkZHJgLCBldGMpLi5cbiAgICpcbiAgICogSWYgdGhlIHBlZXIgaW5mb3JtYXRpb24gb25seSBjb250YWlucyBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCB3aXRoIHRoZSBFTlIgcHJlLWRlZmluZWQga2V5c1xuICAgKiAoaXAsIHRjcCwgZXRjKSB0aGVuIHRoZSB1c2FnZSBvZiBbW2dldExvY2F0aW9uTXVsdGlhZGRyXV0gc2hvdWxkIGJlIHByZWZlcnJlZC5cbiAgICpcbiAgICogVGhlIG11bHRpYWRkcmVzc2VzIHN0b3JlZCBpbiB0aGlzIGZpZWxkIGFyZSBleHBlY3RlZCB0byBiZSBsb2NhdGlvbiBtdWx0aWFkZHJlc3NlcywgaWUsIHBlZXIgaWQgbGVzcy5cbiAgICovXG4gIGdldCBtdWx0aWFkZHJzKCk6IE11bHRpYWRkcltdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByYXcgPSB0aGlzLmdldCgnbXVsdGlhZGRycycpO1xuXG4gICAgaWYgKHJhdykge1xuICAgICAgY29uc3QgbXVsdGlhZGRycyA9IFtdO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IHJhdy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBzaXplQnl0ZXMgPSByYXcuc2xpY2UoaW5kZXgsIGluZGV4ICsgMik7XG4gICAgICAgICAgY29uc3Qgc2l6ZSA9IEJ1ZmZlci5mcm9tKHNpemVCeXRlcykucmVhZFVJbnQxNkJFKDApO1xuXG4gICAgICAgICAgY29uc3QgbXVsdGlhZGRyQnl0ZXMgPSByYXcuc2xpY2UoXG4gICAgICAgICAgICBpbmRleCArIE1VTFRJQUREUl9MRU5HVEhfU0laRSxcbiAgICAgICAgICAgIGluZGV4ICsgc2l6ZSArIE1VTFRJQUREUl9MRU5HVEhfU0laRVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgbXVsdGlhZGRyID0gbmV3IE11bHRpYWRkcihtdWx0aWFkZHJCeXRlcyk7XG5cbiAgICAgICAgICBtdWx0aWFkZHJzLnB1c2gobXVsdGlhZGRyKTtcbiAgICAgICAgICBpbmRleCArPSBzaXplICsgTVVMVElBRERSX0xFTkdUSF9TSVpFO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBpbiBtdWx0aWFkZHJzIGZpZWxkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbXVsdGlhZGRycztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBgbXVsdGlhZGRyc2AgZmllbGQgb24gdGhlIEVOUi5cbiAgICpcbiAgICogVGhpcyBmaWVsZCBpcyB1c2VkIHRvIHN0b3JlIG11bHRpYWRkcmVzc2VzIHRoYXQgY2Fubm90IGJlIHN0b3JlZCB3aXRoIHRoZSBjdXJyZW50IEVOUiBwcmUtZGVmaW5lZCBrZXlzLlxuICAgKiBUaGVzZSBjYW4gYmUgYSBtdWx0aWFkZHJlc3NlcyB0aGF0IGluY2x1ZGUgZW5jYXBzdWxhdGlvbiAoZS5nLiB3c3MpIG9yIGRvIG5vdCB1c2UgYGlwNGAgbm9yIGBpcDZgIGZvciB0aGUgaG9zdFxuICAgKiBhZGRyZXNzIChlLmcuIGBkbnM0YCwgYGRuc2FkZHJgLCBldGMpLi5cbiAgICpcbiAgICogSWYgdGhlIHBlZXIgaW5mb3JtYXRpb24gb25seSBjb250YWlucyBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCB3aXRoIHRoZSBFTlIgcHJlLWRlZmluZWQga2V5c1xuICAgKiAoaXAsIHRjcCwgZXRjKSB0aGVuIHRoZSB1c2FnZSBvZiBbW3NldExvY2F0aW9uTXVsdGlhZGRyXV0gc2hvdWxkIGJlIHByZWZlcnJlZC5cbiAgICpcbiAgICogVGhlIG11bHRpYWRkcmVzc2VzIHN0b3JlZCBpbiB0aGlzIGZpZWxkIG11c3QgdG8gYmUgbG9jYXRpb24gbXVsdGlhZGRyZXNzZXMsIGllLCBwZWVyIGlkIGxlc3MuXG4gICAqL1xuICBzZXQgbXVsdGlhZGRycyhtdWx0aWFkZHJzOiBNdWx0aWFkZHJbXSB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChtdWx0aWFkZHJzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGVsZXRlKCdtdWx0aWFkZHJzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBtdWx0aWFkZHJzQnVmID0gQnVmZmVyLmZyb20oW10pO1xuXG4gICAgICBtdWx0aWFkZHJzLmZvckVhY2goKG11bHRpYWRkcikgPT4ge1xuICAgICAgICBpZiAobXVsdGlhZGRyLmdldFBlZXJJZCgpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYG11bHRpYWRkcmAgZmllbGQgTVVTVCBub3QgY29udGFpbiBwZWVyIGlkJyk7XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBtdWx0aWFkZHIuYnl0ZXM7XG5cbiAgICAgICAgbGV0IGJ1ZiA9IEJ1ZmZlci5hbGxvYygyKTtcblxuICAgICAgICAvLyBQcmVwZW5kIHRoZSBzaXplIG9mIHRoZSBuZXh0IGVudHJ5XG4gICAgICAgIGNvbnN0IHdyaXR0ZW4gPSBidWYud3JpdGVVSW50MTZCRShieXRlcy5sZW5ndGgsIDApO1xuXG4gICAgICAgIGlmICh3cml0dGVuICE9PSBNVUxUSUFERFJfTEVOR1RIX1NJWkUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW50ZXJuYWwgZXJyb3I6IHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyIHdhcyBub3Qgd3JpdHRlbiBpbiAke01VTFRJQUREUl9MRU5HVEhfU0laRX0gYnl0ZXNgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW2J1ZiwgYnl0ZXNdKTtcblxuICAgICAgICBtdWx0aWFkZHJzQnVmID0gQnVmZmVyLmNvbmNhdChbbXVsdGlhZGRyc0J1ZiwgYnVmXSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zZXQoJ211bHRpYWRkcnMnLCBtdWx0aWFkZHJzQnVmKTtcbiAgICB9XG4gIH1cblxuICBnZXRMb2NhdGlvbk11bHRpYWRkcihcbiAgICBwcm90b2NvbDogJ3VkcCcgfCAndWRwNCcgfCAndWRwNicgfCAndGNwJyB8ICd0Y3A0JyB8ICd0Y3A2J1xuICApOiBNdWx0aWFkZHIgfCB1bmRlZmluZWQge1xuICAgIGlmIChwcm90b2NvbCA9PT0gJ3VkcCcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25NdWx0aWFkZHIoJ3VkcDQnKSB8fCB0aGlzLmdldExvY2F0aW9uTXVsdGlhZGRyKCd1ZHA2JylcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwcm90b2NvbCA9PT0gJ3RjcCcpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZ2V0TG9jYXRpb25NdWx0aWFkZHIoJ3RjcDQnKSB8fCB0aGlzLmdldExvY2F0aW9uTXVsdGlhZGRyKCd0Y3A2JylcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGlzSXB2NiA9IHByb3RvY29sLmVuZHNXaXRoKCc2Jyk7XG4gICAgY29uc3QgaXBWYWwgPSB0aGlzLmdldChpc0lwdjYgPyAnaXA2JyA6ICdpcCcpO1xuICAgIGlmICghaXBWYWwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaXNVZHAgPSBwcm90b2NvbC5zdGFydHNXaXRoKCd1ZHAnKTtcbiAgICBjb25zdCBpc1RjcCA9IHByb3RvY29sLnN0YXJ0c1dpdGgoJ3RjcCcpO1xuICAgIGxldCBwcm90b05hbWUsIHByb3RvVmFsO1xuICAgIGlmIChpc1VkcCkge1xuICAgICAgcHJvdG9OYW1lID0gJ3VkcCc7XG4gICAgICBwcm90b1ZhbCA9IGlzSXB2NiA/IHRoaXMuZ2V0KCd1ZHA2JykgOiB0aGlzLmdldCgndWRwJyk7XG4gICAgfSBlbHNlIGlmIChpc1RjcCkge1xuICAgICAgcHJvdG9OYW1lID0gJ3RjcCc7XG4gICAgICBwcm90b1ZhbCA9IGlzSXB2NiA/IHRoaXMuZ2V0KCd0Y3A2JykgOiB0aGlzLmdldCgndGNwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghcHJvdG9WYWwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHJhdyBtdWx0aWFkZHIgYnVmZmVyXG4gICAgLy8gbXVsdGlhZGRyIGxlbmd0aCBpczpcbiAgICAvLyAgMSBieXRlIGZvciB0aGUgaXAgcHJvdG9jb2wgKGlwNCBvciBpcDYpXG4gICAgLy8gIE4gYnl0ZXMgZm9yIHRoZSBpcCBhZGRyZXNzXG4gICAgLy8gIDEgb3IgMiBieXRlcyBmb3IgdGhlIHByb3RvY29sIGFzIGJ1ZmZlciAodGNwIG9yIHVkcClcbiAgICAvLyAgMiBieXRlcyBmb3IgdGhlIHBvcnRcbiAgICBjb25zdCBpcE1hID0gcHJvdG9jb2xzLm5hbWVzW2lzSXB2NiA/ICdpcDYnIDogJ2lwNCddO1xuICAgIGNvbnN0IGlwQnl0ZUxlbiA9IGlwTWEuc2l6ZSAvIDg7XG4gICAgY29uc3QgcHJvdG9NYSA9IHByb3RvY29scy5uYW1lc1twcm90b05hbWVdO1xuICAgIGNvbnN0IHByb3RvQnVmID0gdmFyaW50RW5jb2RlKHByb3RvTWEuY29kZSk7XG4gICAgY29uc3QgbWFCdWYgPSBuZXcgVWludDhBcnJheSgzICsgaXBCeXRlTGVuICsgcHJvdG9CdWYubGVuZ3RoKTtcbiAgICBtYUJ1ZlswXSA9IGlwTWEuY29kZTtcbiAgICBtYUJ1Zi5zZXQoaXBWYWwsIDEpO1xuICAgIG1hQnVmLnNldChwcm90b0J1ZiwgMSArIGlwQnl0ZUxlbik7XG4gICAgbWFCdWYuc2V0KHByb3RvVmFsLCAxICsgaXBCeXRlTGVuICsgcHJvdG9CdWYubGVuZ3RoKTtcblxuICAgIHJldHVybiBuZXcgTXVsdGlhZGRyKG1hQnVmKTtcbiAgfVxuXG4gIHNldExvY2F0aW9uTXVsdGlhZGRyKG11bHRpYWRkcjogTXVsdGlhZGRyKTogdm9pZCB7XG4gICAgY29uc3QgcHJvdG9OYW1lcyA9IG11bHRpYWRkci5wcm90b05hbWVzKCk7XG4gICAgaWYgKFxuICAgICAgcHJvdG9OYW1lcy5sZW5ndGggIT09IDIgJiZcbiAgICAgIHByb3RvTmFtZXNbMV0gIT09ICd1ZHAnICYmXG4gICAgICBwcm90b05hbWVzWzFdICE9PSAndGNwJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG11bHRpYWRkcicpO1xuICAgIH1cbiAgICBjb25zdCB0dXBsZXMgPSBtdWx0aWFkZHIudHVwbGVzKCk7XG4gICAgaWYgKCF0dXBsZXNbMF1bMV0gfHwgIXR1cGxlc1sxXVsxXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG11bHRpYWRkcicpO1xuICAgIH1cblxuICAgIC8vIElQdjRcbiAgICBpZiAodHVwbGVzWzBdWzBdID09PSA0KSB7XG4gICAgICB0aGlzLnNldCgnaXAnLCB0dXBsZXNbMF1bMV0pO1xuICAgICAgdGhpcy5zZXQocHJvdG9OYW1lc1sxXSwgdHVwbGVzWzFdWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXQoJ2lwNicsIHR1cGxlc1swXVsxXSk7XG4gICAgICB0aGlzLnNldChwcm90b05hbWVzWzFdICsgJzYnLCB0dXBsZXNbMV1bMV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmdWxsIG11bHRpYWRkciBmcm9tIHRoZSBFTlIgZmllbGRzIG1hdGNoaW5nIHRoZSBwcm92aWRlZFxuICAgKiBgcHJvdG9jb2xgIHBhcmFtZXRlci5cbiAgICogVG8gcmV0dXJuIGZ1bGwgbXVsdGlhZGRycyBmcm9tIHRoZSBgbXVsdGlhZGRyc2AgRU5SIGZpZWxkLFxuICAgKiB1c2UgW1tFTlIuZ2V0RnVsbE11bHRpYWRkcnNdXVxuICAgKlxuICAgKiBAcGFyYW0gcHJvdG9jb2xcbiAgICovXG4gIGdldEZ1bGxNdWx0aWFkZHIoXG4gICAgcHJvdG9jb2w6ICd1ZHAnIHwgJ3VkcDQnIHwgJ3VkcDYnIHwgJ3RjcCcgfCAndGNwNCcgfCAndGNwNidcbiAgKTogTXVsdGlhZGRyIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBsb2NhdGlvbk11bHRpYWRkciA9IHRoaXMuZ2V0TG9jYXRpb25NdWx0aWFkZHIocHJvdG9jb2wpO1xuICAgIGlmIChsb2NhdGlvbk11bHRpYWRkcikge1xuICAgICAgcmV0dXJuIGxvY2F0aW9uTXVsdGlhZGRyLmVuY2Fwc3VsYXRlKGAvcDJwLyR7dGhpcy5wZWVySWQudG9CNThTdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZ1bGwgbXVsdGlhZGRycyBmcm9tIHRoZSBgbXVsdGlhZGRyc2AgRU5SIGZpZWxkLlxuICAgKi9cbiAgZ2V0RnVsbE11bHRpYWRkcnMoKTogTXVsdGlhZGRyW10ge1xuICAgIGlmICh0aGlzLm11bHRpYWRkcnMpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpYWRkcnMubWFwKChtYSkgPT4ge1xuICAgICAgICByZXR1cm4gbWEuZW5jYXBzdWxhdGUoYC9wMnAvJHt0aGlzLnBlZXJJZC50b0I1OFN0cmluZygpfWApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZlcmlmeShkYXRhOiBCdWZmZXIsIHNpZ25hdHVyZTogQnVmZmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmdldCgnaWQnKSB8fCB0aGlzLmlkICE9PSAndjQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX0lOVkFMSURfSUQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB2ZXJpZnkgRU5SOiBObyBwdWJsaWMga2V5Jyk7XG4gICAgfVxuICAgIHJldHVybiB2NC52ZXJpZnkodGhpcy5wdWJsaWNLZXksIGRhdGEsIHNpZ25hdHVyZSk7XG4gIH1cblxuICBzaWduKGRhdGE6IEJ1ZmZlciwgcHJpdmF0ZUtleTogQnVmZmVyKTogQnVmZmVyIHtcbiAgICBzd2l0Y2ggKHRoaXMuaWQpIHtcbiAgICAgIGNhc2UgJ3Y0JzpcbiAgICAgICAgdGhpcy5zaWduYXR1cmUgPSB2NC5zaWduKHByaXZhdGVLZXksIGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfSU5WQUxJRF9JRCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZTtcbiAgfVxuXG4gIGVuY29kZVRvVmFsdWVzKHByaXZhdGVLZXk/OiBCdWZmZXIpOiAoRU5SS2V5IHwgRU5SVmFsdWUgfCBudW1iZXIpW10ge1xuICAgIC8vIHNvcnQga2V5cyBhbmQgZmxhdHRlbiBpbnRvIFtrLCB2LCBrLCB2LCAuLi5dXG4gICAgY29uc3QgY29udGVudDogQXJyYXk8RU5SS2V5IHwgRU5SVmFsdWUgfCBudW1iZXI+ID0gQXJyYXkuZnJvbSh0aGlzLmtleXMoKSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpXG4gICAgICAubWFwKChrKSA9PiBbaywgdGhpcy5nZXQoayldIGFzIFtFTlJLZXksIEVOUlZhbHVlXSlcbiAgICAgIC5mbGF0KCk7XG4gICAgY29udGVudC51bnNoaWZ0KE51bWJlcih0aGlzLnNlcSkpO1xuICAgIGlmIChwcml2YXRlS2V5KSB7XG4gICAgICBjb250ZW50LnVuc2hpZnQodGhpcy5zaWduKFJMUC5lbmNvZGUoY29udGVudCksIHByaXZhdGVLZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnNpZ25hdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX05PX1NJR05BVFVSRSk7XG4gICAgICB9XG4gICAgICBjb250ZW50LnVuc2hpZnQodGhpcy5zaWduYXR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGVuY29kZShwcml2YXRlS2V5PzogQnVmZmVyKTogQnVmZmVyIHtcbiAgICBjb25zdCBlbmNvZGVkID0gUkxQLmVuY29kZSh0aGlzLmVuY29kZVRvVmFsdWVzKHByaXZhdGVLZXkpKTtcbiAgICBpZiAoZW5jb2RlZC5sZW5ndGggPj0gTUFYX1JFQ09SRF9TSVpFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VOUiBtdXN0IGJlIGxlc3MgdGhhbiAzMDAgYnl0ZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWQ7XG4gIH1cblxuICBlbmNvZGVUeHQocHJpdmF0ZUtleT86IEJ1ZmZlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIEVOUi5SRUNPUkRfUFJFRklYICsgYmFzZTY0dXJsLmVuY29kZSh0aGlzLmVuY29kZShwcml2YXRlS2V5KSk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHY0Q3J5cHRvIGZyb20gJy4vdjQnO1xuZXhwb3J0IGNvbnN0IHY0ID0gdjRDcnlwdG87XG5leHBvcnQgKiBmcm9tICcuL2NvbnN0YW50cyc7XG5leHBvcnQgKiBmcm9tICcuL2Vucic7XG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vY3JlYXRlJztcbmV4cG9ydCAqIGZyb20gJy4va2V5cGFpcic7XG4iLCJleHBvcnQgY29uc3QgRVJSX1RZUEVfTk9UX0lNUExFTUVOVEVEID0gJ0tleXBhaXIgdHlwZSBub3QgaW1wbGVtZW50ZWQnO1xuZXhwb3J0IGNvbnN0IEVSUl9JTlZBTElEX0tFWVBBSVJfVFlQRSA9ICdJbnZhbGlkIGtleXBhaXIgdHlwZSc7XG4iLCJpbXBvcnQgeyBrZXlzIH0gZnJvbSAnbGlicDJwLWNyeXB0byc7XG5pbXBvcnQgbWggZnJvbSAnbXVsdGloYXNoZXMnO1xuaW1wb3J0IFBlZXJJZCBmcm9tICdwZWVyLWlkJztcblxuY29uc3QgeyBrZXlzUEJNLCBzdXBwb3J0ZWRLZXlzIH0gPSBrZXlzO1xuXG5pbXBvcnQgeyBFUlJfVFlQRV9OT1RfSU1QTEVNRU5URUQgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBTZWNwMjU2azFLZXlwYWlyIH0gZnJvbSAnLi9zZWNwMjU2azEnO1xuaW1wb3J0IHsgSUtleXBhaXIsIEtleXBhaXJUeXBlIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9zZWNwMjU2azEnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVLZXlwYWlyKHR5cGU6IEtleXBhaXJUeXBlKTogUHJvbWlzZTxJS2V5cGFpcj4ge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIEtleXBhaXJUeXBlLnNlY3AyNTZrMTpcbiAgICAgIHJldHVybiBhd2FpdCBTZWNwMjU2azFLZXlwYWlyLmdlbmVyYXRlKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfVFlQRV9OT1RfSU1QTEVNRU5URUQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVLZXlwYWlyKFxuICB0eXBlOiBLZXlwYWlyVHlwZSxcbiAgcHJpdmF0ZUtleT86IEJ1ZmZlcixcbiAgcHVibGljS2V5PzogQnVmZmVyXG4pOiBJS2V5cGFpciB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgS2V5cGFpclR5cGUuc2VjcDI1NmsxOlxuICAgICAgcmV0dXJuIG5ldyBTZWNwMjU2azFLZXlwYWlyKHByaXZhdGVLZXksIHB1YmxpY0tleSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihFUlJfVFlQRV9OT1RfSU1QTEVNRU5URUQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQZWVySWRGcm9tS2V5cGFpcihrZXlwYWlyOiBJS2V5cGFpcik6IFBlZXJJZCB7XG4gIHN3aXRjaCAoa2V5cGFpci50eXBlKSB7XG4gICAgY2FzZSBLZXlwYWlyVHlwZS5zZWNwMjU2azE6IHtcbiAgICAgIC8vIG1hbnVhbGx5IGNyZWF0ZSBhIHBlZXIgaWQgdG8gYXZvaWQgZXhwZW5zaXZlIG9wc1xuICAgICAgY29uc3QgcHJpdktleSA9IGtleXBhaXIuaGFzUHJpdmF0ZUtleSgpXG4gICAgICAgID8gbmV3IHN1cHBvcnRlZEtleXMuc2VjcDI1NmsxLlNlY3AyNTZrMVByaXZhdGVLZXkoXG4gICAgICAgICAgICBrZXlwYWlyLnByaXZhdGVLZXksXG4gICAgICAgICAgICBrZXlwYWlyLnB1YmxpY0tleVxuICAgICAgICAgIClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGNvbnN0IHB1YktleSA9IG5ldyBzdXBwb3J0ZWRLZXlzLnNlY3AyNTZrMS5TZWNwMjU2azFQdWJsaWNLZXkoXG4gICAgICAgIGtleXBhaXIucHVibGljS2V5XG4gICAgICApO1xuICAgICAgY29uc3QgaWQgPSBtaC5lbmNvZGUocHViS2V5LmJ5dGVzLCAnaWRlbnRpdHknKTtcbiAgICAgIHJldHVybiBuZXcgUGVlcklkKGlkLCBwcml2S2V5LCBwdWJLZXkpO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUl9UWVBFX05PVF9JTVBMRU1FTlRFRCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUtleXBhaXJGcm9tUGVlcklkKHBlZXJJZDogUGVlcklkKTogSUtleXBhaXIge1xuICAvLyBwdWIvcHJpdmF0ZSBrZXkgYnl0ZXMgZnJvbSBwZWVyLWlkIGFyZSBlbmNvZGVkIGluIHByb3RvYnVmIGZvcm1hdFxuICBjb25zdCBwdWIgPSBrZXlzUEJNLlB1YmxpY0tleS5kZWNvZGUocGVlcklkLnB1YktleS5ieXRlcyk7XG4gIHJldHVybiBjcmVhdGVLZXlwYWlyKFxuICAgIHB1Yi5UeXBlIGFzIEtleXBhaXJUeXBlLFxuICAgIHBlZXJJZC5wcml2S2V5ID8gQnVmZmVyLmZyb20ocGVlcklkLnByaXZLZXkubWFyc2hhbCgpKSA6IHVuZGVmaW5lZCxcbiAgICBCdWZmZXIuZnJvbShwdWIuRGF0YSlcbiAgKTtcbn1cbiIsImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbmltcG9ydCAqIGFzIHNlY3AyNTZrMSBmcm9tICdzZWNwMjU2azEnO1xuXG5pbXBvcnQgeyBBYnN0cmFjdEtleXBhaXIsIElLZXlwYWlyLCBJS2V5cGFpckNsYXNzLCBLZXlwYWlyVHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gc2VjcDI1NmsxUHVibGljS2V5VG9Db21wcmVzc2VkKHB1YmxpY0tleTogVWludDhBcnJheSk6IEJ1ZmZlciB7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFs0XSksIHB1YmxpY0tleV0pO1xuICB9XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIHRydWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY3AyNTZrMVB1YmxpY0tleVRvRnVsbChwdWJsaWNLZXk6IFVpbnQ4QXJyYXkpOiBCdWZmZXIge1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSk7XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgZmFsc2UpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlY3AyNTZrMVB1YmxpY0tleVRvUmF3KHB1YmxpY0tleTogVWludDhBcnJheSk6IEJ1ZmZlciB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGZhbHNlKS5zbGljZSgxKSk7XG59XG5cbmV4cG9ydCBjb25zdCBTZWNwMjU2azFLZXlwYWlyOiBJS2V5cGFpckNsYXNzID0gY2xhc3MgU2VjcDI1NmsxS2V5cGFpclxuICBleHRlbmRzIEFic3RyYWN0S2V5cGFpclxuICBpbXBsZW1lbnRzIElLZXlwYWlyXG57XG4gIHJlYWRvbmx5IHR5cGU6IEtleXBhaXJUeXBlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGVLZXk/OiBCdWZmZXIsIHB1YmxpY0tleT86IEJ1ZmZlcikge1xuICAgIGxldCBwdWIgPSBwdWJsaWNLZXk7XG4gICAgaWYgKHB1Yikge1xuICAgICAgcHViID0gc2VjcDI1NmsxUHVibGljS2V5VG9Db21wcmVzc2VkKHB1Yik7XG4gICAgfVxuICAgIHN1cGVyKHByaXZhdGVLZXksIHB1Yik7XG4gICAgdGhpcy50eXBlID0gS2V5cGFpclR5cGUuc2VjcDI1NmsxO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGdlbmVyYXRlKCk6IFByb21pc2U8U2VjcDI1NmsxS2V5cGFpcj4ge1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBCdWZmZXIuZnJvbShhd2FpdCByYW5kb21CeXRlcygzMikpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSk7XG4gICAgcmV0dXJuIG5ldyBTZWNwMjU2azFLZXlwYWlyKHByaXZhdGVLZXksIEJ1ZmZlci5mcm9tKHB1YmxpY0tleSkpO1xuICB9XG5cbiAgcHJpdmF0ZUtleVZlcmlmeShrZXkgPSB0aGlzLl9wcml2YXRlS2V5KTogYm9vbGVhbiB7XG4gICAgaWYgKGtleSkge1xuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHVibGljS2V5VmVyaWZ5KGtleSA9IHRoaXMuX3B1YmxpY0tleSk6IGJvb2xlYW4ge1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KGtleSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc2lnbihtc2c6IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUsIHJlY2lkIH0gPSBzZWNwMjU2azEuZWNkc2FTaWduKG1zZywgdGhpcy5wcml2YXRlS2V5KTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbc2lnbmF0dXJlLCBCdWZmZXIuZnJvbShbcmVjaWRdKV0pO1xuICB9XG5cbiAgdmVyaWZ5KG1zZzogQnVmZmVyLCBzaWc6IEJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBzZWNwMjU2azEuZWNkc2FWZXJpZnkoc2lnLCBtc2csIHRoaXMucHVibGljS2V5KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoOiBudW1iZXIpOiBVaW50OEFycmF5IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAmJiB3aW5kb3cuY3J5cHRvKSB7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICByZXR1cm4gYXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhsZW5ndGgpO1xuICB9XG59XG4iLCJleHBvcnQgZW51bSBLZXlwYWlyVHlwZSB7XG4gIHJzYSA9IDAsXG4gIGVkMjU1MTkgPSAxLFxuICBzZWNwMjU2azEgPSAyLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElLZXlwYWlyIHtcbiAgdHlwZTogS2V5cGFpclR5cGU7XG4gIHByaXZhdGVLZXk6IEJ1ZmZlcjtcbiAgcHVibGljS2V5OiBCdWZmZXI7XG4gIHByaXZhdGVLZXlWZXJpZnkoKTogYm9vbGVhbjtcbiAgcHVibGljS2V5VmVyaWZ5KCk6IGJvb2xlYW47XG4gIHNpZ24obXNnOiBCdWZmZXIpOiBCdWZmZXI7XG4gIHZlcmlmeShtc2c6IEJ1ZmZlciwgc2lnOiBCdWZmZXIpOiBib29sZWFuO1xuICBoYXNQcml2YXRlS2V5KCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUtleXBhaXJDbGFzcyB7XG4gIG5ldyAocHJpdmF0ZUtleT86IEJ1ZmZlciwgcHVibGljS2V5PzogQnVmZmVyKTogSUtleXBhaXI7XG4gIGdlbmVyYXRlKCk6IFByb21pc2U8SUtleXBhaXI+O1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RLZXlwYWlyIHtcbiAgX3ByaXZhdGVLZXk/OiBCdWZmZXI7XG4gIHJlYWRvbmx5IF9wdWJsaWNLZXk/OiBCdWZmZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZUtleT86IEJ1ZmZlciwgcHVibGljS2V5PzogQnVmZmVyKSB7XG4gICAgaWYgKCh0aGlzLl9wcml2YXRlS2V5ID0gcHJpdmF0ZUtleSkgJiYgIXRoaXMucHJpdmF0ZUtleVZlcmlmeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gICAgaWYgKCh0aGlzLl9wdWJsaWNLZXkgPSBwdWJsaWNLZXkpICYmICF0aGlzLnB1YmxpY0tleVZlcmlmeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcHJpdmF0ZUtleSgpOiBCdWZmZXIge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcml2YXRlS2V5O1xuICB9XG5cbiAgZ2V0IHB1YmxpY0tleSgpOiBCdWZmZXIge1xuICAgIGlmICghdGhpcy5fcHVibGljS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleTtcbiAgfVxuXG4gIHByaXZhdGVLZXlWZXJpZnkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBwdWJsaWNLZXlWZXJpZnkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBoYXNQcml2YXRlS2V5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuX3ByaXZhdGVLZXkpO1xuICB9XG59XG4iLCIvLyBDdXN0b20gYW5kIGFsaWFzZWQgdHlwZXMgZm9yIEVOUnNcblxuLyoqXG4gKiBXZSByZXByZXNlbnQgTm9kZUlkIGFzIGEgaGV4IHN0cmluZywgc2luY2Ugbm9kZSBlcXVhbGl0eSBpcyB1c2VkIHZlcnkgaGVhdmlseVxuICogYW5kIGl0IGlzIGNvbnZlbmllbnQgdG8gaW5kZXggZGF0YSBieSBOb2RlSWRcbiAqL1xuZXhwb3J0IHR5cGUgTm9kZUlkID0gc3RyaW5nO1xuZXhwb3J0IHR5cGUgU2VxdWVuY2VOdW1iZXIgPSBiaWdpbnQ7XG5cbmV4cG9ydCB0eXBlIEVOUktleSA9IHN0cmluZztcbmV4cG9ydCB0eXBlIEVOUlZhbHVlID0gVWludDhBcnJheTtcbiIsImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSAnanMtc2hhMyc7XG5pbXBvcnQgKiBhcyBzZWNwMjU2azEgZnJvbSAnc2VjcDI1NmsxJztcblxuaW1wb3J0IHsgY3JlYXRlTm9kZUlkIH0gZnJvbSAnLi9jcmVhdGUnO1xuaW1wb3J0IHsgTm9kZUlkIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGlucHV0OiBVaW50OEFycmF5KTogQnVmZmVyIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGtlY2NhazI1Ni5hcnJheUJ1ZmZlcihpbnB1dCkpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUHJpdmF0ZUtleSgpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICByZXR1cm4gQnVmZmVyLmZyb20oYXdhaXQgcmFuZG9tQnl0ZXMoMzIpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHB1YmxpY0tleShwcml2S2V5OiBVaW50OEFycmF5KTogQnVmZmVyIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdktleSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2lnbihwcml2S2V5OiBVaW50OEFycmF5LCBtc2c6IFVpbnQ4QXJyYXkpOiBCdWZmZXIge1xuICBjb25zdCB7IHNpZ25hdHVyZSB9ID0gc2VjcDI1NmsxLmVjZHNhU2lnbihoYXNoKG1zZyksIHByaXZLZXkpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2lnbmF0dXJlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeShwdWJLZXk6IEJ1ZmZlciwgbXNnOiBCdWZmZXIsIHNpZzogQnVmZmVyKTogYm9vbGVhbiB7XG4gIC8vIFJlbW92ZSB0aGUgcmVjb3ZlcnkgaWQgaWYgcHJlc2VudCAoYnl0ZSAjNjUpXG4gIHJldHVybiBzZWNwMjU2azEuZWNkc2FWZXJpZnkoc2lnLnNsaWNlKDAsIDY0KSwgaGFzaChtc2cpLCBwdWJLZXkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9kZUlkKHB1YktleTogVWludDhBcnJheSk6IE5vZGVJZCB7XG4gIGNvbnN0IHVuY29tcHJlc3NlZFB1YmtleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpO1xuXG4gIHJldHVybiBjcmVhdGVOb2RlSWQoaGFzaCh1bmNvbXByZXNzZWRQdWJrZXkuc2xpY2UoMSkpKTtcbn1cblxuZXhwb3J0IGNsYXNzIEVOUktleVBhaXIge1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IG5vZGVJZDogTm9kZUlkLFxuICAgIHB1YmxpYyByZWFkb25seSBwcml2YXRlS2V5OiBCdWZmZXIsXG4gICAgcHVibGljIHJlYWRvbmx5IHB1YmxpY0tleTogQnVmZmVyXG4gICkge31cblxuICBwdWJsaWMgc3RhdGljIGFzeW5jIGNyZWF0ZShwcml2YXRlS2V5PzogQnVmZmVyKTogUHJvbWlzZTxFTlJLZXlQYWlyPiB7XG4gICAgaWYgKHByaXZhdGVLZXkpIHtcbiAgICAgIGlmICghc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUga2V5Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IF9wcml2YXRlS2V5ID0gcHJpdmF0ZUtleSB8fCAoYXdhaXQgY3JlYXRlUHJpdmF0ZUtleSgpKTtcbiAgICBjb25zdCBfcHVibGljS2V5ID0gcHVibGljS2V5KF9wcml2YXRlS2V5KTtcbiAgICBjb25zdCBfbm9kZUlkID0gbm9kZUlkKF9wdWJsaWNLZXkpO1xuXG4gICAgcmV0dXJuIG5ldyBFTlJLZXlQYWlyKF9ub2RlSWQsIF9wcml2YXRlS2V5LCBfcHVibGljS2V5KTtcbiAgfVxuXG4gIHB1YmxpYyBzaWduKG1zZzogQnVmZmVyKTogQnVmZmVyIHtcbiAgICByZXR1cm4gc2lnbih0aGlzLnByaXZhdGVLZXksIG1zZyk7XG4gIH1cblxuICBwdWJsaWMgdmVyaWZ5KG1zZzogQnVmZmVyLCBzaWc6IEJ1ZmZlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2ZXJpZnkodGhpcy5wdWJsaWNLZXksIG1zZywgc2lnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGg6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHdpbmRvdy5jcnlwdG8pIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gIH1cbn1cbiIsImltcG9ydCBMaWJwMnAgZnJvbSAnbGlicDJwJztcbmltcG9ydCB7IFBlZXIgfSBmcm9tICdsaWJwMnAvc3JjL3BlZXItc3RvcmUnO1xuXG4vKipcbiAqIFJldHVybnMgYSBwc2V1ZG8tcmFuZG9tIHBlZXIgdGhhdCBzdXBwb3J0cyB0aGUgZ2l2ZW4gcHJvdG9jb2wuXG4gKiBVc2VmdWwgZm9yIHByb3RvY29scyBzdWNoIGFzIHN0b3JlIGFuZCBsaWdodCBwdXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RSYW5kb21QZWVyKHBlZXJzOiBQZWVyW10pOiBQZWVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHBlZXJzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gIGNvbnN0IGluZGV4ID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKHBlZXJzLmxlbmd0aCAtIDEpKTtcbiAgcmV0dXJuIHBlZXJzW2luZGV4XTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHBlZXJzIHRoYXQgc3VwcG9ydHMgdGhlIGdpdmVuIHByb3RvY29sLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGVlcnNGb3JQcm90b2NvbChsaWJwMnA6IExpYnAycCwgcHJvdG9jb2w6IHN0cmluZyk6IFBlZXJbXSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGxpYnAycC5wZWVyU3RvcmUucGVlcnMudmFsdWVzKCkpLmZpbHRlcigocGVlcikgPT5cbiAgICBwZWVyLnByb3RvY29scy5pbmNsdWRlcyhwcm90b2NvbClcbiAgKTtcbn1cbiIsImltcG9ydCB7IGtlY2NhazI1NiwgTWVzc2FnZSB9IGZyb20gJ2pzLXNoYTMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CdWYoaGV4OiBzdHJpbmcgfCBCdWZmZXIgfCBVaW50OEFycmF5KTogQnVmZmVyIHtcbiAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleC5yZXBsYWNlKC9eMHgvaSwgJycpLCAnaGV4Jyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhleCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1ZlRvSGV4KGJ1ZjogVWludDhBcnJheSB8IEJ1ZmZlciB8IEFycmF5QnVmZmVyKTogc3RyaW5nIHtcbiAgY29uc3QgX2J1ZiA9IEJ1ZmZlci5mcm9tKGJ1Zik7XG4gIHJldHVybiBfYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZUFycmF5cyhcbiAgYTogVWludDhBcnJheSB8IEJ1ZmZlciB8IHN0cmluZyxcbiAgYjogVWludDhBcnJheSB8IEJ1ZmZlciB8IHN0cmluZ1xuKTogYm9vbGVhbiB7XG4gIGxldCBhQnVmOiBCdWZmZXI7XG4gIGxldCBiQnVmOiBCdWZmZXI7XG4gIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICBhQnVmID0gaGV4VG9CdWYoYSk7XG4gIH0gZWxzZSB7XG4gICAgYUJ1ZiA9IEJ1ZmZlci5mcm9tKGEpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgIGJCdWYgPSBoZXhUb0J1ZihiKTtcbiAgfSBlbHNlIHtcbiAgICBiQnVmID0gQnVmZmVyLmZyb20oYik7XG4gIH1cblxuICByZXR1cm4gYUJ1Zi5jb21wYXJlKGJCdWYpID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2QnVmKG1lc3NhZ2U6IE1lc3NhZ2UpOiBCdWZmZXIge1xuICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrMjU2LmFycmF5QnVmZmVyKG1lc3NhZ2UpKTtcbn1cbiIsImltcG9ydCB7IGJ5dGVzIH0gZnJvbSAnQGNoYWluc2FmZS9saWJwMnAtbm9pc2UvZGlzdC9zcmMvQHR5cGVzL2Jhc2ljJztcbmltcG9ydCB7IE5vaXNlIH0gZnJvbSAnQGNoYWluc2FmZS9saWJwMnAtbm9pc2UvZGlzdC9zcmMvbm9pc2UnO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBMaWJwMnAsIHsgQ29ubmVjdGlvbiwgTGlicDJwTW9kdWxlcywgTGlicDJwT3B0aW9ucyB9IGZyb20gJ2xpYnAycCc7XG5pbXBvcnQgTGlicDJwQm9vdHN0cmFwIGZyb20gJ2xpYnAycC1ib290c3RyYXAnO1xuaW1wb3J0IHsgTXV4ZWRTdHJlYW0gfSBmcm9tICdsaWJwMnAtaW50ZXJmYWNlcy9kaXN0L3NyYy9zdHJlYW0tbXV4ZXIvdHlwZXMnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuLy8gQHRzLWlnbm9yZTogTm8gdHlwZXMgYXZhaWxhYmxlXG5pbXBvcnQgTXBsZXggZnJvbSAnbGlicDJwLW1wbGV4Jztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbi8vIEB0cy1pZ25vcmU6IE5vIHR5cGVzIGF2YWlsYWJsZVxuaW1wb3J0IFdlYnNvY2tldHMgZnJvbSAnbGlicDJwLXdlYnNvY2tldHMnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuLy8gQHRzLWlnbm9yZTogTm8gdHlwZXMgYXZhaWxhYmxlXG5pbXBvcnQgZmlsdGVycyBmcm9tICdsaWJwMnAtd2Vic29ja2V0cy9zcmMvZmlsdGVycyc7XG5pbXBvcnQgeyBQZWVyIH0gZnJvbSAnbGlicDJwL2Rpc3Qvc3JjL3BlZXItc3RvcmUnO1xuaW1wb3J0IFBpbmcgZnJvbSAnbGlicDJwL3NyYy9waW5nJztcbmltcG9ydCB7IE11bHRpYWRkciwgbXVsdGlhZGRyIH0gZnJvbSAnbXVsdGlhZGRyJztcbmltcG9ydCBQZWVySWQgZnJvbSAncGVlci1pZCc7XG5cbmltcG9ydCB7IEJvb3RzdHJhcCwgQm9vdHN0cmFwT3B0aW9ucyB9IGZyb20gJy4vZGlzY292ZXJ5JztcbmltcG9ydCB7IGdldFBlZXJzRm9yUHJvdG9jb2wgfSBmcm9tICcuL3NlbGVjdF9wZWVyJztcbmltcG9ydCB7IExpZ2h0UHVzaENvZGVjLCBXYWt1TGlnaHRQdXNoIH0gZnJvbSAnLi93YWt1X2xpZ2h0X3B1c2gnO1xuaW1wb3J0IHsgRGVjcnlwdGlvbk1ldGhvZCwgV2FrdU1lc3NhZ2UgfSBmcm9tICcuL3dha3VfbWVzc2FnZSc7XG5pbXBvcnQgeyBSZWxheUNvZGVjcywgV2FrdVJlbGF5IH0gZnJvbSAnLi93YWt1X3JlbGF5JztcbmltcG9ydCB7IFJlbGF5UGluZ0NvbnRlbnRUb3BpYyB9IGZyb20gJy4vd2FrdV9yZWxheS9jb25zdGFudHMnO1xuaW1wb3J0IHsgU3RvcmVDb2RlYywgV2FrdVN0b3JlIH0gZnJvbSAnLi93YWt1X3N0b3JlJztcblxuY29uc3Qgd2Vic29ja2V0c1RyYW5zcG9ydEtleSA9IFdlYnNvY2tldHMucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ107XG5cbmV4cG9ydCBjb25zdCBEZWZhdWx0UGluZ0tlZXBBbGl2ZVZhbHVlU2VjcyA9IDA7XG5leHBvcnQgY29uc3QgRGVmYXVsdFJlbGF5S2VlcEFsaXZlVmFsdWVTZWNzID0gNSAqIDYwO1xuXG4vKipcbiAqIERlZmF1bHRQdWJTdWJUb3BpYyBpcyB0aGUgZGVmYXVsdCBnb3NzaXBzdWIgdG9waWMgdG8gdXNlIGZvciBXYWt1LlxuICovXG5leHBvcnQgY29uc3QgRGVmYXVsdFB1YlN1YlRvcGljID0gJy93YWt1LzIvZGVmYXVsdC13YWt1L3Byb3RvJztcblxuY29uc3QgZGJnID0gZGVidWcoJ3dha3U6d2FrdScpO1xuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIFB1YlN1YiBUb3BpYyB0byB1c2UuIERlZmF1bHRzIHRvIHtAbGluayBEZWZhdWx0UHViU3ViVG9waWN9LlxuICAgKlxuICAgKiBPbmUgYW5kIG9ubHkgb25lIHB1YnN1YiB0b3BpYyBpcyB1c2VkIGJ5IFdha3UuIFRoaXMgaXMgdXNlZCBieTpcbiAgICogLSBXYWt1UmVsYXkgdG8gcmVjZWl2ZSwgcm91dGUgYW5kIHNlbmQgbWVzc2FnZXMsXG4gICAqIC0gV2FrdUxpZ2h0UHVzaCB0byBzZW5kIG1lc3NhZ2VzLFxuICAgKiAtIFdha3VTdG9yZSB0byByZXRyaWV2ZSBtZXNzYWdlcy5cbiAgICpcbiAgICogVGhlIHVzYWdlIG9mIHRoZSBkZWZhdWx0IHB1YnN1YiB0b3BpYyBpcyByZWNvbW1lbmRlZC5cbiAgICogU2VlIFtXYWt1IHYyIFRvcGljIFVzYWdlIFJlY29tbWVuZGF0aW9uc10oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzIzLykgZm9yIGRldGFpbHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IHtAbGluayBEZWZhdWx0UHViU3ViVG9waWN9XG4gICAqL1xuICBwdWJTdWJUb3BpYz86IHN0cmluZztcbiAgLyoqXG4gICAqIFNldCBrZWVwIGFsaXZlIGZyZXF1ZW5jeSBpbiBzZWNvbmRzOiBXYWt1IHdpbGwgc2VuZCBhIGAvaXBmcy9waW5nLzEuMC4wYFxuICAgKiByZXF1ZXN0IHRvIGVhY2ggcGVlciBhZnRlciB0aGUgc2V0IG51bWJlciBvZiBzZWNvbmRzLiBTZXQgdG8gMCB0byBkaXNhYmxlLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgRGVmYXVsdFBpbmdLZWVwQWxpdmVWYWx1ZVNlY3N9XG4gICAqL1xuICBwaW5nS2VlcEFsaXZlPzogbnVtYmVyO1xuICAvKipcbiAgICogU2V0IGtlZXAgYWxpdmUgZnJlcXVlbmN5IGluIHNlY29uZHM6IFdha3Ugd2lsbCBzZW5kIGEgcGluZyBtZXNzYWdlIG92ZXJcbiAgICogcmVsYXkgdG8gZWFjaCBwZWVyIGFmdGVyIHRoZSBzZXQgbnVtYmVyIG9mIHNlY29uZHMuIFNldCB0byAwIHRvIGRpc2FibGUuXG4gICAqXG4gICAqIEBkZWZhdWx0IHtAbGluayBEZWZhdWx0UmVsYXlLZWVwQWxpdmVWYWx1ZVNlY3N9XG4gICAqL1xuICByZWxheUtlZXBBbGl2ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIFlvdSBjYW4gcGFzcyBvcHRpb25zIHRvIHRoZSBgTGlicDJwYCBpbnN0YW5jZSB1c2VkIGJ5IHtAbGluayBXYWt1fSB1c2luZyB0aGUge0BsaW5rIENyZWF0ZU9wdGlvbnMubGlicDJwfSBwcm9wZXJ0eS5cbiAgICogVGhpcyBwcm9wZXJ0eSBpcyB0aGUgc2FtZSB0eXBlIHRoYW4gdGhlIG9uZSBwYXNzZWQgdG8gW2BMaWJwMnAuY3JlYXRlYF0oaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9qcy1saWJwMnAvYmxvYi9tYXN0ZXIvZG9jL0FQSS5tZCNjcmVhdGUpXG4gICAqIGFwYXJ0IHRoYXQgd2UgbWFkZSB0aGUgYG1vZHVsZXNgIHByb3BlcnR5IG9wdGlvbmFsIGFuZCBwYXJ0aWFsLFxuICAgKiBhbGxvd2luZyBpdHMgb21pc3Npb24gYW5kIGxldHRpbmcgV2FrdSBzZXQgZ29vZCBkZWZhdWx0cy5cbiAgICogTm90ZXMgdGhhdCBzb21lIHZhbHVlcyBhcmUgb3ZlcnJpZGRlbiBieSB7QGxpbmsgV2FrdX0gdG8gZW5zdXJlIGl0IGltcGxlbWVudHMgdGhlIFdha3UgcHJvdG9jb2wuXG4gICAqL1xuICBsaWJwMnA/OiBPbWl0PExpYnAycE9wdGlvbnMgJiBpbXBvcnQoJ2xpYnAycCcpLkNyZWF0ZU9wdGlvbnMsICdtb2R1bGVzJz4gJiB7XG4gICAgbW9kdWxlcz86IFBhcnRpYWw8TGlicDJwTW9kdWxlcz47XG4gIH07XG4gIC8qKlxuICAgKiBCeXRlIGFycmF5IHVzZWQgYXMga2V5IGZvciB0aGUgbm9pc2UgcHJvdG9jb2wgdXNlZCBmb3IgY29ubmVjdGlvbiBlbmNyeXB0aW9uXG4gICAqIGJ5IFtgTGlicDJwLmNyZWF0ZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9saWJwMnAvanMtbGlicDJwL2Jsb2IvbWFzdGVyL2RvYy9BUEkubWQjY3JlYXRlKVxuICAgKiBUaGlzIGlzIG9ubHkgdXNlZCBmb3IgdGVzdCBwdXJwb3NlcyB0byBub3QgcnVuIG91dCBvZiBlbnRyb3B5IGR1cmluZyBDSSBydW5zLlxuICAgKi9cbiAgc3RhdGljTm9pc2VLZXk/OiBieXRlcztcbiAgLyoqXG4gICAqIFVzZSBsaWJwMnAtYm9vdHN0cmFwIHRvIGRpc2NvdmVyIGFuZCBjb25uZWN0IHRvIG5ldyBub2Rlcy5cbiAgICpcbiAgICogU2VlIFtbQm9vdHN0cmFwT3B0aW9uc11dIGZvciBhdmFpbGFibGUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogTm90ZTogSXQgb3ZlcnJpZGVzIGFueSBvdGhlciBwZWVyRGlzY292ZXJ5IG1vZHVsZXMgdGhhdCBtYXkgaGF2ZSBiZWVuIHNldCB2aWFcbiAgICoge0BsaW5rIENyZWF0ZU9wdGlvbnMubGlicDJwfS5cbiAgICovXG4gIGJvb3RzdHJhcD86IEJvb3RzdHJhcE9wdGlvbnM7XG4gIGRlY3J5cHRpb25LZXlzPzogQXJyYXk8VWludDhBcnJheSB8IHN0cmluZz47XG59XG5cbmV4cG9ydCBjbGFzcyBXYWt1IHtcbiAgcHVibGljIGxpYnAycDogTGlicDJwO1xuICBwdWJsaWMgcmVsYXk6IFdha3VSZWxheTtcbiAgcHVibGljIHN0b3JlOiBXYWt1U3RvcmU7XG4gIHB1YmxpYyBsaWdodFB1c2g6IFdha3VMaWdodFB1c2g7XG5cbiAgcHJpdmF0ZSBwaW5nS2VlcEFsaXZlVGltZXJzOiB7XG4gICAgW3BlZXI6IHN0cmluZ106IFJldHVyblR5cGU8dHlwZW9mIHNldEludGVydmFsPjtcbiAgfTtcbiAgcHJpdmF0ZSByZWxheUtlZXBBbGl2ZVRpbWVyczoge1xuICAgIFtwZWVyOiBzdHJpbmddOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRJbnRlcnZhbD47XG4gIH07XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICBvcHRpb25zOiBDcmVhdGVPcHRpb25zLFxuICAgIGxpYnAycDogTGlicDJwLFxuICAgIHN0b3JlOiBXYWt1U3RvcmUsXG4gICAgbGlnaHRQdXNoOiBXYWt1TGlnaHRQdXNoXG4gICkge1xuICAgIHRoaXMubGlicDJwID0gbGlicDJwO1xuICAgIHRoaXMucmVsYXkgPSBsaWJwMnAucHVic3ViIGFzIHVua25vd24gYXMgV2FrdVJlbGF5O1xuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLmxpZ2h0UHVzaCA9IGxpZ2h0UHVzaDtcbiAgICB0aGlzLnBpbmdLZWVwQWxpdmVUaW1lcnMgPSB7fTtcbiAgICB0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzID0ge307XG5cbiAgICBjb25zdCBwaW5nS2VlcEFsaXZlID1cbiAgICAgIG9wdGlvbnMucGluZ0tlZXBBbGl2ZSB8fCBEZWZhdWx0UGluZ0tlZXBBbGl2ZVZhbHVlU2VjcztcbiAgICBjb25zdCByZWxheUtlZXBBbGl2ZSA9XG4gICAgICBvcHRpb25zLnJlbGF5S2VlcEFsaXZlIHx8IERlZmF1bHRSZWxheUtlZXBBbGl2ZVZhbHVlU2VjcztcblxuICAgIGxpYnAycC5jb25uZWN0aW9uTWFuYWdlci5vbigncGVlcjpjb25uZWN0JywgKGNvbm5lY3Rpb246IENvbm5lY3Rpb24pID0+IHtcbiAgICAgIHRoaXMuc3RhcnRLZWVwQWxpdmUoY29ubmVjdGlvbi5yZW1vdGVQZWVyLCBwaW5nS2VlcEFsaXZlLCByZWxheUtlZXBBbGl2ZSk7XG4gICAgfSk7XG5cbiAgICBsaWJwMnAuY29ubmVjdGlvbk1hbmFnZXIub24oJ3BlZXI6ZGlzY29ubmVjdCcsIChjb25uZWN0aW9uOiBDb25uZWN0aW9uKSA9PiB7XG4gICAgICB0aGlzLnN0b3BLZWVwQWxpdmUoY29ubmVjdGlvbi5yZW1vdGVQZWVyKTtcbiAgICB9KTtcblxuICAgIG9wdGlvbnM/LmRlY3J5cHRpb25LZXlzPy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuYWRkRGVjcnlwdGlvbktleShrZXkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBuZXcgd2FrdSBub2RlXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFRha2VzIHRoZSBzYW1lIG9wdGlvbnMgdGhhbiBgTGlicDJwYC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUob3B0aW9ucz86IENyZWF0ZU9wdGlvbnMpOiBQcm9taXNlPFdha3U+IHtcbiAgICAvLyBHZXQgYW4gb2JqZWN0IGluIGNhc2Ugb3B0aW9ucyBvciBsaWJwMnAgYXJlIHVuZGVmaW5lZFxuICAgIGNvbnN0IGxpYnAycE9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zPy5saWJwMnApO1xuXG4gICAgLy8gRGVmYXVsdCBmb3IgV2Vic29ja2V0IGZpbHRlciBpcyBgYWxsYDpcbiAgICAvLyBSZXR1cm5zIGFsbCBUQ1AgYW5kIEROUyBiYXNlZCBhZGRyZXNzZXMsIGJvdGggd2l0aCB3cyBvciB3c3MuXG4gICAgbGlicDJwT3B0cy5jb25maWcgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICB0cmFuc3BvcnQ6IHtcbiAgICAgICAgICBbd2Vic29ja2V0c1RyYW5zcG9ydEtleV06IHtcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVycy5hbGwsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zPy5saWJwMnA/LmNvbmZpZ1xuICAgICk7XG5cbiAgICAvLyBQYXNzIHB1YnN1YiB0b3BpYyB0byByZWxheVxuICAgIGlmIChvcHRpb25zPy5wdWJTdWJUb3BpYykge1xuICAgICAgbGlicDJwT3B0cy5jb25maWcucHVic3ViID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgeyBwdWJTdWJUb3BpYzogb3B0aW9ucy5wdWJTdWJUb3BpYyB9LFxuICAgICAgICBsaWJwMnBPcHRzLmNvbmZpZy5wdWJzdWJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGlicDJwT3B0cy5tb2R1bGVzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucz8ubGlicDJwPy5tb2R1bGVzKTtcblxuICAgIC8vIERlZmF1bHQgdHJhbnNwb3J0IGZvciBsaWJwMnAgaXMgV2Vic29ja2V0c1xuICAgIGxpYnAycE9wdHMubW9kdWxlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIHRyYW5zcG9ydDogW1dlYnNvY2tldHNdLFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnM/LmxpYnAycD8ubW9kdWxlc1xuICAgICk7XG5cbiAgICAvLyBzdHJlYW1NdXhlciwgY29ubmVjdGlvbiBlbmNyeXB0aW9uIGFuZCBwdWJzdWIgYXJlIG92ZXJyaWRkZW5cbiAgICAvLyBhcyB0aG9zZSBhcmUgdGhlIG9ubHkgb25lcyBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IFdha3Ugbm9kZXMuXG4gICAgbGlicDJwT3B0cy5tb2R1bGVzID0gT2JqZWN0LmFzc2lnbihsaWJwMnBPcHRzLm1vZHVsZXMsIHtcbiAgICAgIHN0cmVhbU11eGVyOiBbTXBsZXhdLFxuICAgICAgY29ubkVuY3J5cHRpb246IFtuZXcgTm9pc2Uob3B0aW9ucz8uc3RhdGljTm9pc2VLZXkpXSxcbiAgICAgIHB1YnN1YjogV2FrdVJlbGF5LFxuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnM/LmJvb3RzdHJhcCkge1xuICAgICAgY29uc3QgYm9vdHN0cmFwID0gbmV3IEJvb3RzdHJhcChvcHRpb25zPy5ib290c3RyYXApO1xuXG4gICAgICBpZiAoYm9vdHN0cmFwLmdldEJvb3RzdHJhcFBlZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBsaXN0ID0gYXdhaXQgYm9vdHN0cmFwLmdldEJvb3RzdHJhcFBlZXJzKCk7XG5cbiAgICAgICAgICAvLyBOb3RlOiB0aGlzIG92ZXJyaWRlcyBhbnkgb3RoZXIgcGVlciBkaXNjb3ZlclxuICAgICAgICAgIGxpYnAycE9wdHMubW9kdWxlcyA9IE9iamVjdC5hc3NpZ24obGlicDJwT3B0cy5tb2R1bGVzLCB7XG4gICAgICAgICAgICBwZWVyRGlzY292ZXJ5OiBbTGlicDJwQm9vdHN0cmFwXSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGxpYnAycE9wdHMuY29uZmlnLnBlZXJEaXNjb3ZlcnkgPSB7XG4gICAgICAgICAgICBbTGlicDJwQm9vdHN0cmFwLnRhZ106IHtcbiAgICAgICAgICAgICAgbGlzdCxcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRiZygnRmFpbGVkIHRvIHJldHJpZXZlIGJvb3RzdHJhcCBub2RlcycsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmU6IG1vZHVsZXMgcHJvcGVydHkgaXMgY29ycmVjdGx5IHNldCB0aGFua3MgdG8gdm9vZG9vXG4gICAgY29uc3QgbGlicDJwID0gYXdhaXQgTGlicDJwLmNyZWF0ZShsaWJwMnBPcHRzKTtcblxuICAgIGNvbnN0IHdha3VTdG9yZSA9IG5ldyBXYWt1U3RvcmUobGlicDJwLCB7XG4gICAgICBwdWJTdWJUb3BpYzogb3B0aW9ucz8ucHViU3ViVG9waWMsXG4gICAgfSk7XG4gICAgY29uc3Qgd2FrdUxpZ2h0UHVzaCA9IG5ldyBXYWt1TGlnaHRQdXNoKGxpYnAycCk7XG5cbiAgICBhd2FpdCBsaWJwMnAuc3RhcnQoKTtcblxuICAgIHJldHVybiBuZXcgV2FrdShvcHRpb25zID8gb3B0aW9ucyA6IHt9LCBsaWJwMnAsIHdha3VTdG9yZSwgd2FrdUxpZ2h0UHVzaCk7XG4gIH1cblxuICAvKipcbiAgICogRGlhbHMgdG8gdGhlIHByb3ZpZGVkIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSBwZWVyIFRoZSBwZWVyIHRvIGRpYWxcbiAgICovXG4gIGFzeW5jIGRpYWwocGVlcjogUGVlcklkIHwgTXVsdGlhZGRyIHwgc3RyaW5nKTogUHJvbWlzZTx7XG4gICAgc3RyZWFtOiBNdXhlZFN0cmVhbTtcbiAgICBwcm90b2NvbDogc3RyaW5nO1xuICB9PiB7XG4gICAgcmV0dXJuIHRoaXMubGlicDJwLmRpYWxQcm90b2NvbChwZWVyLCBbU3RvcmVDb2RlY10uY29uY2F0KFJlbGF5Q29kZWNzKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIHBlZXIgdG8gYWRkcmVzcyBib29rLCBpdCB3aWxsIGJlIGF1dG8tZGlhbGVkIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgKi9cbiAgYWRkUGVlclRvQWRkcmVzc0Jvb2soXG4gICAgcGVlcklkOiBQZWVySWQgfCBzdHJpbmcsXG4gICAgbXVsdGlhZGRyczogTXVsdGlhZGRyW10gfCBzdHJpbmdbXVxuICApOiB2b2lkIHtcbiAgICBsZXQgcGVlcjtcbiAgICBpZiAodHlwZW9mIHBlZXJJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBlZXIgPSBQZWVySWQuY3JlYXRlRnJvbUI1OFN0cmluZyhwZWVySWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWVyID0gcGVlcklkO1xuICAgIH1cbiAgICBjb25zdCBhZGRyZXNzZXMgPSBtdWx0aWFkZHJzLm1hcCgoYWRkcjogTXVsdGlhZGRyIHwgc3RyaW5nKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGFkZHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtdWx0aWFkZHIoYWRkcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYWRkcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmxpYnAycC5wZWVyU3RvcmUuYWRkcmVzc0Jvb2suc2V0KHBlZXIsIGFkZHJlc3Nlcyk7XG4gIH1cblxuICBhc3luYyBzdG9wKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmxpYnAycC5zdG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBkZWNyeXB0aW9uIGtleSB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgbWVzc2FnZXMgcmVjZWl2ZWQgdmlhXG4gICAqIFtbV2FrdVJlbGF5XV0gYW5kIFtbV2FrdVN0b3JlXV0uIFRoaXMgY2FuIGVpdGhlciBiZSBhIHByaXZhdGUga2V5IGZvclxuICAgKiBhc3ltbWV0cmljIGVuY3J5cHRpb24gb3IgYSBzeW1tZXRyaWMga2V5LlxuICAgKlxuICAgKiBTdHJpbmdzIG11c3QgYmUgaW4gaGV4IGZvcm1hdC5cbiAgICovXG4gIGFkZERlY3J5cHRpb25LZXkoXG4gICAga2V5OiBVaW50OEFycmF5IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IG1ldGhvZD86IERlY3J5cHRpb25NZXRob2Q7IGNvbnRlbnRUb3BpY3M/OiBzdHJpbmdbXSB9XG4gICk6IHZvaWQge1xuICAgIHRoaXMucmVsYXkuYWRkRGVjcnlwdGlvbktleShrZXksIG9wdGlvbnMpO1xuICAgIHRoaXMuc3RvcmUuYWRkRGVjcnlwdGlvbktleShrZXksIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGRlY3J5cHRpb24ga2V5IHRoYXQgd2FzIHVzZWQgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzXG4gICAqIHJlY2VpdmVkIHZpYSBbW1dha3VSZWxheV1dIG9yIFtbV2FrdVN0b3JlXV0uXG4gICAqXG4gICAqIFN0cmluZ3MgbXVzdCBiZSBpbiBoZXggZm9ybWF0LlxuICAgKi9cbiAgZGVsZXRlRGVjcnlwdGlvbktleShrZXk6IFVpbnQ4QXJyYXkgfCBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnJlbGF5LmRlbGV0ZURlY3J5cHRpb25LZXkoa2V5KTtcbiAgICB0aGlzLnN0b3JlLmRlbGV0ZURlY3J5cHRpb25LZXkoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxvY2FsIG11bHRpYWRkciB3aXRoIHBlZXIgaWQgb24gd2hpY2ggbGlicDJwIGlzIGxpc3RlbmluZy5cbiAgICogQHRocm93cyBpZiBsaWJwMnAgaXMgbm90IGxpc3RlbmluZyBvbiBsb2NhbGhvc3RcbiAgICovXG4gIGdldExvY2FsTXVsdGlhZGRyV2l0aElEKCk6IHN0cmluZyB7XG4gICAgY29uc3QgbG9jYWxNdWx0aWFkZHIgPSB0aGlzLmxpYnAycC5tdWx0aWFkZHJzLmZpbmQoKGFkZHIpID0+XG4gICAgICBhZGRyLnRvU3RyaW5nKCkubWF0Y2goLzEyN1xcLjBcXC4wXFwuMS8pXG4gICAgKTtcbiAgICBpZiAoIWxvY2FsTXVsdGlhZGRyIHx8IGxvY2FsTXVsdGlhZGRyLnRvU3RyaW5nKCkgPT09ICcnKSB7XG4gICAgICB0aHJvdyAnTm90IGxpc3RlbmluZyBvbiBsb2NhbGhvc3QnO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxNdWx0aWFkZHIgKyAnL3AycC8nICsgdGhpcy5saWJwMnAucGVlcklkLnRvQjU4U3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogV2FpdCB0byBiZSBjb25uZWN0ZWQgdG8gYSBwZWVyLiBVc2VmdWwgd2hlbiB1c2luZyB0aGUgW1tDcmVhdGVPcHRpb25zLmJvb3RzdHJhcF1dXG4gICAqIHdpdGggW1tXYWt1LmNyZWF0ZV1dLiBUaGUgUHJvbWlzZSByZXNvbHZlcyBvbmx5IG9uY2Ugd2UgYXJlIGNvbm5lY3RlZCB0byBhXG4gICAqIFN0b3JlIHBlZXIsIFJlbGF5IHBlZXIgYW5kIExpZ2h0IFB1c2ggcGVlci5cbiAgICovXG4gIGFzeW5jIHdhaXRGb3JDb25uZWN0ZWRQZWVyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRlc2lyZWRQcm90b2NvbHMgPSBbW1N0b3JlQ29kZWNdLCBbTGlnaHRQdXNoQ29kZWNdLCBSZWxheUNvZGVjc107XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGRlc2lyZWRQcm90b2NvbHMubWFwKChkZXNpcmVkUHJvdG9jb2xWZXJzaW9ucykgPT4ge1xuICAgICAgICBjb25zdCBwZWVycyA9IG5ldyBBcnJheTxQZWVyPigpO1xuICAgICAgICBkZXNpcmVkUHJvdG9jb2xWZXJzaW9ucy5mb3JFYWNoKChwcm90bykgPT4ge1xuICAgICAgICAgIGdldFBlZXJzRm9yUHJvdG9jb2wodGhpcy5saWJwMnAsIHByb3RvKS5mb3JFYWNoKChwZWVyKSA9PlxuICAgICAgICAgICAgcGVlcnMucHVzaChwZWVyKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwZWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIHBlZXIgYXZhaWxhYmxlIGZvciB0aGlzIHByb3RvY29sLCB3YWl0aW5nIHRvIGNvbm5lY3QgdG8gb25lLlxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saWJwMnAucGVlclN0b3JlLm9uKFxuICAgICAgICAgICAgICAnY2hhbmdlOnByb3RvY29scycsXG4gICAgICAgICAgICAgICh7IHByb3RvY29sczogY29ubmVjdGVkUGVlclByb3RvY29scyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgZGVzaXJlZFByb3RvY29sVmVyc2lvbnMuZm9yRWFjaCgoZGVzaXJlZFByb3RvKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGVkUGVlclByb3RvY29scy5pbmNsdWRlcyhkZXNpcmVkUHJvdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiZygnUmVzb2x2aW5nIGZvcicsIGRlc2lyZWRQcm90bywgY29ubmVjdGVkUGVlclByb3RvY29scyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGFydEtlZXBBbGl2ZShcbiAgICBwZWVySWQ6IFBlZXJJZCxcbiAgICBwaW5nUGVyaW9kU2VjczogbnVtYmVyLFxuICAgIHJlbGF5UGVyaW9kU2VjczogbnVtYmVyXG4gICk6IHZvaWQge1xuICAgIC8vIEp1c3QgaW4gY2FzZSBhIHRpbWVyIGFscmVhZHkgZXhpc3QgZm9yIHRoaXMgcGVlclxuICAgIHRoaXMuc3RvcEtlZXBBbGl2ZShwZWVySWQpO1xuXG4gICAgY29uc3QgcGVlcklkU3RyID0gcGVlcklkLnRvQjU4U3RyaW5nKCk7XG5cbiAgICBpZiAocGluZ1BlcmlvZFNlY3MgIT09IDApIHtcbiAgICAgIHRoaXMucGluZ0tlZXBBbGl2ZVRpbWVyc1twZWVySWRTdHJdID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBQaW5nKHRoaXMubGlicDJwLCBwZWVySWQpO1xuICAgICAgfSwgcGluZ1BlcmlvZFNlY3MgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBpZiAocmVsYXlQZXJpb2RTZWNzICE9PSAwKSB7XG4gICAgICB0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0gPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIFdha3VNZXNzYWdlLmZyb21CeXRlcyhuZXcgVWludDhBcnJheSgpLCBSZWxheVBpbmdDb250ZW50VG9waWMpLnRoZW4oXG4gICAgICAgICAgKHdha3VNc2cpID0+IHRoaXMucmVsYXkuc2VuZCh3YWt1TXNnKVxuICAgICAgICApO1xuICAgICAgfSwgcmVsYXlQZXJpb2RTZWNzICogMTAwMCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdG9wS2VlcEFsaXZlKHBlZXJJZDogUGVlcklkKTogdm9pZCB7XG4gICAgY29uc3QgcGVlcklkU3RyID0gcGVlcklkLnRvQjU4U3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5waW5nS2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0pIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5waW5nS2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0pO1xuICAgICAgZGVsZXRlIHRoaXMucGluZ0tlZXBBbGl2ZVRpbWVyc1twZWVySWRTdHJdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl0pIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5yZWxheUtlZXBBbGl2ZVRpbWVyc1twZWVySWRTdHJdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnJlbGF5S2VlcEFsaXZlVGltZXJzW3BlZXJJZFN0cl07XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgY29uY2F0IGZyb20gJ2l0LWNvbmNhdCc7XG5pbXBvcnQgbHAgZnJvbSAnaXQtbGVuZ3RoLXByZWZpeGVkJztcbmltcG9ydCBwaXBlIGZyb20gJ2l0LXBpcGUnO1xuaW1wb3J0IExpYnAycCBmcm9tICdsaWJwMnAnO1xuaW1wb3J0IHsgUGVlciB9IGZyb20gJ2xpYnAycC9zcmMvcGVlci1zdG9yZSc7XG5pbXBvcnQgUGVlcklkIGZyb20gJ3BlZXItaWQnO1xuXG5pbXBvcnQgeyBQdXNoUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9wcm90by93YWt1L3YyL2xpZ2h0X3B1c2gnO1xuaW1wb3J0IHsgZ2V0UGVlcnNGb3JQcm90b2NvbCwgc2VsZWN0UmFuZG9tUGVlciB9IGZyb20gJy4uL3NlbGVjdF9wZWVyJztcbmltcG9ydCB7IERlZmF1bHRQdWJTdWJUb3BpYyB9IGZyb20gJy4uL3dha3UnO1xuaW1wb3J0IHsgV2FrdU1lc3NhZ2UgfSBmcm9tICcuLi93YWt1X21lc3NhZ2UnO1xuXG5pbXBvcnQgeyBQdXNoUlBDIH0gZnJvbSAnLi9wdXNoX3JwYyc7XG5cbmV4cG9ydCBjb25zdCBMaWdodFB1c2hDb2RlYyA9ICcvdmFjL3dha3UvbGlnaHRwdXNoLzIuMC4wLWJldGExJztcbmV4cG9ydCB7IFB1c2hSZXNwb25zZSB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIFB1YlN1YiBUb3BpYyB0byB1c2UuIERlZmF1bHRzIHRvIHtAbGluayBEZWZhdWx0UHViU3ViVG9waWN9LlxuICAgKlxuICAgKiBUaGUgdXNhZ2Ugb2YgdGhlIGRlZmF1bHQgcHVic3ViIHRvcGljIGlzIHJlY29tbWVuZGVkLlxuICAgKiBTZWUgW1dha3UgdjIgVG9waWMgVXNhZ2UgUmVjb21tZW5kYXRpb25zXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMjMvKSBmb3IgZGV0YWlscy5cbiAgICpcbiAgICogQGRlZmF1bHQge0BsaW5rIERlZmF1bHRQdWJTdWJUb3BpY31cbiAgICovXG4gIHB1YlN1YlRvcGljPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFB1c2hPcHRpb25zIHtcbiAgcGVlcklkPzogUGVlcklkO1xuICBwdWJTdWJUb3BpYz86IHN0cmluZztcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBbV2FrdSB2MiBMaWdodCBQdXNoIHByb3RvY29sXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMTkvKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdha3VMaWdodFB1c2gge1xuICBwdWJTdWJUb3BpYzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBsaWJwMnA6IExpYnAycCwgb3B0aW9ucz86IENyZWF0ZU9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8ucHViU3ViVG9waWMpIHtcbiAgICAgIHRoaXMucHViU3ViVG9waWMgPSBvcHRpb25zLnB1YlN1YlRvcGljO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1YlN1YlRvcGljID0gRGVmYXVsdFB1YlN1YlRvcGljO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHB1c2goXG4gICAgbWVzc2FnZTogV2FrdU1lc3NhZ2UsXG4gICAgb3B0cz86IFB1c2hPcHRpb25zXG4gICk6IFByb21pc2U8UHVzaFJlc3BvbnNlIHwgbnVsbD4ge1xuICAgIGxldCBwZWVyO1xuICAgIGlmIChvcHRzPy5wZWVySWQpIHtcbiAgICAgIHBlZXIgPSB0aGlzLmxpYnAycC5wZWVyU3RvcmUuZ2V0KG9wdHMucGVlcklkKTtcbiAgICAgIGlmICghcGVlcikgdGhyb3cgJ1BlZXIgaXMgdW5rbm93bic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZXIgPSB0aGlzLnJhbmRvbVBlZXI7XG4gICAgfVxuICAgIGlmICghcGVlcikgdGhyb3cgJ05vIHBlZXIgYXZhaWxhYmxlJztcbiAgICBpZiAoIXBlZXIucHJvdG9jb2xzLmluY2x1ZGVzKExpZ2h0UHVzaENvZGVjKSlcbiAgICAgIHRocm93ICdQZWVyIGRvZXMgbm90IHJlZ2lzdGVyIHdha3UgbGlnaHQgcHVzaCBwcm90b2NvbCc7XG5cbiAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5saWJwMnAuY29ubmVjdGlvbk1hbmFnZXIuZ2V0KHBlZXIuaWQpO1xuICAgIGlmICghY29ubmVjdGlvbikgdGhyb3cgJ0ZhaWxlZCB0byBnZXQgYSBjb25uZWN0aW9uIHRvIHRoZSBwZWVyJztcblxuICAgIGNvbnN0IHsgc3RyZWFtIH0gPSBhd2FpdCBjb25uZWN0aW9uLm5ld1N0cmVhbShMaWdodFB1c2hDb2RlYyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHB1YlN1YlRvcGljID0gb3B0cz8ucHViU3ViVG9waWNcbiAgICAgICAgPyBvcHRzLnB1YlN1YlRvcGljXG4gICAgICAgIDogdGhpcy5wdWJTdWJUb3BpYztcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gUHVzaFJQQy5jcmVhdGVSZXF1ZXN0KG1lc3NhZ2UsIHB1YlN1YlRvcGljKTtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHBpcGUoXG4gICAgICAgIFtxdWVyeS5lbmNvZGUoKV0sXG4gICAgICAgIGxwLmVuY29kZSgpLFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIGxwLmRlY29kZSgpLFxuICAgICAgICBjb25jYXRcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IFB1c2hSUEMuZGVjb2RlKHJlcy5zbGljZSgpKS5yZXNwb25zZTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ05vIHJlc3BvbnNlIGluIFB1c2hSUEMnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGRlY29kZSBwdXNoIHJlcGx5JywgZXJyKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGYWlsZWQgdG8gc2VuZCB3YWt1IGxpZ2h0IHB1c2ggcmVxdWVzdCcsIGVycik7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMga25vd24gcGVlcnMgZnJvbSB0aGUgYWRkcmVzcyBib29rIChgbGlicDJwLnBlZXJTdG9yZWApIHRoYXQgc3VwcG9ydFxuICAgKiBsaWdodCBwdXNoIHByb3RvY29sLiBXYWt1IG1heSBvciAgbWF5IG5vdCBiZSBjdXJyZW50bHkgY29ubmVjdGVkIHRvIHRoZXNlIHBlZXJzLlxuICAgKi9cbiAgZ2V0IHBlZXJzKCk6IFBlZXJbXSB7XG4gICAgcmV0dXJuIGdldFBlZXJzRm9yUHJvdG9jb2wodGhpcy5saWJwMnAsIExpZ2h0UHVzaENvZGVjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmFuZG9tIHBlZXIgdGhhdCBzdXBwb3J0cyBsaWdodCBwdXNoIHByb3RvY29sIGZyb20gdGhlIGFkZHJlc3NcbiAgICogYm9vayAoYGxpYnAycC5wZWVyU3RvcmVgKS4gV2FrdSBtYXkgb3IgIG1heSBub3QgYmUgY3VycmVudGx5IGNvbm5lY3RlZCB0b1xuICAgKiB0aGlzIHBlZXIuXG4gICAqL1xuICBnZXQgcmFuZG9tUGVlcigpOiBQZWVyIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gc2VsZWN0UmFuZG9tUGVlcih0aGlzLnBlZXJzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUmVhZGVyIH0gZnJvbSAncHJvdG9idWZqcy9taW5pbWFsJztcbmltcG9ydCB7IHY0IGFzIHV1aWQgfSBmcm9tICd1dWlkJztcblxuaW1wb3J0ICogYXMgcHJvdG8gZnJvbSAnLi4vLi4vcHJvdG8vd2FrdS92Mi9saWdodF9wdXNoJztcbmltcG9ydCB7IFdha3VNZXNzYWdlIH0gZnJvbSAnLi4vd2FrdV9tZXNzYWdlJztcblxuZXhwb3J0IGNsYXNzIFB1c2hSUEMge1xuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHByb3RvOiBwcm90by5QdXNoUlBDKSB7fVxuXG4gIHN0YXRpYyBjcmVhdGVSZXF1ZXN0KG1lc3NhZ2U6IFdha3VNZXNzYWdlLCBwdWJTdWJUb3BpYzogc3RyaW5nKTogUHVzaFJQQyB7XG4gICAgcmV0dXJuIG5ldyBQdXNoUlBDKHtcbiAgICAgIHJlcXVlc3RJZDogdXVpZCgpLFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLnByb3RvLFxuICAgICAgICBwdWJTdWJUb3BpYzogcHViU3ViVG9waWMsXG4gICAgICB9LFxuICAgICAgcmVzcG9uc2U6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBkZWNvZGUoYnl0ZXM6IFVpbnQ4QXJyYXkpOiBQdXNoUlBDIHtcbiAgICBjb25zdCByZXMgPSBwcm90by5QdXNoUlBDLmRlY29kZShSZWFkZXIuY3JlYXRlKGJ5dGVzKSk7XG4gICAgcmV0dXJuIG5ldyBQdXNoUlBDKHJlcyk7XG4gIH1cblxuICBlbmNvZGUoKTogVWludDhBcnJheSB7XG4gICAgcmV0dXJuIHByb3RvLlB1c2hSUEMuZW5jb2RlKHRoaXMucHJvdG8pLmZpbmlzaCgpO1xuICB9XG5cbiAgZ2V0IHF1ZXJ5KCk6IHByb3RvLlB1c2hSZXF1ZXN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wcm90by5yZXF1ZXN0O1xuICB9XG5cbiAgZ2V0IHJlc3BvbnNlKCk6IHByb3RvLlB1c2hSZXNwb25zZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8ucmVzcG9uc2U7XG4gIH1cbn1cbiIsIi8vIEVuc3VyZSB0aGF0IHRoaXMgY2xhc3MgbWF0Y2hlcyB0aGUgcHJvdG8gaW50ZXJmYWNlIHdoaWxlXG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuXG5pbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IHsgUmVhZGVyIH0gZnJvbSAncHJvdG9idWZqcy9taW5pbWFsJztcblxuLy8gUHJvdGVjdGluZyB0aGUgdXNlciBmcm9tIHByb3RvYnVmIG9kZGl0aWVzXG5pbXBvcnQgKiBhcyBwcm90byBmcm9tICcuLi8uLi9wcm90by93YWt1L3YyL21lc3NhZ2UnO1xuXG5pbXBvcnQgKiBhcyB2ZXJzaW9uXzEgZnJvbSAnLi92ZXJzaW9uXzEnO1xuXG5jb25zdCBEZWZhdWx0VmVyc2lvbiA9IDA7XG5jb25zdCBkYmcgPSBkZWJ1Zygnd2FrdTptZXNzYWdlJyk7XG5cbmV4cG9ydCBlbnVtIERlY3J5cHRpb25NZXRob2Qge1xuICBBc3ltbWV0cmljID0gJ2FzeW1tZXRyaWMnLFxuICBTeW1tZXRyaWMgPSAnc3ltbWV0cmljJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRpbWVzdGFtcCB0byBzZXQgb24gdGhlIG1lc3NhZ2UsIGRlZmF1bHRzIHRvIG5vdyBpZiBub3QgcGFzc2VkLlxuICAgKi9cbiAgdGltZXN0YW1wPzogRGF0ZTtcbiAgLyoqXG4gICAqIFB1YmxpYyBLZXkgdG8gdXNlIHRvIGVuY3J5cHQgdGhlIG1lc3NhZ2VzIHVzaW5nIEVDSUVTIChBc3ltbWV0cmljIEVuY3J5cHRpb24pLlxuICAgKlxuICAgKiBAdGhyb3dzIGlmIGJvdGggYGVuY1B1YmxpY0tleWAgYW5kIGBzeW1LZXlgIGFyZSBwYXNzZWRcbiAgICovXG4gIGVuY1B1YmxpY0tleT86IFVpbnQ4QXJyYXkgfCBzdHJpbmc7XG4gIC8qKlxuICAgKiBLZXkgdG8gdXNlIHRvIGVuY3J5cHQgdGhlIG1lc3NhZ2VzIHVzaW5nIEFFUyAoU3ltbWV0cmljIEVuY3J5cHRpb24pLlxuICAgKlxuICAgKiBAdGhyb3dzIGlmIGJvdGggYGVuY1B1YmxpY0tleWAgYW5kIGBzeW1LZXlgIGFyZSBwYXNzZWRcbiAgICovXG4gIHN5bUtleT86IFVpbnQ4QXJyYXkgfCBzdHJpbmc7XG4gIC8qKlxuICAgKiBQcml2YXRlIGtleSB0byB1c2UgdG8gc2lnbiB0aGUgbWVzc2FnZSwgZWl0aGVyIGBlbmNQdWJsaWNLZXlgIG9yIGBzeW1LZXlgIG11c3QgYmUgcHJvdmlkZWQgYXMgb25seVxuICAgKiBlbmNyeXB0ZWQgbWVzc2FnZXMgYXJlIHNpZ25lZC5cbiAgICovXG4gIHNpZ1ByaXZLZXk/OiBVaW50OEFycmF5O1xufVxuXG5leHBvcnQgY2xhc3MgV2FrdU1lc3NhZ2Uge1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBwcm90bzogcHJvdG8uV2FrdU1lc3NhZ2UsXG4gICAgcHJpdmF0ZSBfc2lnbmF0dXJlUHVibGljS2V5PzogVWludDhBcnJheSxcbiAgICBwcml2YXRlIF9zaWduYXR1cmU/OiBVaW50OEFycmF5XG4gICkge31cblxuICAvKipcbiAgICogQ3JlYXRlIE1lc3NhZ2Ugd2l0aCBhbiB1dGYtOCBzdHJpbmcgYXMgcGF5bG9hZC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tVXRmOFN0cmluZyhcbiAgICB1dGY4OiBzdHJpbmcsXG4gICAgY29udGVudFRvcGljOiBzdHJpbmcsXG4gICAgb3B0cz86IE9wdGlvbnNcbiAgKTogUHJvbWlzZTxXYWt1TWVzc2FnZT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbSh1dGY4LCAndXRmLTgnKTtcbiAgICByZXR1cm4gV2FrdU1lc3NhZ2UuZnJvbUJ5dGVzKHBheWxvYWQsIGNvbnRlbnRUb3BpYywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgV2FrdSBNZXNzYWdlIHdpdGggdGhlIGdpdmVuIHBheWxvYWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBwYXlsb2FkIGlzIGtlcHQgY2xlYXIgKHZlcnNpb24gMCkuXG4gICAqIElmIGBvcHRzLmVuY1B1YmxpY0tleWAgaXMgcGFzc2VkLCB0aGUgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgdXNpbmdcbiAgICogYXN5bW1ldHJpYyBlbmNyeXB0aW9uICh2ZXJzaW9uIDEpLlxuICAgKlxuICAgKiBJZiBgb3B0cy5zaWdQcml2S2V5YCBpcyBwYXNzZWQgYW5kIHZlcnNpb24gMSBpcyB1c2VkLCB0aGUgcGF5bG9hZCBpcyBzaWduZWRcbiAgICogYmVmb3JlIGVuY3J5cHRpb24uXG4gICAqXG4gICAqIEB0aHJvd3MgaWYgYm90aCBgb3B0cy5lbmNQdWJsaWNLZXlgIGFuZCBgb3B0LnN5bUtleWAgYXJlIHBhc3NlZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZyb21CeXRlcyhcbiAgICBwYXlsb2FkOiBVaW50OEFycmF5LFxuICAgIGNvbnRlbnRUb3BpYzogc3RyaW5nLFxuICAgIG9wdHM/OiBPcHRpb25zXG4gICk6IFByb21pc2U8V2FrdU1lc3NhZ2U+IHtcbiAgICBjb25zdCB7IHRpbWVzdGFtcCwgZW5jUHVibGljS2V5LCBzeW1LZXksIHNpZ1ByaXZLZXkgfSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7IHRpbWVzdGFtcDogbmV3IERhdGUoKSB9LFxuICAgICAgb3B0cyA/IG9wdHMgOiB7fVxuICAgICk7XG5cbiAgICBsZXQgX3BheWxvYWQgPSBwYXlsb2FkO1xuICAgIGxldCB2ZXJzaW9uID0gRGVmYXVsdFZlcnNpb247XG4gICAgbGV0IHNpZztcblxuICAgIGlmIChlbmNQdWJsaWNLZXkgJiYgc3ltS2V5KSB7XG4gICAgICB0aHJvdyAnUGFzcyBlaXRoZXIgYGVuY1B1YmxpY0tleWAgb3IgYHN5bUtleWAsIG5vdCBib3RoLic7XG4gICAgfVxuXG4gICAgaWYgKGVuY1B1YmxpY0tleSkge1xuICAgICAgY29uc3QgZW5jID0gdmVyc2lvbl8xLmNsZWFyRW5jb2RlKF9wYXlsb2FkLCBzaWdQcml2S2V5KTtcbiAgICAgIF9wYXlsb2FkID0gYXdhaXQgdmVyc2lvbl8xLmVuY3J5cHRBc3ltbWV0cmljKGVuYy5wYXlsb2FkLCBlbmNQdWJsaWNLZXkpO1xuICAgICAgc2lnID0gZW5jLnNpZztcbiAgICAgIHZlcnNpb24gPSAxO1xuICAgIH0gZWxzZSBpZiAoc3ltS2V5KSB7XG4gICAgICBjb25zdCBlbmMgPSB2ZXJzaW9uXzEuY2xlYXJFbmNvZGUoX3BheWxvYWQsIHNpZ1ByaXZLZXkpO1xuICAgICAgX3BheWxvYWQgPSBhd2FpdCB2ZXJzaW9uXzEuZW5jcnlwdFN5bW1ldHJpYyhlbmMucGF5bG9hZCwgc3ltS2V5KTtcbiAgICAgIHNpZyA9IGVuYy5zaWc7XG4gICAgICB2ZXJzaW9uID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFdha3VNZXNzYWdlKFxuICAgICAge1xuICAgICAgICBwYXlsb2FkOiBfcGF5bG9hZCxcbiAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAudmFsdWVPZigpIC8gMTAwMCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgY29udGVudFRvcGljLFxuICAgICAgfSxcbiAgICAgIHNpZz8ucHVibGljS2V5LFxuICAgICAgc2lnPy5zaWduYXR1cmVcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGJ5dGUgYXJyYXkgaW50byBXYWt1IE1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbXMgYnl0ZXMgVGhlIG1lc3NhZ2UgZW5jb2RlZCB1c2luZyBwcm90b2J1ZiBhcyBkZWZpbmVkIGluIFsxNC9XQUtVMi1NRVNTQUdFXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMTQvKS5cbiAgICogQHBhcmFtcyBkZWNyeXB0aW9uS2V5cyBJZiB0aGUgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgKHZlcnNpb24gPSAxKSwgdGhlbiB0aGVcbiAgICoga2V5cyBhcmUgdXNlZCB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgdGhlIG1lc3NhZ2UuIFRoZSBwYXNzZWQga2V5IGNhbiBlaXRoZXJcbiAgICogYmUgYXN5bW1ldHJpYyBwcml2YXRlIGtleXMgb3Igc3ltbWV0cmljIGtleXMsIGJvdGggbWV0aG9kIGFyZSB0cmllZCBmb3IgZWFjaFxuICAgKiBrZXkgdW50aWwgdGhlIG1lc3NhZ2UgaXMgZGVjcnlwdGVkIG9yIGNvbWJpbmF0aW9ucyBhcmUgcnVuIG91dC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWNvZGUoXG4gICAgYnl0ZXM6IFVpbnQ4QXJyYXksXG4gICAgZGVjcnlwdGlvbktleXM/OiBBcnJheTx7XG4gICAgICBrZXk6IFVpbnQ4QXJyYXk7XG4gICAgICBtZXRob2Q/OiBEZWNyeXB0aW9uTWV0aG9kO1xuICAgICAgY29udGVudFRvcGljPzogc3RyaW5nW107XG4gICAgfT5cbiAgKTogUHJvbWlzZTxXYWt1TWVzc2FnZSB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IHByb3RvQnVmID0gcHJvdG8uV2FrdU1lc3NhZ2UuZGVjb2RlKFJlYWRlci5jcmVhdGUoYnl0ZXMpKTtcblxuICAgIHJldHVybiBXYWt1TWVzc2FnZS5kZWNvZGVQcm90byhwcm90b0J1ZiwgZGVjcnlwdGlvbktleXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbmQgZGVjcnlwdCBXYWt1IE1lc3NhZ2UgUHJvdG9idWYgT2JqZWN0IGludG8gV2FrdSBNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW1zIHByb3RvQnVmIFRoZSBtZXNzYWdlIHRvIGRlY29kZSBhbmQgZGVjcnlwdC5cbiAgICogQHBhcmFtcyBkZWNyeXB0aW9uS2V5cyBJZiB0aGUgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgKHZlcnNpb24gPSAxKSwgdGhlbiB0aGVcbiAgICoga2V5cyBhcmUgdXNlZCB0byBhdHRlbXB0IGRlY3J5cHRpb24gb2YgdGhlIG1lc3NhZ2UuIFRoZSBwYXNzZWQga2V5IGNhbiBlaXRoZXJcbiAgICogYmUgYXN5bW1ldHJpYyBwcml2YXRlIGtleXMgb3Igc3ltbWV0cmljIGtleXMsIGJvdGggbWV0aG9kIGFyZSB0cmllZCBmb3IgZWFjaFxuICAgKiBrZXkgdW50aWwgdGhlIG1lc3NhZ2UgaXMgZGVjcnlwdGVkIG9yIGNvbWJpbmF0aW9ucyBhcmUgcnVuIG91dC5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBkZWNvZGVQcm90byhcbiAgICBwcm90b0J1ZjogcHJvdG8uV2FrdU1lc3NhZ2UsXG4gICAgZGVjcnlwdGlvbktleXM/OiBBcnJheTx7XG4gICAgICBrZXk6IFVpbnQ4QXJyYXk7XG4gICAgICBtZXRob2Q/OiBEZWNyeXB0aW9uTWV0aG9kO1xuICAgICAgY29udGVudFRvcGljcz86IHN0cmluZ1tdO1xuICAgIH0+XG4gICk6IFByb21pc2U8V2FrdU1lc3NhZ2UgfCB1bmRlZmluZWQ+IHtcbiAgICBpZiAocHJvdG9CdWYucGF5bG9hZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYmcoJ1BheWxvYWQgaXMgdW5kZWZpbmVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSBwcm90b0J1Zi5wYXlsb2FkO1xuXG4gICAgbGV0IHNpZ25hdHVyZVB1YmxpY0tleTtcbiAgICBsZXQgc2lnbmF0dXJlO1xuICAgIGlmIChwcm90b0J1Zi52ZXJzaW9uID09PSAxICYmIHByb3RvQnVmLnBheWxvYWQpIHtcbiAgICAgIGlmIChkZWNyeXB0aW9uS2V5cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRiZygnUGF5bG9hZCBpcyBlbmNyeXB0ZWQgYnV0IG5vIHByaXZhdGUga2V5cyBoYXZlIGJlZW4gcHJvdmlkZWQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJucyBhIGJ1bmNoIG9mIGB1bmRlZmluZWRgIGFuZCBob3BlZnVsbHkgb25lIGRlY3J5cHRlZCByZXN1bHRcbiAgICAgIGNvbnN0IGFsbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgZGVjcnlwdGlvbktleXMubWFwKGFzeW5jICh7IGtleSwgbWV0aG9kLCBjb250ZW50VG9waWNzIH0pID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhY29udGVudFRvcGljcyB8fFxuICAgICAgICAgICAgKHByb3RvQnVmLmNvbnRlbnRUb3BpYyAmJlxuICAgICAgICAgICAgICBjb250ZW50VG9waWNzLmluY2x1ZGVzKHByb3RvQnVmLmNvbnRlbnRUb3BpYykpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgICBjYXNlIERlY3J5cHRpb25NZXRob2QuQXN5bW1ldHJpYzpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHZlcnNpb25fMS5kZWNyeXB0QXN5bW1ldHJpYyhwYXlsb2FkLCBrZXkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIGRiZyhcbiAgICAgICAgICAgICAgICAgICAgJ0ZhaWxlZCB0byBkZWNyeXB0IG1lc3NhZ2UgdXNpbmcgc3ltbWV0cmljIGVuY3J5cHRpb24gZGVzcGl0ZSBkZWNyeXB0aW9uIG1ldGhvZCBiZWluZyBzcGVjaWZpZWQnLFxuICAgICAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBEZWNyeXB0aW9uTWV0aG9kLlN5bW1ldHJpYzpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHZlcnNpb25fMS5kZWNyeXB0U3ltbWV0cmljKHBheWxvYWQsIGtleSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgZGJnKFxuICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGRlY3J5cHQgbWVzc2FnZSB1c2luZyBhc3ltbWV0cmljIGVuY3J5cHRpb24gZGVzcGl0ZSBkZWNyeXB0aW9uIG1ldGhvZCBiZWluZyBzcGVjaWZpZWQnLFxuICAgICAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHZlcnNpb25fMS5kZWNyeXB0U3ltbWV0cmljKHBheWxvYWQsIGtleSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgZGJnKFxuICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGRlY3J5cHQgbWVzc2FnZSB1c2luZyBzeW1tZXRyaWMgZW5jcnlwdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdmVyc2lvbl8xLmRlY3J5cHRBc3ltbWV0cmljKHBheWxvYWQsIGtleSk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiZyhcbiAgICAgICAgICAgICAgICAgICAgICAnRmFpbGVkIHRvIGRlY3J5cHQgbWVzc2FnZSB1c2luZyBhc3ltbWV0cmljIGVuY3J5cHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8ga2V5IGF2YWlsYWJsZSBmb3IgdGhpcyBjb250ZW50IHRvcGljXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgaXNEZWZpbmVkID0gKGRlYzogVWludDhBcnJheSB8IHVuZGVmaW5lZCk6IGRlYyBpcyBVaW50OEFycmF5ID0+IHtcbiAgICAgICAgcmV0dXJuICEhZGVjO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZGVjb2RlZFJlc3VsdHMgPSBhbGxSZXN1bHRzLmZpbHRlcihpc0RlZmluZWQpO1xuXG4gICAgICBpZiAoZGVjb2RlZFJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRiZygnRmFpbGVkIHRvIGRlY3J5cHQgcGF5bG9hZC4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVjID0gZGVjb2RlZFJlc3VsdHNbMF07XG5cbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHZlcnNpb25fMS5jbGVhckRlY29kZShkZWMpO1xuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgZGJnKCdGYWlsZWQgdG8gZGVjb2RlIHBheWxvYWQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5hc3NpZ24ocHJvdG9CdWYsIHsgcGF5bG9hZDogcmVzLnBheWxvYWQgfSk7XG4gICAgICBzaWduYXR1cmVQdWJsaWNLZXkgPSByZXMuc2lnPy5wdWJsaWNLZXk7XG4gICAgICBzaWduYXR1cmUgPSByZXMuc2lnPy5zaWduYXR1cmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBXYWt1TWVzc2FnZShwcm90b0J1Ziwgc2lnbmF0dXJlUHVibGljS2V5LCBzaWduYXR1cmUpO1xuICB9XG5cbiAgZW5jb2RlKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBwcm90by5XYWt1TWVzc2FnZS5lbmNvZGUodGhpcy5wcm90bykuZmluaXNoKCk7XG4gIH1cblxuICBnZXQgcGF5bG9hZEFzVXRmOCgpOiBzdHJpbmcge1xuICAgIGlmICghdGhpcy5wcm90by5wYXlsb2FkKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMucHJvdG8ucGF5bG9hZCkudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gIH1cblxuICBnZXQgcGF5bG9hZCgpOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5wcm90by5wYXlsb2FkO1xuICB9XG5cbiAgZ2V0IGNvbnRlbnRUb3BpYygpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnByb3RvLmNvbnRlbnRUb3BpYztcbiAgfVxuXG4gIGdldCB2ZXJzaW9uKCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8udmVyc2lvbjtcbiAgfVxuXG4gIGdldCB0aW1lc3RhbXAoKTogRGF0ZSB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMucHJvdG8udGltZXN0YW1wKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5wcm90by50aW1lc3RhbXAgKiAxMDAwKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwdWJsaWMga2V5IHVzZWQgdG8gc2lnbiB0aGUgbWVzc2FnZS5cbiAgICpcbiAgICogTUFZIGJlIHByZXNlbnQgaWYgdGhlIG1lc3NhZ2UgaXMgdmVyc2lvbiAxLlxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZVB1YmxpY0tleSgpOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmF0dXJlUHVibGljS2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzaWduYXR1cmUgb2YgdGhlIG1lc3NhZ2UuXG4gICAqXG4gICAqIE1BWSBiZSBwcmVzZW50IGlmIHRoZSBtZXNzYWdlIGlzIHZlcnNpb24gMS5cbiAgICovXG4gIGdldCBzaWduYXR1cmUoKTogVWludDhBcnJheSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25hdHVyZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSXZTaXplIH0gZnJvbSAnLi9pbmRleCc7XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgbXNDcnlwdG8/OiBDcnlwdG87XG4gIH1cbiAgaW50ZXJmYWNlIENyeXB0byB7XG4gICAgd2Via2l0U3VidGxlPzogU3VidGxlQ3J5cHRvO1xuICB9XG59XG5cbmNvbnN0IGNyeXB0byA9IHdpbmRvdy5jcnlwdG8gfHwgd2luZG93Lm1zQ3J5cHRvO1xuY29uc3Qgc3VidGxlOiBTdWJ0bGVDcnlwdG8gPSBjcnlwdG8uc3VidGxlIHx8IGNyeXB0by53ZWJraXRTdWJ0bGU7XG5cbmNvbnN0IEFsZ29yaXRobSA9IHsgbmFtZTogJ0FFUy1HQ00nLCBsZW5ndGg6IDEyOCB9O1xuXG5pZiAoc3VidGxlID09PSB1bmRlZmluZWQpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBTdWJ0bGUgQ3J5cHRvQVBJJyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0KFxuICBpdjogQnVmZmVyIHwgVWludDhBcnJheSxcbiAga2V5OiBCdWZmZXIsXG4gIGNsZWFyVGV4dDogQnVmZmVyXG4pOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICByZXR1cm4gc3VidGxlXG4gICAgLmltcG9ydEtleSgncmF3Jywga2V5LCBBbGdvcml0aG0sIGZhbHNlLCBbJ2VuY3J5cHQnXSlcbiAgICAudGhlbigoY3J5cHRvS2V5KSA9PlxuICAgICAgc3VidGxlLmVuY3J5cHQoeyBpdiwgLi4uQWxnb3JpdGhtIH0sIGNyeXB0b0tleSwgY2xlYXJUZXh0KVxuICAgIClcbiAgICAudGhlbihCdWZmZXIuZnJvbSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0KFxuICBpdjogQnVmZmVyLFxuICBrZXk6IEJ1ZmZlcixcbiAgY2lwaGVyVGV4dDogQnVmZmVyXG4pOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICByZXR1cm4gc3VidGxlXG4gICAgLmltcG9ydEtleSgncmF3Jywga2V5LCBBbGdvcml0aG0sIGZhbHNlLCBbJ2RlY3J5cHQnXSlcbiAgICAudGhlbigoY3J5cHRvS2V5KSA9PlxuICAgICAgc3VidGxlLmRlY3J5cHQoeyBpdiwgLi4uQWxnb3JpdGhtIH0sIGNyeXB0b0tleSwgY2lwaGVyVGV4dClcbiAgICApXG4gICAgLnRoZW4oQnVmZmVyLmZyb20pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVJdigpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgaXYgPSBuZXcgVWludDhBcnJheShJdlNpemUpO1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGl2KTtcbiAgcmV0dXJuIGl2O1xufVxuIiwiZXhwb3J0IGNvbnN0IFN5bW1ldHJpY0tleVNpemUgPSAzMjtcbmV4cG9ydCBjb25zdCBJdlNpemUgPSAxMjtcbmV4cG9ydCBjb25zdCBUYWdTaXplID0gMTY7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3ltbWV0cmljIHtcbiAgLyoqXG4gICAqIFByb2NlZWQgd2l0aCBzeW1tZXRyaWMgZW5jcnlwdGlvbiBvZiBgY2xlYXJUZXh0YCB2YWx1ZS5cbiAgICovXG4gIGVuY3J5cHQ6IChcbiAgICBpdjogQnVmZmVyIHwgVWludDhBcnJheSxcbiAgICBrZXk6IEJ1ZmZlcixcbiAgICBjbGVhclRleHQ6IEJ1ZmZlclxuICApID0+IFByb21pc2U8QnVmZmVyPjtcbiAgLyoqXG4gICAqIFByb2NlZWQgd2l0aCBzeW1tZXRyaWMgZGVjcnlwdGlvbiBvZiBgY2lwaGVyVGV4dGAgdmFsdWUuXG4gICAqL1xuICBkZWNyeXB0OiAoaXY6IEJ1ZmZlciwga2V5OiBCdWZmZXIsIGNpcGhlclRleHQ6IEJ1ZmZlcikgPT4gUHJvbWlzZTxCdWZmZXI+O1xuICAvKipcbiAgICogR2VuZXJhdGUgYW4gSW5pdGlhbGl6YXRpb24gVmVjdG9yIChpdikgZm9yIGZvciBTeW1tZXRyaWMgZW5jcnlwdGlvbiBwdXJwb3Nlcy5cbiAgICovXG4gIGdlbmVyYXRlSXY6ICgpID0+IFVpbnQ4QXJyYXk7XG59XG5cbmV4cG9ydCBsZXQgc3ltbWV0cmljOiBTeW1tZXRyaWMgPSB7fSBhcyB1bmtub3duIGFzIFN5bW1ldHJpYztcblxuaW1wb3J0KCcuL2Jyb3dzZXInKVxuICAudGhlbigobW9kKSA9PiB7XG4gICAgc3ltbWV0cmljID0gbW9kO1xuICB9KVxuICAuY2F0Y2goKGVCcm93c2VyKSA9PiB7XG4gICAgaW1wb3J0KCcuL25vZGUnKVxuICAgICAgLnRoZW4oKG1vZCkgPT4ge1xuICAgICAgICBzeW1tZXRyaWMgPSBtb2Q7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlTm9kZSkgPT4ge1xuICAgICAgICB0aHJvdyBgQ291bGQgbm90IGxvYWQgYW55IHN5bW1ldHJpYyBjcnlwdG8gbW9kdWxlczogJHtlQnJvd3Nlcn0sICR7ZU5vZGV9YDtcbiAgICAgIH0pO1xuICB9KTtcbiIsImltcG9ydCB7IGNyZWF0ZUNpcGhlcml2LCBjcmVhdGVEZWNpcGhlcml2LCByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0byc7XG5cbmltcG9ydCB7IEl2U2l6ZSwgVGFnU2l6ZSB9IGZyb20gJy4vaW5kZXgnO1xuXG5jb25zdCBBbGdvcml0aG0gPSAnYWVzLTI1Ni1nY20nO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChcbiAgaXY6IEJ1ZmZlciB8IFVpbnQ4QXJyYXksXG4gIGtleTogQnVmZmVyLFxuICBjbGVhclRleHQ6IEJ1ZmZlclxuKTogUHJvbWlzZTxCdWZmZXI+IHtcbiAgY29uc3QgY2lwaGVyID0gY3JlYXRlQ2lwaGVyaXYoQWxnb3JpdGhtLCBrZXksIGl2KTtcbiAgY29uc3QgYSA9IGNpcGhlci51cGRhdGUoY2xlYXJUZXh0KTtcbiAgY29uc3QgYiA9IGNpcGhlci5maW5hbCgpO1xuICBjb25zdCB0YWcgPSBjaXBoZXIuZ2V0QXV0aFRhZygpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbYSwgYiwgdGFnXSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0KFxuICBpdjogQnVmZmVyLFxuICBrZXk6IEJ1ZmZlcixcbiAgZGF0YTogQnVmZmVyXG4pOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICBjb25zdCB0YWdTdGFydCA9IGRhdGEubGVuZ3RoIC0gVGFnU2l6ZTtcbiAgY29uc3QgY2lwaGVyVGV4dCA9IGRhdGEuc2xpY2UoMCwgdGFnU3RhcnQpO1xuICBjb25zdCB0YWcgPSBkYXRhLnNsaWNlKHRhZ1N0YXJ0KTtcbiAgY29uc3QgZGVjaXBoZXIgPSBjcmVhdGVEZWNpcGhlcml2KEFsZ29yaXRobSwga2V5LCBpdik7XG4gIGRlY2lwaGVyLnNldEF1dGhUYWcodGFnKTtcbiAgY29uc3QgYSA9IGRlY2lwaGVyLnVwZGF0ZShjaXBoZXJUZXh0KTtcbiAgY29uc3QgYiA9IGRlY2lwaGVyLmZpbmFsKCk7XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFthLCBiXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUl2KCk6IEJ1ZmZlciB7XG4gIHJldHVybiByYW5kb21CeXRlcyhJdlNpemUpO1xufVxuIiwiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCAqIGFzIGNyeXB0byBmcm9tICdjcnlwdG8nO1xuXG5pbXBvcnQgKiBhcyBlY2llcyBmcm9tICdlY2llcy1nZXRoJztcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gJ2pzLXNoYTMnO1xuaW1wb3J0ICogYXMgc2VjcDI1NmsxIGZyb20gJ3NlY3AyNTZrMSc7XG5cbmltcG9ydCB7IGhleFRvQnVmIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBJdlNpemUsIHN5bW1ldHJpYywgU3ltbWV0cmljS2V5U2l6ZSB9IGZyb20gJy4vc3ltbWV0cmljJztcblxuY29uc3QgRmxhZ3NMZW5ndGggPSAxO1xuY29uc3QgRmxhZ01hc2sgPSAzOyAvLyAwMDExXG5jb25zdCBJc1NpZ25lZE1hc2sgPSA0OyAvLyAwMTAwXG5jb25zdCBQYWRkaW5nVGFyZ2V0ID0gMjU2O1xuY29uc3QgU2lnbmF0dXJlTGVuZ3RoID0gNjU7XG5cbmV4cG9ydCBjb25zdCBQcml2YXRlS2V5U2l6ZSA9IDMyO1xuXG4vKipcbiAqIEVuY29kZSB0aGUgcGF5bG9hZCBwcmUtZW5jcnlwdGlvbi5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBtZXNzYWdlUGF5bG9hZDogVGhlIHBheWxvYWQgdG8gaW5jbHVkZSBpbiB0aGUgbWVzc2FnZVxuICogQHBhcmFtIHNpZ1ByaXZLZXk6IElmIHNldCwgYSBzaWduYXR1cmUgdXNpbmcgdGhpcyBwcml2YXRlIGtleSBpcyBhZGRlZC5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHBheWxvYWQsIHJlYWR5IGZvciBlbmNyeXB0aW9uIHVzaW5nIHtAbGluayBlbmNyeXB0QXN5bW1ldHJpY31cbiAqIG9yIHtAbGluayBlbmNyeXB0U3ltbWV0cmljfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyRW5jb2RlKFxuICBtZXNzYWdlUGF5bG9hZDogVWludDhBcnJheSxcbiAgc2lnUHJpdktleT86IFVpbnQ4QXJyYXlcbik6IHsgcGF5bG9hZDogVWludDhBcnJheTsgc2lnPzogU2lnbmF0dXJlIH0ge1xuICBsZXQgZW52ZWxvcGUgPSBCdWZmZXIuZnJvbShbMF0pOyAvLyBObyBmbGFnc1xuICBlbnZlbG9wZSA9IGFkZFBheWxvYWRTaXplRmllbGQoZW52ZWxvcGUsIG1lc3NhZ2VQYXlsb2FkKTtcbiAgZW52ZWxvcGUgPSBCdWZmZXIuY29uY2F0KFtlbnZlbG9wZSwgQnVmZmVyLmZyb20obWVzc2FnZVBheWxvYWQpXSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHBhZGRpbmc6XG4gIGxldCByYXdTaXplID1cbiAgICBGbGFnc0xlbmd0aCArXG4gICAgZ2V0U2l6ZU9mUGF5bG9hZFNpemVGaWVsZChtZXNzYWdlUGF5bG9hZCkgK1xuICAgIG1lc3NhZ2VQYXlsb2FkLmxlbmd0aDtcblxuICBpZiAoc2lnUHJpdktleSkge1xuICAgIHJhd1NpemUgKz0gU2lnbmF0dXJlTGVuZ3RoO1xuICB9XG5cbiAgY29uc3QgcmVtYWluZGVyID0gcmF3U2l6ZSAlIFBhZGRpbmdUYXJnZXQ7XG4gIGNvbnN0IHBhZGRpbmdTaXplID0gUGFkZGluZ1RhcmdldCAtIHJlbWFpbmRlcjtcbiAgY29uc3QgcGFkID0gQnVmZmVyLmZyb20ocmFuZG9tQnl0ZXMocGFkZGluZ1NpemUpKTtcblxuICBpZiAoIXZhbGlkYXRlRGF0YUludGVncml0eShwYWQsIHBhZGRpbmdTaXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdlbmVyYXRlIHJhbmRvbSBwYWRkaW5nIG9mIHNpemUgJyArIHBhZGRpbmdTaXplKTtcbiAgfVxuXG4gIGVudmVsb3BlID0gQnVmZmVyLmNvbmNhdChbZW52ZWxvcGUsIHBhZF0pO1xuXG4gIGxldCBzaWc7XG4gIGlmIChzaWdQcml2S2V5KSB7XG4gICAgZW52ZWxvcGVbMF0gfD0gSXNTaWduZWRNYXNrO1xuICAgIGNvbnN0IGhhc2ggPSBrZWNjYWsyNTYoZW52ZWxvcGUpO1xuICAgIGNvbnN0IHMgPSBzZWNwMjU2azEuZWNkc2FTaWduKGhleFRvQnVmKGhhc2gpLCBzaWdQcml2S2V5KTtcbiAgICBlbnZlbG9wZSA9IEJ1ZmZlci5jb25jYXQoW2VudmVsb3BlLCBzLnNpZ25hdHVyZSwgQnVmZmVyLmZyb20oW3MucmVjaWRdKV0pO1xuICAgIHNpZyA9IHtcbiAgICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20ocy5zaWduYXR1cmUpLFxuICAgICAgcHVibGljS2V5OiBnZXRQdWJsaWNLZXkoc2lnUHJpdktleSksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7IHBheWxvYWQ6IGVudmVsb3BlLCBzaWcgfTtcbn1cblxuZXhwb3J0IHR5cGUgU2lnbmF0dXJlID0ge1xuICBzaWduYXR1cmU6IFVpbnQ4QXJyYXk7XG4gIHB1YmxpY0tleTogVWludDhBcnJheTtcbn07XG5cbi8qKlxuICogRGVjb2RlIGEgZGVjcnlwdGVkIHBheWxvYWQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckRlY29kZShcbiAgbWVzc2FnZTogVWludDhBcnJheSB8IEJ1ZmZlclxuKTogeyBwYXlsb2FkOiBVaW50OEFycmF5OyBzaWc/OiBTaWduYXR1cmUgfSB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGJ1ZiA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICBsZXQgc3RhcnQgPSAxO1xuICBsZXQgc2lnO1xuXG4gIGNvbnN0IHNpemVPZlBheWxvYWRTaXplRmllbGQgPSBidWYucmVhZFVJbnRMRSgwLCAxKSAmIEZsYWdNYXNrO1xuXG4gIGlmIChzaXplT2ZQYXlsb2FkU2l6ZUZpZWxkID09PSAwKSByZXR1cm47XG5cbiAgY29uc3QgcGF5bG9hZFNpemUgPSBidWYucmVhZFVJbnRMRShzdGFydCwgc2l6ZU9mUGF5bG9hZFNpemVGaWVsZCk7XG4gIHN0YXJ0ICs9IHNpemVPZlBheWxvYWRTaXplRmllbGQ7XG4gIGNvbnN0IHBheWxvYWQgPSBidWYuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgcGF5bG9hZFNpemUpO1xuXG4gIGNvbnN0IGlzU2lnbmVkID0gKGJ1Zi5yZWFkVUludExFKDAsIDEpICYgSXNTaWduZWRNYXNrKSA9PSBJc1NpZ25lZE1hc2s7XG4gIGlmIChpc1NpZ25lZCkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IGdldFNpZ25hdHVyZShidWYpO1xuICAgIGNvbnN0IGhhc2ggPSBnZXRIYXNoKGJ1ZiwgaXNTaWduZWQpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGVjUmVjb3ZlclB1YktleShoYXNoLCBzaWduYXR1cmUpO1xuICAgIHNpZyA9IHsgc2lnbmF0dXJlLCBwdWJsaWNLZXkgfTtcbiAgfVxuXG4gIHJldHVybiB7IHBheWxvYWQsIHNpZyB9O1xufVxuXG4vKipcbiAqIFByb2NlZWQgd2l0aCBBc3ltbWV0cmljIGVuY3J5cHRpb24gb2YgdGhlIGRhdGEgYXMgcGVyIFsyNi9XQUtVLVBBWUxPQURdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8yNi8pLlxuICogVGhlIGRhdGEgTVVTVCBiZSBmbGFncyB8IHBheWxvYWQtbGVuZ3RoIHwgcGF5bG9hZCB8IFtzaWduYXR1cmVdLlxuICogVGhlIHJldHVybmVkIHJlc3VsdCBjYW4gYmUgc2V0IHRvIGBXYWt1TWVzc2FnZS5wYXlsb2FkYC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRBc3ltbWV0cmljKFxuICBkYXRhOiBVaW50OEFycmF5IHwgQnVmZmVyLFxuICBwdWJsaWNLZXk6IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBzdHJpbmdcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICByZXR1cm4gZWNpZXMuZW5jcnlwdChoZXhUb0J1ZihwdWJsaWNLZXkpLCBCdWZmZXIuZnJvbShkYXRhKSk7XG59XG5cbi8qKlxuICogUHJvY2VlZCB3aXRoIEFzeW1tZXRyaWMgZGVjcnlwdGlvbiBvZiB0aGUgZGF0YSBhcyBwZXIgWzI2L1dBS1UtUEFZTE9BRF0oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzI2LykuXG4gKiBUaGUgcmV0dXJuIGRhdGEgaXMgZXhwZWN0IHRvIGJlIGZsYWdzIHwgcGF5bG9hZC1sZW5ndGggfCBwYXlsb2FkIHwgW3NpZ25hdHVyZV0uXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0QXN5bW1ldHJpYyhcbiAgcGF5bG9hZDogVWludDhBcnJheSB8IEJ1ZmZlcixcbiAgcHJpdktleTogVWludDhBcnJheSB8IEJ1ZmZlclxuKTogUHJvbWlzZTxVaW50OEFycmF5PiB7XG4gIHJldHVybiBlY2llcy5kZWNyeXB0KEJ1ZmZlci5mcm9tKHByaXZLZXkpLCBCdWZmZXIuZnJvbShwYXlsb2FkKSk7XG59XG5cbi8qKlxuICogUHJvY2VlZCB3aXRoIFN5bW1ldHJpYyBlbmNyeXB0aW9uIG9mIHRoZSBkYXRhIGFzIHBlciBbMjYvV0FLVS1QQVlMT0FEXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMjYvKS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBlbmNyeXB0LCBleHBlY3RlZCB0byBiZSBgZmxhZ3MgfCBwYXlsb2FkLWxlbmd0aCB8IHBheWxvYWQgfCBbc2lnbmF0dXJlXWAuXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdXNlIGZvciBlbmNyeXB0aW9uLlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCBkYXRhLCBgY2lwaGVyVGV4dCB8IHRhZyB8IGl2YCBhbmQgY2FuIGJlIHNldCB0byBgV2FrdU1lc3NhZ2UucGF5bG9hZGAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlbmNyeXB0U3ltbWV0cmljKFxuICBkYXRhOiBVaW50OEFycmF5IHwgQnVmZmVyLFxuICBrZXk6IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBzdHJpbmdcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICBjb25zdCBpdiA9IHN5bW1ldHJpYy5nZW5lcmF0ZUl2KCk7XG5cbiAgLy8gUmV0dXJucyBgY2lwaGVyIHwgdGFnYFxuICBjb25zdCBjaXBoZXIgPSBhd2FpdCBzeW1tZXRyaWMuZW5jcnlwdChpdiwgaGV4VG9CdWYoa2V5KSwgQnVmZmVyLmZyb20oZGF0YSkpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbY2lwaGVyLCBCdWZmZXIuZnJvbShpdildKTtcbn1cblxuLyoqXG4gKiBQcm9jZWVkIHdpdGggU3ltbWV0cmljIGRlY3J5cHRpb24gb2YgdGhlIGRhdGEgYXMgcGVyIFsyNi9XQUtVLVBBWUxPQURdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8yNi8pLlxuICpcbiAqIEBwYXJhbSBwYXlsb2FkIFRoZSBjaXBoZXIgZGF0YSwgaXQgaXMgZXhwZWN0ZWQgdG8gYmUgYGNpcGhlclRleHQgfCB0YWcgfCBpdmAuXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdXNlIGZvciBkZWNyeXB0aW9uLlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCBkYXRhLCBleHBlY3RlZCB0byBiZSBgZmxhZ3MgfCBwYXlsb2FkLWxlbmd0aCB8IHBheWxvYWQgfCBbc2lnbmF0dXJlXWAuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWNyeXB0U3ltbWV0cmljKFxuICBwYXlsb2FkOiBVaW50OEFycmF5IHwgQnVmZmVyLFxuICBrZXk6IFVpbnQ4QXJyYXkgfCBCdWZmZXIgfCBzdHJpbmdcbik6IFByb21pc2U8VWludDhBcnJheT4ge1xuICBjb25zdCBkYXRhID0gQnVmZmVyLmZyb20ocGF5bG9hZCk7XG4gIGNvbnN0IGl2U3RhcnQgPSBkYXRhLmxlbmd0aCAtIEl2U2l6ZTtcbiAgY29uc3QgY2lwaGVyID0gZGF0YS5zbGljZSgwLCBpdlN0YXJ0KTtcbiAgY29uc3QgaXYgPSBkYXRhLnNsaWNlKGl2U3RhcnQpO1xuXG4gIHJldHVybiBzeW1tZXRyaWMuZGVjcnlwdChpdiwgaGV4VG9CdWYoa2V5KSwgY2lwaGVyKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG5ldyBwcml2YXRlIGtleSB0byBiZSB1c2VkIGZvciBhc3ltbWV0cmljIGVuY3J5cHRpb24uXG4gKlxuICogVXNlIHtAbGluayBnZXRQdWJsaWNLZXl9IHRvIGdldCB0aGUgY29ycmVzcG9uZGluZyBQdWJsaWMgS2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQcml2YXRlS2V5KCk6IFVpbnQ4QXJyYXkge1xuICByZXR1cm4gcmFuZG9tQnl0ZXMoUHJpdmF0ZUtleVNpemUpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgbmV3IHN5bW1ldHJpYyBrZXkgdG8gYmUgdXNlZCBmb3Igc3ltbWV0cmljIGVuY3J5cHRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVN5bW1ldHJpY0tleSgpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIHJhbmRvbUJ5dGVzKFN5bW1ldHJpY0tleVNpemUpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIHByaXZhdGUga2V5LCB0byBiZSB1c2VkIGZvciBhc3ltbWV0cmljXG4gKiBlbmNyeXB0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXk6IFVpbnQ4QXJyYXkgfCBCdWZmZXIpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBmbGFncyAmIGF1eGlsaWFyeS1maWVsZCBhcyBwZXIgWzI2L1dBS1UtUEFZTE9BRF0oaHR0cHM6Ly9yZmMudmFjLmRldi9zcGVjLzI2LykuXG4gKi9cbmZ1bmN0aW9uIGFkZFBheWxvYWRTaXplRmllbGQobXNnOiBCdWZmZXIsIHBheWxvYWQ6IFVpbnQ4QXJyYXkpOiBCdWZmZXIge1xuICBjb25zdCBmaWVsZFNpemUgPSBnZXRTaXplT2ZQYXlsb2FkU2l6ZUZpZWxkKHBheWxvYWQpO1xuICBsZXQgZmllbGQgPSBCdWZmZXIuYWxsb2MoNCk7XG4gIGZpZWxkLndyaXRlVUludDMyTEUocGF5bG9hZC5sZW5ndGgsIDApO1xuICBmaWVsZCA9IGZpZWxkLnNsaWNlKDAsIGZpZWxkU2l6ZSk7XG4gIG1zZyA9IEJ1ZmZlci5jb25jYXQoW21zZywgZmllbGRdKTtcbiAgbXNnWzBdIHw9IGZpZWxkU2l6ZTtcbiAgcmV0dXJuIG1zZztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBhdXhpbGlhcnktZmllbGQgd2hpY2ggaW4gdHVybnMgY29udGFpbnMgdGhlIHBheWxvYWQgc2l6ZVxuICovXG5mdW5jdGlvbiBnZXRTaXplT2ZQYXlsb2FkU2l6ZUZpZWxkKHBheWxvYWQ6IFVpbnQ4QXJyYXkpOiBudW1iZXIge1xuICBsZXQgcyA9IDE7XG4gIGZvciAobGV0IGkgPSBwYXlsb2FkLmxlbmd0aDsgaSA+PSAyNTY7IGkgLz0gMjU2KSB7XG4gICAgcysrO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURhdGFJbnRlZ3JpdHkoXG4gIHZhbHVlOiBVaW50OEFycmF5LFxuICBleHBlY3RlZFNpemU6IG51bWJlclxuKTogYm9vbGVhbiB7XG4gIGlmICh2YWx1ZS5sZW5ndGggIT09IGV4cGVjdGVkU2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhKFxuICAgIGV4cGVjdGVkU2l6ZSA+IDMgJiYgQnVmZmVyLmZyb20odmFsdWUpLmVxdWFscyhCdWZmZXIuYWxsb2ModmFsdWUubGVuZ3RoKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2lnbmF0dXJlKG1lc3NhZ2U6IEJ1ZmZlcik6IEJ1ZmZlciB7XG4gIHJldHVybiBtZXNzYWdlLnNsaWNlKG1lc3NhZ2UubGVuZ3RoIC0gU2lnbmF0dXJlTGVuZ3RoLCBtZXNzYWdlLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIGdldEhhc2gobWVzc2FnZTogQnVmZmVyLCBpc1NpZ25lZDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGlmIChpc1NpZ25lZCkge1xuICAgIHJldHVybiBrZWNjYWsyNTYobWVzc2FnZS5zbGljZSgwLCBtZXNzYWdlLmxlbmd0aCAtIFNpZ25hdHVyZUxlbmd0aCkpO1xuICB9XG4gIHJldHVybiBrZWNjYWsyNTYobWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIGVjUmVjb3ZlclB1YktleShtZXNzYWdlSGFzaDogc3RyaW5nLCBzaWduYXR1cmU6IEJ1ZmZlcik6IFVpbnQ4QXJyYXkge1xuICBjb25zdCByZWNvdmVyeSA9IHNpZ25hdHVyZS5zbGljZSg2NCkucmVhZEludEJFKDAsIDEpO1xuICByZXR1cm4gc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihcbiAgICBzaWduYXR1cmUuc2xpY2UoMCwgNjQpLFxuICAgIHJlY292ZXJ5LFxuICAgIGhleFRvQnVmKG1lc3NhZ2VIYXNoKSxcbiAgICBmYWxzZVxuICApO1xufVxuXG5mdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGg6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHdpbmRvdy5jcnlwdG8pIHtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYXJyYXkpO1xuICAgIHJldHVybiBhcnJheTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBzZWNvbmQgPSAxMDAwO1xuZXhwb3J0IGNvbnN0IG1pbnV0ZSA9IDYwICogc2Vjb25kO1xuXG4vKipcbiAqIFJlbGF5Q29kZWMgaXMgdGhlIGxpYnAycCBpZGVudGlmaWVyIGZvciB0aGUgd2FrdSByZWxheSBwcm90b2NvbFxuICovXG5leHBvcnQgY29uc3QgUmVsYXlDb2RlY3MgPSBbXG4gICcvdmFjL3dha3UvcmVsYXkvMi4wLjAtYmV0YTInLFxuICAnL3ZhYy93YWt1L3JlbGF5LzIuMC4wJyxcbl07XG5cbmV4cG9ydCBjb25zdCBSZWxheVBpbmdDb250ZW50VG9waWMgPSAnL3JlbGF5LXBpbmcvMS9waW5nL251bGwnO1xuXG4vKipcbiAqIFJlbGF5R29zc2lwRmFjdG9yIGFmZmVjdHMgaG93IG1hbnkgcGVlcnMgd2Ugd2lsbCBlbWl0IGdvc3NpcCB0byBhdCBlYWNoIGhlYXJ0YmVhdC5cbiAqIFdlIHdpbGwgc2VuZCBnb3NzaXAgdG8gUmVsYXlHb3NzaXBGYWN0b3IgKiAodG90YWwgbnVtYmVyIG9mIG5vbi1tZXNoIHBlZXJzKSwgb3JcbiAqIFJlbGF5RGxhenksIHdoaWNoZXZlciBpcyBncmVhdGVyLlxuICovXG5leHBvcnQgY29uc3QgUmVsYXlHb3NzaXBGYWN0b3IgPSAwLjI1O1xuXG4vKipcbiAqIEdvc3NpcHN1YkhlYXJ0YmVhdEluaXRpYWxEZWxheSBpcyB0aGUgc2hvcnQgZGVsYXkgYmVmb3JlIHRoZSBoZWFydGJlYXQgdGltZXIgYmVnaW5zXG4gKiBhZnRlciB0aGUgcm91dGVyIGlzIGluaXRpYWxpemVkLlxuICovXG5leHBvcnQgY29uc3QgUmVsYXlIZWFydGJlYXRJbml0aWFsRGVsYXkgPSAxMDA7XG5cbi8qKlxuICogUmVsYXlIZWFydGJlYXRJbnRlcnZhbCBjb250cm9scyB0aGUgdGltZSBiZXR3ZWVuIGhlYXJ0YmVhdHMuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheUhlYXJ0YmVhdEludGVydmFsID0gc2Vjb25kO1xuXG4vKipcbiAqIFJlbGF5UHJ1bmVQZWVycyBjb250cm9scyB0aGUgbnVtYmVyIG9mIHBlZXJzIHRvIGluY2x1ZGUgaW4gcHJ1bmUgUGVlciBlWGNoYW5nZS5cbiAqIFdoZW4gd2UgcHJ1bmUgYSBwZWVyIHRoYXQncyBlbGlnaWJsZSBmb3IgUFggKGhhcyBhIGdvb2Qgc2NvcmUsIGV0YyksIHdlIHdpbGwgdHJ5IHRvXG4gKiBzZW5kIHRoZW0gc2lnbmVkIHBlZXIgcmVjb3JkcyBmb3IgdXAgdG8gUmVsYXlQcnVuZVBlZXJzIG90aGVyIHBlZXJzIHRoYXQgd2VcbiAqIGtub3cgb2YuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheVBydW5lUGVlcnMgPSAxNjtcblxuLyoqXG4gKiBSZWxheVBydW5lQmFja29mZiBjb250cm9scyB0aGUgYmFja29mZiB0aW1lIGZvciBwcnVuZWQgcGVlcnMuIFRoaXMgaXMgaG93IGxvbmdcbiAqIGEgcGVlciBtdXN0IHdhaXQgYmVmb3JlIGF0dGVtcHRpbmcgdG8gZ3JhZnQgaW50byBvdXIgbWVzaCBhZ2FpbiBhZnRlciBiZWluZyBwcnVuZWQuXG4gKiBXaGVuIHBydW5pbmcgYSBwZWVyLCB3ZSBzZW5kIHRoZW0gb3VyIHZhbHVlIG9mIFJlbGF5UHJ1bmVCYWNrb2ZmIHNvIHRoZXkga25vd1xuICogdGhlIG1pbmltdW0gdGltZSB0byB3YWl0LiBQZWVycyBydW5uaW5nIG9sZGVyIHZlcnNpb25zIG1heSBub3Qgc2VuZCBhIGJhY2tvZmYgdGltZSxcbiAqIHNvIGlmIHdlIHJlY2VpdmUgYSBwcnVuZSBtZXNzYWdlIHdpdGhvdXQgb25lLCB3ZSB3aWxsIHdhaXQgYXQgbGVhc3QgUmVsYXlQcnVuZUJhY2tvZmZcbiAqIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHJlLWdyYWZ0LlxuICovXG5leHBvcnQgY29uc3QgUmVsYXlQcnVuZUJhY2tvZmYgPSBtaW51dGU7XG5cbi8qKlxuICogUmVsYXlGYW5vdXRUVEwgY29udHJvbHMgaG93IGxvbmcgd2Uga2VlcCB0cmFjayBvZiB0aGUgZmFub3V0IHN0YXRlLiBJZiBpdCdzIGJlZW5cbiAqIFJlbGF5RmFub3V0VFRMIHNpbmNlIHdlJ3ZlIHB1Ymxpc2hlZCB0byBhIHRvcGljIHRoYXQgd2UncmUgbm90IHN1YnNjcmliZWQgdG8sXG4gKiB3ZSdsbCBkZWxldGUgdGhlIGZhbm91dCBtYXAgZm9yIHRoYXQgdG9waWMuXG4gKi9cbmV4cG9ydCBjb25zdCBSZWxheUZhbm91dFRUTCA9IG1pbnV0ZTtcblxuLyoqXG4gKiBSZWxheU9wcG9ydHVuaXN0aWNHcmFmdFRpY2tzIGlzIHRoZSBudW1iZXIgb2YgaGVhcnRiZWF0IHRpY2tzIGZvciBhdHRlbXB0aW5nIHRvIGltcHJvdmUgdGhlIG1lc2hcbiAqIHdpdGggb3Bwb3J0dW5pc3RpYyBncmFmdGluZy4gRXZlcnkgUmVsYXlPcHBvcnR1bmlzdGljR3JhZnRUaWNrcyB3ZSB3aWxsIGF0dGVtcHQgdG8gc2VsZWN0IHNvbWVcbiAqIGhpZ2gtc2NvcmluZyBtZXNoIHBlZXJzIHRvIHJlcGxhY2UgbG93ZXItc2NvcmluZyBvbmVzLCBpZiB0aGUgbWVkaWFuIHNjb3JlIG9mIG91ciBtZXNoIHBlZXJzIGZhbGxzXG4gKiBiZWxvdyBhIHRocmVzaG9sZFxuICovXG5leHBvcnQgY29uc3QgUmVsYXlPcHBvcnR1bmlzdGljR3JhZnRUaWNrcyA9IDYwO1xuXG4vKipcbiAqIFJlbGF5T3Bwb3J0dW5pc3RpY0dyYWZ0UGVlcnMgaXMgdGhlIG51bWJlciBvZiBwZWVycyB0byBvcHBvcnR1bmlzdGljYWxseSBncmFmdC5cbiAqL1xuZXhwb3J0IGNvbnN0IFJlbGF5T3Bwb3J0dW5pc3RpY0dyYWZ0UGVlcnMgPSAyO1xuXG4vKipcbiAqIFJlbGF5TWF4SUhhdmVMZW5ndGggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIGluY2x1ZGUgaW4gYW4gSUhBVkUgbWVzc2FnZS5cbiAqIEFsc28gY29udHJvbHMgdGhlIG1heGltdW0gbnVtYmVyIG9mIElIQVZFIGlkcyB3ZSB3aWxsIGFjY2VwdCBhbmQgcmVxdWVzdCB3aXRoIElXQU5UIGZyb20gYVxuICogcGVlciB3aXRoaW4gYSBoZWFydGJlYXQsIHRvIHByb3RlY3QgZnJvbSBJSEFWRSBmbG9vZHMuIFlvdSBzaG91bGQgYWRqdXN0IHRoaXMgdmFsdWUgZnJvbSB0aGVcbiAqIGRlZmF1bHQgaWYgeW91ciBzeXN0ZW0gaXMgcHVzaGluZyBtb3JlIHRoYW4gNTAwMCBtZXNzYWdlcyBpbiBHb3NzaXBzdWJIaXN0b3J5R29zc2lwIGhlYXJ0YmVhdHM7XG4gKiB3aXRoIHRoZSBkZWZhdWx0cyB0aGlzIGlzIDE2NjYgbWVzc2FnZXMvcy5cbiAqL1xuZXhwb3J0IGNvbnN0IFJlbGF5TWF4SUhhdmVMZW5ndGggPSA1MDAwO1xuIiwiaW1wb3J0IEdvc3NpcHN1YiBmcm9tICdsaWJwMnAtZ29zc2lwc3ViJztcbmltcG9ydCB7IHNodWZmbGUgfSBmcm9tICdsaWJwMnAtZ29zc2lwc3ViL3NyYy91dGlscyc7XG5cbmltcG9ydCB7IFJlbGF5Q29kZWNzIH0gZnJvbSAnLi9pbmRleCc7XG5cbi8qKlxuICogR2l2ZW4gYSB0b3BpYywgcmV0dXJucyB1cCB0byBjb3VudCBwZWVycyBzdWJzY3JpYmVkIHRvIHRoYXQgdG9waWNcbiAqIHRoYXQgcGFzcyBhbiBvcHRpb25hbCBmaWx0ZXIgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0dvc3NpcHN1Yn0gcm91dGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9waWNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZpbHRlcl0gYSBmdW5jdGlvbiB0byBmaWx0ZXIgYWNjZXB0YWJsZSBwZWVyc1xuICogQHJldHVybnMge1NldDxzdHJpbmc+fVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlbGF5UGVlcnMoXG4gIHJvdXRlcjogR29zc2lwc3ViLFxuICB0b3BpYzogc3RyaW5nLFxuICBjb3VudDogbnVtYmVyLFxuICBmaWx0ZXI6IChpZDogc3RyaW5nKSA9PiBib29sZWFuID0gKCk6IGJvb2xlYW4gPT4gdHJ1ZVxuKTogU2V0PHN0cmluZz4ge1xuICBjb25zdCBwZWVyc0luVG9waWMgPSByb3V0ZXIudG9waWNzLmdldCh0b3BpYyk7XG4gIGlmICghcGVlcnNJblRvcGljKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoKTtcbiAgfVxuXG4gIC8vIEFkZHMgYWxsIHBlZXJzIHVzaW5nIG91ciBwcm90b2NvbFxuICAvLyB0aGF0IGFsc28gcGFzcyB0aGUgZmlsdGVyIGZ1bmN0aW9uXG4gIGxldCBwZWVyczogc3RyaW5nW10gPSBbXTtcbiAgcGVlcnNJblRvcGljLmZvckVhY2goKGlkOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBwZWVyU3RyZWFtcyA9IHJvdXRlci5wZWVycy5nZXQoaWQpO1xuICAgIGlmICghcGVlclN0cmVhbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFJlbGF5Q29kZWNzLmluY2x1ZGVzKHBlZXJTdHJlYW1zLnByb3RvY29sKSAmJiBmaWx0ZXIoaWQpKSB7XG4gICAgICBwZWVycy5wdXNoKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFBzZXVkby1yYW5kb21seSBzaHVmZmxlcyBwZWVyc1xuICBwZWVycyA9IHNodWZmbGUocGVlcnMpO1xuICBpZiAoY291bnQgPiAwICYmIHBlZXJzLmxlbmd0aCA+IGNvdW50KSB7XG4gICAgcGVlcnMgPSBwZWVycy5zbGljZSgwLCBjb3VudCk7XG4gIH1cblxuICByZXR1cm4gbmV3IFNldChwZWVycyk7XG59XG4iLCJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IExpYnAycCBmcm9tICdsaWJwMnAnO1xuaW1wb3J0IEdvc3NpcHN1YiBmcm9tICdsaWJwMnAtZ29zc2lwc3ViJztcbmltcG9ydCB7IEFkZHJJbmZvLCBNZXNzYWdlSWRGdW5jdGlvbiB9IGZyb20gJ2xpYnAycC1nb3NzaXBzdWIvc3JjL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTWVzc2FnZUNhY2hlIH0gZnJvbSAnbGlicDJwLWdvc3NpcHN1Yi9zcmMvbWVzc2FnZS1jYWNoZSc7XG5pbXBvcnQgeyBSUEMgfSBmcm9tICdsaWJwMnAtZ29zc2lwc3ViL3NyYy9tZXNzYWdlL3JwYyc7XG5pbXBvcnQge1xuICBQZWVyU2NvcmVQYXJhbXMsXG4gIFBlZXJTY29yZVRocmVzaG9sZHMsXG59IGZyb20gJ2xpYnAycC1nb3NzaXBzdWIvc3JjL3Njb3JlJztcbmltcG9ydCB7XG4gIGNyZWF0ZUdvc3NpcFJwYyxcbiAgbWVzc2FnZUlkVG9TdHJpbmcsXG4gIHNodWZmbGUsXG59IGZyb20gJ2xpYnAycC1nb3NzaXBzdWIvc3JjL3V0aWxzJztcbmltcG9ydCB7IEluTWVzc2FnZSB9IGZyb20gJ2xpYnAycC1pbnRlcmZhY2VzL3NyYy9wdWJzdWInO1xuaW1wb3J0IHsgU2lnbmF0dXJlUG9saWN5IH0gZnJvbSAnbGlicDJwLWludGVyZmFjZXMvc3JjL3B1YnN1Yi9zaWduYXR1cmUtcG9saWN5JztcbmltcG9ydCBQZWVySWQgZnJvbSAncGVlci1pZCc7XG5cbmltcG9ydCB7IGhleFRvQnVmIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQ3JlYXRlT3B0aW9ucywgRGVmYXVsdFB1YlN1YlRvcGljIH0gZnJvbSAnLi4vd2FrdSc7XG5pbXBvcnQgeyBEZWNyeXB0aW9uTWV0aG9kLCBXYWt1TWVzc2FnZSB9IGZyb20gJy4uL3dha3VfbWVzc2FnZSc7XG5cbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBSZWxheUNvZGVjcyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldFJlbGF5UGVlcnMgfSBmcm9tICcuL2dldF9yZWxheV9wZWVycyc7XG5pbXBvcnQgeyBSZWxheUhlYXJ0YmVhdCB9IGZyb20gJy4vcmVsYXlfaGVhcnRiZWF0JztcblxuY29uc3QgZGJnID0gZGVidWcoJ3dha3U6cmVsYXknKTtcblxuZXhwb3J0IHsgUmVsYXlDb2RlY3MgfTtcblxuLyoqXG4gKiBTZWUgY29uc3RydWN0b3IgbGlicDJwLWdvc3NpcHN1YiBbQVBJXShodHRwczovL2dpdGh1Yi5jb20vQ2hhaW5TYWZlL2pzLWxpYnAycC1nb3NzaXBzdWIjYXBpKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHb3NzaXBPcHRpb25zIHtcbiAgZW1pdFNlbGY6IGJvb2xlYW47XG4gIGdvc3NpcEluY29taW5nOiBib29sZWFuO1xuICBmYWxsYmFja1RvRmxvb2RzdWI6IGJvb2xlYW47XG4gIGZsb29kUHVibGlzaDogYm9vbGVhbjtcbiAgZG9QWDogYm9vbGVhbjtcbiAgbXNnSWRGbjogTWVzc2FnZUlkRnVuY3Rpb247XG4gIG1lc3NhZ2VDYWNoZTogTWVzc2FnZUNhY2hlO1xuICAvLyBUaGlzIG9wdGlvbiBpcyBhbHdheXMgb3ZlcnJpZGRlblxuICAvLyBnbG9iYWxTaWduYXR1cmVQb2xpY3k6IHN0cmluZztcbiAgc2NvcmVQYXJhbXM6IFBhcnRpYWw8UGVlclNjb3JlUGFyYW1zPjtcbiAgc2NvcmVUaHJlc2hvbGRzOiBQYXJ0aWFsPFBlZXJTY29yZVRocmVzaG9sZHM+O1xuICBkaXJlY3RQZWVyczogQWRkckluZm9bXTtcbiAgRDogbnVtYmVyO1xuICBEbG86IG51bWJlcjtcbiAgRGhpOiBudW1iZXI7XG4gIERzY29yZTogbnVtYmVyO1xuICBEb3V0OiBudW1iZXI7XG4gIERsYXp5OiBudW1iZXI7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgW1dha3UgdjIgUmVsYXkgcHJvdG9jb2xde0BsaW5rIGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8xMS99LlxuICogTXVzdCBiZSBwYXNzZWQgYXMgYSBgcHVic3ViYCBtb2R1bGUgdG8gYSB7TGlicDJwfSBpbnN0YW5jZS5cbiAqXG4gKiBAaW1wbGVtZW50cyB7cmVxdWlyZSgnbGlicDJwLWludGVyZmFjZXMvc3JjL3B1YnN1YicpfVxuICogQG5vSW5oZXJpdERvY1xuICovXG5leHBvcnQgY2xhc3MgV2FrdVJlbGF5IGV4dGVuZHMgR29zc2lwc3ViIHtcbiAgaGVhcnRiZWF0OiBSZWxheUhlYXJ0YmVhdDtcbiAgcHViU3ViVG9waWM6IHN0cmluZztcblxuICBwdWJsaWMgZGVjcnlwdGlvbktleXM6IE1hcDxcbiAgICBVaW50OEFycmF5LFxuICAgIHsgbWV0aG9kPzogRGVjcnlwdGlvbk1ldGhvZDsgY29udGVudFRvcGljcz86IHN0cmluZ1tdIH1cbiAgPjtcblxuICAvKipcbiAgICogb2JzZXJ2ZXJzIGNhbGxlZCB3aGVuIHJlY2VpdmluZyBuZXcgbWVzc2FnZS5cbiAgICogT2JzZXJ2ZXJzIHVuZGVyIGtleSBgXCJcImAgYXJlIGFsd2F5cyBjYWxsZWQuXG4gICAqL1xuICBwdWJsaWMgb2JzZXJ2ZXJzOiB7XG4gICAgW2NvbnRlbnRUb3BpYzogc3RyaW5nXTogU2V0PChtZXNzYWdlOiBXYWt1TWVzc2FnZSkgPT4gdm9pZD47XG4gIH07XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbGlicDJwOiBMaWJwMnAsXG4gICAgb3B0aW9ucz86IFBhcnRpYWw8Q3JlYXRlT3B0aW9ucyAmIEdvc3NpcE9wdGlvbnM+XG4gICkge1xuICAgIHN1cGVyKFxuICAgICAgbGlicDJwLFxuICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IG5vIHNpZ25hdHVyZSBpcyBpbmNsdWRlZCBub3IgZXhwZWN0ZWQgaW4gdGhlIG1lc3NhZ2VzLlxuICAgICAgICBnbG9iYWxTaWduYXR1cmVQb2xpY3k6IFNpZ25hdHVyZVBvbGljeS5TdHJpY3ROb1NpZ24sXG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLmhlYXJ0YmVhdCA9IG5ldyBSZWxheUhlYXJ0YmVhdCh0aGlzKTtcbiAgICB0aGlzLm9ic2VydmVycyA9IHt9O1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMgPSBuZXcgTWFwKCk7XG5cbiAgICBjb25zdCBtdWx0aWNvZGVjcyA9IGNvbnN0YW50cy5SZWxheUNvZGVjcztcblxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyBtdWx0aWNvZGVjcyB9KTtcblxuICAgIHRoaXMucHViU3ViVG9waWMgPSBvcHRpb25zPy5wdWJTdWJUb3BpYyB8fCBEZWZhdWx0UHViU3ViVG9waWM7XG5cbiAgICBvcHRpb25zPy5kZWNyeXB0aW9uS2V5cz8uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLmFkZERlY3J5cHRpb25LZXkoa2V5KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VudHMgdGhlIGdvc3NpcHN1YiBwcm90b2NvbCBvbnRvIHRoZSBsaWJwMnAgbm9kZVxuICAgKiBhbmQgc3Vic2NyaWJlcyB0byB0aGUgZGVmYXVsdCB0b3BpYy5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcHVibGljIHN0YXJ0KCk6IHZvaWQge1xuICAgIHN1cGVyLnN0YXJ0KCk7XG4gICAgdGhpcy5zdWJzY3JpYmUodGhpcy5wdWJTdWJUb3BpYyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBXYWt1IG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7V2FrdU1lc3NhZ2V9IG1lc3NhZ2VcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2VuZChtZXNzYWdlOiBXYWt1TWVzc2FnZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1zZyA9IG1lc3NhZ2UuZW5jb2RlKCk7XG4gICAgYXdhaXQgc3VwZXIucHVibGlzaCh0aGlzLnB1YlN1YlRvcGljLCBCdWZmZXIuZnJvbShtc2cpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGRlY3J5cHRpb24ga2V5IHRvIGF0dGVtcHQgZGVjcnlwdGlvbiBvZiByZWNlaXZlZCBtZXNzYWdlcy5cbiAgICogVGhpcyBjYW4gZWl0aGVyIGJlIGEgcHJpdmF0ZSBrZXkgZm9yIGFzeW1tZXRyaWMgZW5jcnlwdGlvbiBvciBhIHN5bW1ldHJpY1xuICAgKiBrZXkuIGBXYWt1UmVsYXlgIHdpbGwgYXR0ZW1wdCB0byBkZWNyeXB0IG1lc3NhZ2VzIHVzaW5nIGJvdGggbWV0aG9kcy5cbiAgICpcbiAgICogU3RyaW5ncyBtdXN0IGJlIGluIGhleCBmb3JtYXQuXG4gICAqL1xuICBhZGREZWNyeXB0aW9uS2V5KFxuICAgIGtleTogVWludDhBcnJheSB8IHN0cmluZyxcbiAgICBvcHRpb25zPzogeyBtZXRob2Q/OiBEZWNyeXB0aW9uTWV0aG9kOyBjb250ZW50VG9waWNzPzogc3RyaW5nW10gfVxuICApOiB2b2lkIHtcbiAgICB0aGlzLmRlY3J5cHRpb25LZXlzLnNldChoZXhUb0J1ZihrZXkpLCBvcHRpb25zID8/IHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgYSBkZWNyeXB0aW9uIGtleSB0aGF0IHdhcyB1c2VkIHRvIGF0dGVtcHQgZGVjcnlwdGlvbiBvZiByZWNlaXZlZFxuICAgKiBtZXNzYWdlcy5cbiAgICpcbiAgICogU3RyaW5ncyBtdXN0IGJlIGluIGhleCBmb3JtYXQuXG4gICAqL1xuICBkZWxldGVEZWNyeXB0aW9uS2V5KGtleTogVWludDhBcnJheSB8IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMuZGVsZXRlKGhleFRvQnVmKGtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIG9ic2VydmVyIG9mIG5ldyBtZXNzYWdlcyByZWNlaXZlZCB2aWEgd2FrdSByZWxheVxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBuZXcgbWVzc2FnZSBpcyByZWNlaXZlZCB2aWEgd2FrdSByZWxheVxuICAgKiBAcGFyYW0gY29udGVudFRvcGljcyBDb250ZW50IFRvcGljcyBmb3Igd2hpY2ggdGhlIGNhbGxiYWNrIHdpdGggYmUgY2FsbGVkLFxuICAgKiBhbGwgb2YgdGhlbSBpZiB1bmRlZmluZWQsIFtdIG9yIFtcIlwiLC4uXSBpcyBwYXNzZWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYWRkT2JzZXJ2ZXIoXG4gICAgY2FsbGJhY2s6IChtZXNzYWdlOiBXYWt1TWVzc2FnZSkgPT4gdm9pZCxcbiAgICBjb250ZW50VG9waWNzOiBzdHJpbmdbXSA9IFtdXG4gICk6IHZvaWQge1xuICAgIGlmIChjb250ZW50VG9waWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLm9ic2VydmVyc1snJ10pIHtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNbJyddID0gbmV3IFNldCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vYnNlcnZlcnNbJyddLmFkZChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRUb3BpY3MuZm9yRWFjaCgoY29udGVudFRvcGljKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vYnNlcnZlcnNbY29udGVudFRvcGljXSkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzW2NvbnRlbnRUb3BpY10gPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnNbY29udGVudFRvcGljXS5hZGQoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBvYnNlcnZlciBvZiBuZXcgbWVzc2FnZXMgcmVjZWl2ZWQgdmlhIHdha3UgcmVsYXkuXG4gICAqIFVzZWZ1bCB0byBlbnN1cmUgdGhlIHNhbWUgb2JzZXJ2ZXIgaXMgbm90IHJlZ2lzdGVyZWQgc2V2ZXJhbCB0aW1lXG4gICAqIChlLmcgd2hlbiBsb2FkaW5nIFJlYWN0IGNvbXBvbmVudHMpXG4gICAqL1xuICBkZWxldGVPYnNlcnZlcihcbiAgICBjYWxsYmFjazogKG1lc3NhZ2U6IFdha3VNZXNzYWdlKSA9PiB2b2lkLFxuICAgIGNvbnRlbnRUb3BpY3M6IHN0cmluZ1tdID0gW11cbiAgKTogdm9pZCB7XG4gICAgaWYgKGNvbnRlbnRUb3BpY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5vYnNlcnZlcnNbJyddKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzWycnXS5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50VG9waWNzLmZvckVhY2goKGNvbnRlbnRUb3BpYykgPT4ge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnNbY29udGVudFRvcGljXSkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzW2NvbnRlbnRUb3BpY10uZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgcmVsYXkgcGVlcnMgd2UgYXJlIGNvbm5lY3RlZCB0byBhbmQgd2Ugd291bGQgcHVibGlzaCBhIG1lc3NhZ2UgdG9cbiAgICovXG4gIGdldFBlZXJzKCk6IFNldDxzdHJpbmc+IHtcbiAgICByZXR1cm4gZ2V0UmVsYXlQZWVycyh0aGlzLCB0aGlzLnB1YlN1YlRvcGljLCB0aGlzLl9vcHRpb25zLkQsIChpZCkgPT4ge1xuICAgICAgLy8gRmlsdGVyIHBlZXJzIHdlIHdvdWxkIG5vdCBwdWJsaXNoIHRvXG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnNjb3JlLnNjb3JlKGlkKSA+PSB0aGlzLl9vcHRpb25zLnNjb3JlVGhyZXNob2xkcy5wdWJsaXNoVGhyZXNob2xkXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhIHB1YnN1YiB0b3BpYyBhbmQgc3RhcnQgZW1pdHRpbmcgV2FrdSBtZXNzYWdlcyB0byBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgc3Vic2NyaWJlKHB1YlN1YlRvcGljOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLm9uKHB1YlN1YlRvcGljLCAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGRlY3J5cHRpb25LZXlzID0gQXJyYXkuZnJvbSh0aGlzLmRlY3J5cHRpb25LZXlzKS5tYXAoXG4gICAgICAgIChba2V5LCB7IG1ldGhvZCwgY29udGVudFRvcGljcyB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBjb250ZW50VG9waWNzLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIGRiZyhgTWVzc2FnZSByZWNlaXZlZCBvbiAke3B1YlN1YlRvcGljfWApO1xuICAgICAgV2FrdU1lc3NhZ2UuZGVjb2RlKGV2ZW50LmRhdGEsIGRlY3J5cHRpb25LZXlzKVxuICAgICAgICAudGhlbigod2FrdU1zZykgPT4ge1xuICAgICAgICAgIGlmICghd2FrdU1zZykge1xuICAgICAgICAgICAgZGJnKCdGYWlsZWQgdG8gZGVjb2RlIFdha3UgTWVzc2FnZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVyc1snJ10pIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzWycnXS5mb3JFYWNoKChjYWxsYmFja0ZuKSA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrRm4od2FrdU1zZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdha3VNc2cuY29udGVudFRvcGljKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnNbd2FrdU1zZy5jb250ZW50VG9waWNdKSB7XG4gICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzW3dha3VNc2cuY29udGVudFRvcGljXS5mb3JFYWNoKChjYWxsYmFja0ZuKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tGbih3YWt1TXNnKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBkYmcoJ0ZhaWxlZCB0byBkZWNvZGUgV2FrdSBNZXNzYWdlJywgZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc3VwZXIuc3Vic2NyaWJlKHB1YlN1YlRvcGljKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBKb2luIHB1YnN1YiB0b3BpYy5cbiAgICogVGhpcyBpcyBwcmVzZW50IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvciBvZiBHb3NzaXBzdWIgYW5kIHNob3VsZCBub3RcbiAgICogYmUgdXNlZCBieSBBUEkgQ29uc3VtZXJzXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgam9pbih0b3BpYzogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2FrdVJlbGF5UHViU3ViIGhhcyBub3Qgc3RhcnRlZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGZhbm91dFBlZXJzID0gdGhpcy5mYW5vdXQuZ2V0KHRvcGljKTtcbiAgICBpZiAoZmFub3V0UGVlcnMpIHtcbiAgICAgIC8vIHRoZXNlIHBlZXJzIGhhdmUgYSBzY29yZSBhYm92ZSB0aGUgcHVibGlzaCB0aHJlc2hvbGQsIHdoaWNoIG1heSBiZSBuZWdhdGl2ZVxuICAgICAgLy8gc28gZHJvcCB0aGUgb25lcyB3aXRoIGEgbmVnYXRpdmUgc2NvcmVcbiAgICAgIGZhbm91dFBlZXJzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNjb3JlLnNjb3JlKGlkKSA8IDApIHtcbiAgICAgICAgICBmYW5vdXRQZWVycy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChmYW5vdXRQZWVycy5zaXplIDwgdGhpcy5fb3B0aW9ucy5EKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgbW9yZSBwZWVyczsgZWFnZXIsIGFzIHRoaXMgd291bGQgZ2V0IGZpeGVkIGluIHRoZSBuZXh0IGhlYXJ0YmVhdFxuICAgICAgICBnZXRSZWxheVBlZXJzKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdG9waWMsXG4gICAgICAgICAgdGhpcy5fb3B0aW9ucy5EIC0gZmFub3V0UGVlcnMuc2l6ZSxcbiAgICAgICAgICAoaWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91ciBjdXJyZW50IHBlZXJzLCBkaXJlY3QgcGVlcnMsIGFuZCBwZWVycyB3aXRoIG5lZ2F0aXZlIHNjb3Jlc1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgIWZhbm91dFBlZXJzLmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgIXRoaXMuZGlyZWN0LmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgdGhpcy5zY29yZS5zY29yZShpZCkgPj0gMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICkuZm9yRWFjaCgoaWQpID0+IGZhbm91dFBlZXJzLmFkZChpZCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXNoLnNldCh0b3BpYywgZmFub3V0UGVlcnMpO1xuICAgICAgdGhpcy5mYW5vdXQuZGVsZXRlKHRvcGljKTtcbiAgICAgIHRoaXMubGFzdHB1Yi5kZWxldGUodG9waWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwZWVycyA9IGdldFJlbGF5UGVlcnMoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRvcGljLFxuICAgICAgICB0aGlzLl9vcHRpb25zLkQsXG4gICAgICAgIChpZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgLy8gZmlsdGVyIGRpcmVjdCBwZWVycyBhbmQgcGVlcnMgd2l0aCBuZWdhdGl2ZSBzY29yZVxuICAgICAgICAgIHJldHVybiAhdGhpcy5kaXJlY3QuaGFzKGlkKSAmJiB0aGlzLnNjb3JlLnNjb3JlKGlkKSA+PSAwO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGhpcy5tZXNoLnNldCh0b3BpYywgcGVlcnMpO1xuICAgIH1cbiAgICB0aGlzLm1lc2guZ2V0KHRvcGljKT8uZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIHRoaXMubG9nKCdKT0lOOiBBZGQgbWVzaCBsaW5rIHRvICVzIGluICVzJywgaWQsIHRvcGljKTtcbiAgICAgIHRoaXMuX3NlbmRHcmFmdChpZCwgdG9waWMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggbWVzc2FnZXMuXG4gICAqIFRoaXMgaXMgcHJlc2VudCB0byBvdmVycmlkZSB0aGUgYmVoYXZpb3Igb2YgR29zc2lwc3ViIGFuZCBzaG91bGQgbm90XG4gICAqIGJlIHVzZWQgYnkgQVBJIENvbnN1bWVyc1xuICAgKlxuICAgKiBAaWdub3JlXG4gICAqIEBvdmVycmlkZVxuICAgKiBAcGFyYW0ge0luTWVzc2FnZX0gbXNnXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgYXN5bmMgX3B1Ymxpc2gobXNnOiBJbk1lc3NhZ2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAobXNnLnJlY2VpdmVkRnJvbSAhPT0gdGhpcy5wZWVySWQudG9CNThTdHJpbmcoKSkge1xuICAgICAgdGhpcy5zY29yZS5kZWxpdmVyTWVzc2FnZShtc2cpO1xuICAgICAgdGhpcy5nb3NzaXBUcmFjZXIuZGVsaXZlck1lc3NhZ2UobXNnKTtcbiAgICB9XG5cbiAgICBjb25zdCBtc2dJRCA9IGF3YWl0IHRoaXMuZ2V0TXNnSWQobXNnKTtcbiAgICBjb25zdCBtc2dJZFN0ciA9IG1lc3NhZ2VJZFRvU3RyaW5nKG1zZ0lEKTtcbiAgICAvLyBwdXQgaW4gc2VlbiBjYWNoZVxuICAgIHRoaXMuc2VlbkNhY2hlLnB1dChtc2dJZFN0cik7XG5cbiAgICB0aGlzLm1lc3NhZ2VDYWNoZS5wdXQobXNnKTtcblxuICAgIGNvbnN0IHRvU2VuZCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIG1zZy50b3BpY0lEcy5mb3JFYWNoKCh0b3BpYykgPT4ge1xuICAgICAgY29uc3QgcGVlcnNJblRvcGljID0gdGhpcy50b3BpY3MuZ2V0KHRvcGljKTtcbiAgICAgIGlmICghcGVlcnNJblRvcGljKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0IHBlZXJzXG4gICAgICB0aGlzLmRpcmVjdC5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICB0b1NlbmQuYWRkKGlkKTtcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgbWVzaFBlZXJzID0gdGhpcy5tZXNoLmdldCh0b3BpYyk7XG4gICAgICBpZiAoIW1lc2hQZWVycyB8fCAhbWVzaFBlZXJzLnNpemUpIHtcbiAgICAgICAgLy8gV2UgYXJlIG5vdCBpbiB0aGUgbWVzaCBmb3IgdG9waWMsIHVzZSBmYW5vdXQgcGVlcnNcbiAgICAgICAgbWVzaFBlZXJzID0gdGhpcy5mYW5vdXQuZ2V0KHRvcGljKTtcbiAgICAgICAgaWYgKCFtZXNoUGVlcnMpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgbm90IGluIHRoZSBmYW5vdXQsIHRoZW4gcGljayBwZWVycyBpbiB0b3BpYyBhYm92ZSB0aGUgcHVibGlzaFRocmVzaG9sZFxuICAgICAgICAgIGNvbnN0IHBlZXJzID0gZ2V0UmVsYXlQZWVycyh0aGlzLCB0b3BpYywgdGhpcy5fb3B0aW9ucy5ELCAoaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIHRoaXMuc2NvcmUuc2NvcmUoaWQpID49XG4gICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc2NvcmVUaHJlc2hvbGRzLnB1Ymxpc2hUaHJlc2hvbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAocGVlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIG1lc2hQZWVycyA9IHBlZXJzO1xuICAgICAgICAgICAgdGhpcy5mYW5vdXQuc2V0KHRvcGljLCBwZWVycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1lc2hQZWVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIGxhdGVzdCBwdWJsaXNoaW5nIHRpbWVcbiAgICAgICAgdGhpcy5sYXN0cHViLnNldCh0b3BpYywgdGhpcy5fbm93KCkpO1xuICAgICAgfVxuXG4gICAgICBtZXNoUGVlcnM/LmZvckVhY2goKHBlZXIpID0+IHtcbiAgICAgICAgdG9TZW5kLmFkZChwZWVyKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFB1Ymxpc2ggbWVzc2FnZXMgdG8gcGVlcnNcbiAgICBjb25zdCBycGMgPSBjcmVhdGVHb3NzaXBScGMoW0dvc3NpcHN1Yi51dGlscy5ub3JtYWxpemVPdXRScGNNZXNzYWdlKG1zZyldKTtcbiAgICB0b1NlbmQuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIGlmIChpZCA9PT0gbXNnLmZyb20pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VuZFJwYyhpZCwgcnBjKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0cyBnb3NzaXAgdG8gcGVlcnMgaW4gYSBwYXJ0aWN1bGFyIHRvcGljLlxuICAgKlxuICAgKiBUaGlzIGlzIHByZXNlbnQgdG8gb3ZlcnJpZGUgdGhlIGJlaGF2aW9yIG9mIEdvc3NpcHN1YiBhbmQgc2hvdWxkIG5vdFxuICAgKiBiZSB1c2VkIGJ5IEFQSSBDb25zdW1lcnNcbiAgICpcbiAgICogQGlnbm9yZVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gICAqIEBwYXJhbSB7U2V0PHN0cmluZz59IGV4Y2x1ZGUgcGVlcnMgdG8gZXhjbHVkZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9lbWl0R29zc2lwKHRvcGljOiBzdHJpbmcsIGV4Y2x1ZGU6IFNldDxzdHJpbmc+KTogdm9pZCB7XG4gICAgY29uc3QgbWVzc2FnZUlEcyA9IHRoaXMubWVzc2FnZUNhY2hlLmdldEdvc3NpcElEcyh0b3BpYyk7XG4gICAgaWYgKCFtZXNzYWdlSURzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNodWZmbGUgdG8gZW1pdCBpbiByYW5kb20gb3JkZXJcbiAgICBzaHVmZmxlKG1lc3NhZ2VJRHMpO1xuXG4gICAgLy8gaWYgd2UgYXJlIGVtaXR0aW5nIG1vcmUgdGhhbiBHb3NzaXBzdWJNYXhJSGF2ZUxlbmd0aCBpZHMsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKG1lc3NhZ2VJRHMubGVuZ3RoID4gY29uc3RhbnRzLlJlbGF5TWF4SUhhdmVMZW5ndGgpIHtcbiAgICAgIC8vIHdlIGRvIHRoZSB0cnVuY2F0aW9uICh3aXRoIHNodWZmbGluZykgcGVyIHBlZXIgYmVsb3dcbiAgICAgIHRoaXMubG9nKFxuICAgICAgICAndG9vIG1hbnkgbWVzc2FnZXMgZm9yIGdvc3NpcDsgd2lsbCB0cnVuY2F0ZSBJSEFWRSBsaXN0ICglZCBtZXNzYWdlcyknLFxuICAgICAgICBtZXNzYWdlSURzLmxlbmd0aFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBTZW5kIGdvc3NpcCB0byBHb3NzaXBGYWN0b3IgcGVlcnMgYWJvdmUgdGhyZXNob2xkIHdpdGggYSBtaW5pbXVtIG9mIERfbGF6eVxuICAgIC8vIEZpcnN0IHdlIGNvbGxlY3QgdGhlIHBlZXJzIGFib3ZlIGdvc3NpcFRocmVzaG9sZCB0aGF0IGFyZSBub3QgaW4gdGhlIGV4Y2x1ZGUgc2V0XG4gICAgLy8gYW5kIHRoZW4gcmFuZG9tbHkgc2VsZWN0IGZyb20gdGhhdCBzZXRcbiAgICAvLyBXZSBhbHNvIGV4Y2x1ZGUgZGlyZWN0IHBlZXJzLCBhcyB0aGVyZSBpcyBubyByZWFzb24gdG8gZW1pdCBnb3NzaXAgdG8gdGhlbVxuICAgIGNvbnN0IHBlZXJzVG9Hb3NzaXA6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgdG9waWNQZWVycyA9IHRoaXMudG9waWNzLmdldCh0b3BpYyk7XG4gICAgaWYgKCF0b3BpY1BlZXJzKSB7XG4gICAgICAvLyBubyB0b3BpYyBwZWVycywgbm8gZ29zc2lwXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRvcGljUGVlcnMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIGNvbnN0IHBlZXJTdHJlYW1zID0gdGhpcy5wZWVycy5nZXQoaWQpO1xuICAgICAgaWYgKCFwZWVyU3RyZWFtcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgICFleGNsdWRlLmhhcyhpZCkgJiZcbiAgICAgICAgIXRoaXMuZGlyZWN0LmhhcyhpZCkgJiZcbiAgICAgICAgY29uc3RhbnRzLlJlbGF5Q29kZWNzLmluY2x1ZGVzKHBlZXJTdHJlYW1zLnByb3RvY29sKSAmJlxuICAgICAgICB0aGlzLnNjb3JlLnNjb3JlKGlkKSA+PSB0aGlzLl9vcHRpb25zLnNjb3JlVGhyZXNob2xkcy5nb3NzaXBUaHJlc2hvbGRcbiAgICAgICkge1xuICAgICAgICBwZWVyc1RvR29zc2lwLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGV0IHRhcmdldCA9IHRoaXMuX29wdGlvbnMuRGxhenk7XG4gICAgY29uc3QgZmFjdG9yID0gY29uc3RhbnRzLlJlbGF5R29zc2lwRmFjdG9yICogcGVlcnNUb0dvc3NpcC5sZW5ndGg7XG4gICAgaWYgKGZhY3RvciA+IHRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gZmFjdG9yO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID4gcGVlcnNUb0dvc3NpcC5sZW5ndGgpIHtcbiAgICAgIHRhcmdldCA9IHBlZXJzVG9Hb3NzaXAubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaHVmZmxlKHBlZXJzVG9Hb3NzaXApO1xuICAgIH1cbiAgICAvLyBFbWl0IHRoZSBJSEFWRSBnb3NzaXAgdG8gdGhlIHNlbGVjdGVkIHBlZXJzIHVwIHRvIHRoZSB0YXJnZXRcbiAgICBwZWVyc1RvR29zc2lwLnNsaWNlKDAsIHRhcmdldCkuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgIGxldCBwZWVyTWVzc2FnZUlEcyA9IG1lc3NhZ2VJRHM7XG4gICAgICBpZiAobWVzc2FnZUlEcy5sZW5ndGggPiBjb25zdGFudHMuUmVsYXlNYXhJSGF2ZUxlbmd0aCkge1xuICAgICAgICAvLyBzaHVmZmxlIGFuZCBzbGljZSBtZXNzYWdlIElEcyBwZXIgcGVlciBzbyB0aGF0IHdlIGVtaXQgYSBkaWZmZXJlbnQgc2V0IGZvciBlYWNoIHBlZXJcbiAgICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggcmVkdW5kYW5jeSBpbiB0aGUgc3lzdGVtIHRoYXQgdGhpcyB3aWxsIHNpZ25pZmljYW50bHkgaW5jcmVhc2UgdGhlIG1lc3NhZ2VcbiAgICAgICAgLy8gY292ZXJhZ2Ugd2hlbiB3ZSBkbyB0cnVuY2F0ZVxuICAgICAgICBwZWVyTWVzc2FnZUlEcyA9IHNodWZmbGUocGVlck1lc3NhZ2VJRHMuc2xpY2UoKSkuc2xpY2UoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBjb25zdGFudHMuUmVsYXlNYXhJSGF2ZUxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fcHVzaEdvc3NpcChpZCwge1xuICAgICAgICB0b3BpY0lEOiB0b3BpYyxcbiAgICAgICAgbWVzc2FnZUlEczogcGVlck1lc3NhZ2VJRHMsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgUFJVTkUgY29udHJvbCBtZXNzYWdlIGZvciBhIHBlZXIgaW4gYSB0b3BpYy5cbiAgICogVGhpcyBpcyBwcmVzZW50IHRvIG92ZXJyaWRlIHRoZSBiZWhhdmlvciBvZiBHb3NzaXBzdWIgYW5kIHNob3VsZCBub3RcbiAgICogYmUgdXNlZCBieSBBUEkgQ29uc3VtZXJzXG4gICAqXG4gICAqIEBpZ25vcmVcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9waWNcbiAgICogQHBhcmFtIHtib29sZWFufSBkb1BYXG4gICAqIEByZXR1cm5zIHtSUEMuSUNvbnRyb2xQcnVuZX1cbiAgICovXG4gIF9tYWtlUHJ1bmUoaWQ6IHN0cmluZywgdG9waWM6IHN0cmluZywgZG9QWDogYm9vbGVhbik6IFJQQy5JQ29udHJvbFBydW5lIHtcbiAgICAvLyBiYWNrb2ZmIGlzIG1lYXN1cmVkIGluIHNlY29uZHNcbiAgICAvLyBSZWxheVBydW5lQmFja29mZiBpcyBtZWFzdXJlZCBpbiBtaWxsaXNlY29uZHNcbiAgICBjb25zdCBiYWNrb2ZmID0gY29uc3RhbnRzLlJlbGF5UHJ1bmVCYWNrb2ZmIC8gMTAwMDtcbiAgICBjb25zdCBweDogUlBDLklQZWVySW5mb1tdID0gW107XG4gICAgaWYgKGRvUFgpIHtcbiAgICAgIC8vIHNlbGVjdCBwZWVycyBmb3IgUGVlciBlWGNoYW5nZVxuICAgICAgY29uc3QgcGVlcnMgPSBnZXRSZWxheVBlZXJzKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0b3BpYyxcbiAgICAgICAgY29uc3RhbnRzLlJlbGF5UHJ1bmVQZWVycyxcbiAgICAgICAgKHhpZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgcmV0dXJuIHhpZCAhPT0gaWQgJiYgdGhpcy5zY29yZS5zY29yZSh4aWQpID49IDA7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBwZWVycy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgIC8vIHNlZSBpZiB3ZSBoYXZlIGEgc2lnbmVkIHJlY29yZCB0byBzZW5kIGJhY2s7IGlmIHdlIGRvbid0LCBqdXN0IHNlbmRcbiAgICAgICAgLy8gdGhlIHBlZXIgSUQgYW5kIGxldCB0aGUgcHJ1bmVkIHBlZXIgZmluZCB0aGVtIGluIHRoZSBESFQgLS0gd2UgY2FuJ3QgdHJ1c3RcbiAgICAgICAgLy8gdW5zaWduZWQgYWRkcmVzcyByZWNvcmRzIHRocm91Z2ggUFggYW55d2F5c1xuICAgICAgICAvLyBGaW5kaW5nIHNpZ25lZCByZWNvcmRzIGluIHRoZSBESFQgaXMgbm90IHN1cHBvcnRlZCBhdCB0aGUgdGltZSBvZiB3cml0aW5nIGluIGpzLWxpYnAycFxuICAgICAgICBjb25zdCBwZWVySWQgPSBQZWVySWQuY3JlYXRlRnJvbUI1OFN0cmluZyhwKTtcbiAgICAgICAgcHgucHVzaCh7XG4gICAgICAgICAgcGVlcklEOiBwZWVySWQudG9CeXRlcygpLFxuICAgICAgICAgIHNpZ25lZFBlZXJSZWNvcmQ6XG4gICAgICAgICAgICB0aGlzLl9saWJwMnAucGVlclN0b3JlLmFkZHJlc3NCb29rLmdldFJhd0VudmVsb3BlKHBlZXJJZCksXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0b3BpY0lEOiB0b3BpYyxcbiAgICAgIHBlZXJzOiBweCxcbiAgICAgIGJhY2tvZmY6IGJhY2tvZmYsXG4gICAgfTtcbiAgfVxufVxuIiwiLyoqXG4gKiBAaGlkZGVuXG4gKiBAbW9kdWxlXG4gKi9cblxuaW1wb3J0IEdvc3NpcHN1YiBmcm9tICdsaWJwMnAtZ29zc2lwc3ViJztcbmltcG9ydCB7IEhlYXJ0YmVhdCB9IGZyb20gJ2xpYnAycC1nb3NzaXBzdWIvc3JjL2hlYXJ0YmVhdCc7XG5pbXBvcnQgeyBzaHVmZmxlIH0gZnJvbSAnbGlicDJwLWdvc3NpcHN1Yi9zcmMvdXRpbHMnO1xuXG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0UmVsYXlQZWVycyB9IGZyb20gJy4vZ2V0X3JlbGF5X3BlZXJzJztcblxuZXhwb3J0IGNsYXNzIFJlbGF5SGVhcnRiZWF0IGV4dGVuZHMgSGVhcnRiZWF0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBnb3NzaXBzdWJcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihnb3NzaXBzdWI6IEdvc3NpcHN1Yikge1xuICAgIHN1cGVyKGdvc3NpcHN1Yik7XG4gIH1cblxuICBzdGFydCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5faGVhcnRiZWF0VGltZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoZWFydGJlYXQgPSB0aGlzLl9oZWFydGJlYXQuYmluZCh0aGlzKTtcblxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGhlYXJ0YmVhdCgpO1xuICAgICAgdGhpcy5faGVhcnRiZWF0VGltZXI/LnJ1blBlcmlvZGljYWxseShcbiAgICAgICAgaGVhcnRiZWF0LFxuICAgICAgICBjb25zdGFudHMuUmVsYXlIZWFydGJlYXRJbnRlcnZhbFxuICAgICAgKTtcbiAgICB9LCBjb25zdGFudHMuUmVsYXlIZWFydGJlYXRJbml0aWFsRGVsYXkpO1xuXG4gICAgdGhpcy5faGVhcnRiZWF0VGltZXIgPSB7XG4gICAgICBfaW50ZXJ2YWxJZDogdW5kZWZpbmVkLFxuICAgICAgcnVuUGVyaW9kaWNhbGx5OiAoZm4sIHBlcmlvZCk6IHZvaWQgPT4ge1xuICAgICAgICAvLyB0aGlzLl9oZWFydGJlYXRUaW1lciBjYW5ub3QgYmUgbnVsbCwgaXQgaXMgYmVpbmcgYXNzaWduZWQuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdFRpbWVyIS5faW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZuLCBwZXJpb2QpO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogKCk6IHZvaWQgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faGVhcnRiZWF0VGltZXI/Ll9pbnRlcnZhbElkIGFzIE5vZGVKUy5UaW1lb3V0KTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyB0aGUgZ29zc2lwc3ViIHByb3RvY29sIGFuZCBzaHV0cyBkb3duIGV2ZXJ5IGNvbm5lY3Rpb25cbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgc3RvcCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2hlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faGVhcnRiZWF0VGltZXIuY2FuY2VsKCk7XG4gICAgdGhpcy5faGVhcnRiZWF0VGltZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE1haW50YWlucyB0aGUgbWVzaCBhbmQgZmFub3V0IG1hcHMgaW4gZ29zc2lwc3ViLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIF9oZWFydGJlYXQoKTogdm9pZCB7XG4gICAgY29uc3QgeyBELCBEbG8sIERoaSwgRHNjb3JlLCBEb3V0IH0gPSB0aGlzLmdvc3NpcHN1Yi5fb3B0aW9ucztcbiAgICB0aGlzLmdvc3NpcHN1Yi5oZWFydGJlYXRUaWNrcysrO1xuXG4gICAgLy8gY2FjaGUgc2NvcmVzIHRocm91Z2ggdGhlIGhlYXJ0YmVhdFxuICAgIGNvbnN0IHNjb3JlcyA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgY29uc3QgZ2V0U2NvcmUgPSAoaWQ6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gICAgICBsZXQgcyA9IHNjb3Jlcy5nZXQoaWQpO1xuICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzID0gdGhpcy5nb3NzaXBzdWIuc2NvcmUuc2NvcmUoaWQpO1xuICAgICAgICBzY29yZXMuc2V0KGlkLCBzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzO1xuICAgIH07XG5cbiAgICAvLyBwZWVyIGlkID0+IHRvcGljW11cbiAgICBjb25zdCB0b0dyYWZ0ID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZ1tdPigpO1xuICAgIC8vIHBlZXIgaWQgPT4gdG9waWNbXVxuICAgIGNvbnN0IHRvUHJ1bmUgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nW10+KCk7XG4gICAgLy8gcGVlciBpZCA9PiBkb24ndCBweFxuICAgIGNvbnN0IG5vUFggPSBuZXcgTWFwPHN0cmluZywgYm9vbGVhbj4oKTtcblxuICAgIC8vIGNsZWFuIHVwIGV4cGlyZWQgYmFja29mZnNcbiAgICB0aGlzLmdvc3NpcHN1Yi5fY2xlYXJCYWNrb2ZmKCk7XG5cbiAgICAvLyBjbGVhbiB1cCBwZWVyaGF2ZS9pYXNrZWQgY291bnRlcnNcbiAgICB0aGlzLmdvc3NpcHN1Yi5wZWVyaGF2ZS5jbGVhcigpO1xuICAgIHRoaXMuZ29zc2lwc3ViLmlhc2tlZC5jbGVhcigpO1xuXG4gICAgLy8gYXBwbHkgSVdBTlQgcmVxdWVzdCBwZW5hbHRpZXNcbiAgICB0aGlzLmdvc3NpcHN1Yi5fYXBwbHlJd2FudFBlbmFsdGllcygpO1xuXG4gICAgLy8gZW5zdXJlIGRpcmVjdCBwZWVycyBhcmUgY29ubmVjdGVkXG4gICAgdGhpcy5nb3NzaXBzdWIuX2RpcmVjdENvbm5lY3QoKTtcblxuICAgIC8vIG1haW50YWluIHRoZSBtZXNoIGZvciB0b3BpY3Mgd2UgaGF2ZSBqb2luZWRcbiAgICB0aGlzLmdvc3NpcHN1Yi5tZXNoLmZvckVhY2goKHBlZXJzLCB0b3BpYykgPT4ge1xuICAgICAgLy8gcHJ1bmUvZ3JhZnQgaGVscGVyIGZ1bmN0aW9ucyAoZGVmaW5lZCBwZXIgdG9waWMpXG4gICAgICBjb25zdCBwcnVuZVBlZXIgPSAoaWQ6IHN0cmluZyk6IHZvaWQgPT4ge1xuICAgICAgICB0aGlzLmdvc3NpcHN1Yi5sb2coXG4gICAgICAgICAgJ0hFQVJUQkVBVDogUmVtb3ZlIG1lc2ggbGluayB0byAlcyBpbiAlcycsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdG9waWNcbiAgICAgICAgKTtcbiAgICAgICAgLy8gdXBkYXRlIHBlZXIgc2NvcmVcbiAgICAgICAgdGhpcy5nb3NzaXBzdWIuc2NvcmUucHJ1bmUoaWQsIHRvcGljKTtcbiAgICAgICAgLy8gYWRkIHBydW5lIGJhY2tvZmYgcmVjb3JkXG4gICAgICAgIHRoaXMuZ29zc2lwc3ViLl9hZGRCYWNrb2ZmKGlkLCB0b3BpYyk7XG4gICAgICAgIC8vIHJlbW92ZSBwZWVyIGZyb20gbWVzaFxuICAgICAgICBwZWVycy5kZWxldGUoaWQpO1xuICAgICAgICAvLyBhZGQgdG8gdG9QcnVuZVxuICAgICAgICBjb25zdCB0b3BpY3MgPSB0b1BydW5lLmdldChpZCk7XG4gICAgICAgIGlmICghdG9waWNzKSB7XG4gICAgICAgICAgdG9QcnVuZS5zZXQoaWQsIFt0b3BpY10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcGljcy5wdXNoKHRvcGljKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGdyYWZ0UGVlciA9IChpZDogc3RyaW5nKTogdm9pZCA9PiB7XG4gICAgICAgIHRoaXMuZ29zc2lwc3ViLmxvZygnSEVBUlRCRUFUOiBBZGQgbWVzaCBsaW5rIHRvICVzIGluICVzJywgaWQsIHRvcGljKTtcbiAgICAgICAgLy8gdXBkYXRlIHBlZXIgc2NvcmVcbiAgICAgICAgdGhpcy5nb3NzaXBzdWIuc2NvcmUuZ3JhZnQoaWQsIHRvcGljKTtcbiAgICAgICAgLy8gYWRkIHBlZXIgdG8gbWVzaFxuICAgICAgICBwZWVycy5hZGQoaWQpO1xuICAgICAgICAvLyBhZGQgdG8gdG9HcmFmdFxuICAgICAgICBjb25zdCB0b3BpY3MgPSB0b0dyYWZ0LmdldChpZCk7XG4gICAgICAgIGlmICghdG9waWNzKSB7XG4gICAgICAgICAgdG9HcmFmdC5zZXQoaWQsIFt0b3BpY10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcGljcy5wdXNoKHRvcGljKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gZHJvcCBhbGwgcGVlcnMgd2l0aCBuZWdhdGl2ZSBzY29yZSwgd2l0aG91dCBQWFxuICAgICAgcGVlcnMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBnZXRTY29yZShpZCk7XG4gICAgICAgIGlmIChzY29yZSA8IDApIHtcbiAgICAgICAgICB0aGlzLmdvc3NpcHN1Yi5sb2coXG4gICAgICAgICAgICAnSEVBUlRCRUFUOiBQcnVuZSBwZWVyICVzIHdpdGggbmVnYXRpdmUgc2NvcmU6IHNjb3JlPSVkLCB0b3BpYz0lcycsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHNjb3JlLFxuICAgICAgICAgICAgdG9waWNcbiAgICAgICAgICApO1xuICAgICAgICAgIHBydW5lUGVlcihpZCk7XG4gICAgICAgICAgbm9QWC5zZXQoaWQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gZG8gd2UgaGF2ZSBlbm91Z2ggcGVlcnM/XG4gICAgICBpZiAocGVlcnMuc2l6ZSA8IERsbykge1xuICAgICAgICBjb25zdCBiYWNrb2ZmID0gdGhpcy5nb3NzaXBzdWIuYmFja29mZi5nZXQodG9waWMpO1xuICAgICAgICBjb25zdCBpbmVlZCA9IEQgLSBwZWVycy5zaXplO1xuICAgICAgICBjb25zdCBwZWVyc1NldCA9IGdldFJlbGF5UGVlcnMoXG4gICAgICAgICAgdGhpcy5nb3NzaXBzdWIsXG4gICAgICAgICAgdG9waWMsXG4gICAgICAgICAgaW5lZWQsXG4gICAgICAgICAgKGlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgbWVzaCBwZWVycywgZGlyZWN0IHBlZXJzLCBwZWVycyB3ZSBhcmUgYmFja2luZyBvZmYsIHBlZXJzIHdpdGggbmVnYXRpdmUgc2NvcmVcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICFwZWVycy5oYXMoaWQpICYmXG4gICAgICAgICAgICAgICF0aGlzLmdvc3NpcHN1Yi5kaXJlY3QuaGFzKGlkKSAmJlxuICAgICAgICAgICAgICAoIWJhY2tvZmYgfHwgIWJhY2tvZmYuaGFzKGlkKSkgJiZcbiAgICAgICAgICAgICAgZ2V0U2NvcmUoaWQpID49IDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHBlZXJzU2V0LmZvckVhY2goZ3JhZnRQZWVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gZG8gd2UgaGF2ZSB0byBtYW55IHBlZXJzP1xuICAgICAgaWYgKHBlZXJzLnNpemUgPiBEaGkpIHtcbiAgICAgICAgbGV0IHBlZXJzQXJyYXkgPSBBcnJheS5mcm9tKHBlZXJzKTtcbiAgICAgICAgLy8gc29ydCBieSBzY29yZVxuICAgICAgICBwZWVyc0FycmF5LnNvcnQoKGEsIGIpID0+IGdldFNjb3JlKGIpIC0gZ2V0U2NvcmUoYSkpO1xuICAgICAgICAvLyBXZSBrZWVwIHRoZSBmaXJzdCBEX3Njb3JlIHBlZXJzIGJ5IHNjb3JlIGFuZCB0aGUgcmVtYWluaW5nIHVwIHRvIEQgcmFuZG9tbHlcbiAgICAgICAgLy8gdW5kZXIgdGhlIGNvbnN0cmFpbnQgdGhhdCB3ZSBrZWVwIERfb3V0IHBlZXJzIGluIHRoZSBtZXNoIChpZiB3ZSBoYXZlIHRoYXQgbWFueSlcbiAgICAgICAgcGVlcnNBcnJheSA9IHBlZXJzQXJyYXlcbiAgICAgICAgICAuc2xpY2UoMCwgRHNjb3JlKVxuICAgICAgICAgIC5jb25jYXQoc2h1ZmZsZShwZWVyc0FycmF5LnNsaWNlKERzY29yZSkpKTtcblxuICAgICAgICAvLyBjb3VudCB0aGUgb3V0Ym91bmQgcGVlcnMgd2UgYXJlIGtlZXBpbmdcbiAgICAgICAgbGV0IG91dGJvdW5kID0gMDtcbiAgICAgICAgcGVlcnNBcnJheS5zbGljZSgwLCBEKS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZ29zc2lwc3ViLm91dGJvdW5kLmdldChwKSkge1xuICAgICAgICAgICAgb3V0Ym91bmQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGl0J3MgbGVzcyB0aGFuIERfb3V0LCBidWJibGUgdXAgc29tZSBvdXRib3VuZCBwZWVycyBmcm9tIHRoZSByYW5kb20gc2VsZWN0aW9uXG4gICAgICAgIGlmIChvdXRib3VuZCA8IERvdXQpIHtcbiAgICAgICAgICBjb25zdCByb3RhdGUgPSAoaTogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgICAgICAvLyByb3RhdGUgdGhlIHBlZXJzQXJyYXkgdG8gdGhlIHJpZ2h0IGFuZCBwdXQgdGhlIGl0aCBwZWVyIGluIHRoZSBmcm9udFxuICAgICAgICAgICAgY29uc3QgcCA9IHBlZXJzQXJyYXlbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgICBwZWVyc0FycmF5W2pdID0gcGVlcnNBcnJheVtqIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZWVyc0FycmF5WzBdID0gcDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gZmlyc3QgYnViYmxlIHVwIGFsbCBvdXRib3VuZCBwZWVycyBhbHJlYWR5IGluIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGZyb250XG4gICAgICAgICAgaWYgKG91dGJvdW5kID4gMCkge1xuICAgICAgICAgICAgbGV0IGloYXZlID0gb3V0Ym91bmQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IEQgJiYgaWhhdmUgPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZ29zc2lwc3ViLm91dGJvdW5kLmdldChwZWVyc0FycmF5W2ldKSkge1xuICAgICAgICAgICAgICAgIHJvdGF0ZShpKTtcbiAgICAgICAgICAgICAgICBpaGF2ZS0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbm93IGJ1YmJsZSB1cCBlbm91Z2ggb3V0Ym91bmQgcGVlcnMgb3V0c2lkZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBmcm9udFxuICAgICAgICAgIGxldCBpbmVlZCA9IEQgLSBvdXRib3VuZDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gRDsgaSA8IHBlZXJzQXJyYXkubGVuZ3RoICYmIGluZWVkID4gMDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nb3NzaXBzdWIub3V0Ym91bmQuZ2V0KHBlZXJzQXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgIHJvdGF0ZShpKTtcbiAgICAgICAgICAgICAgaW5lZWQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcnVuZSB0aGUgZXhjZXNzIHBlZXJzXG4gICAgICAgIHBlZXJzQXJyYXkuc2xpY2UoRCkuZm9yRWFjaChwcnVuZVBlZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBkbyB3ZSBoYXZlIGVub3VnaCBvdXRib3VuZCBwZWVycz9cbiAgICAgIGlmIChwZWVycy5zaXplID49IERsbykge1xuICAgICAgICAvLyBjb3VudCB0aGUgb3V0Ym91bmQgcGVlcnMgd2UgaGF2ZVxuICAgICAgICBsZXQgb3V0Ym91bmQgPSAwO1xuICAgICAgICBwZWVycy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZ29zc2lwc3ViLm91dGJvdW5kLmdldChwKSkge1xuICAgICAgICAgICAgb3V0Ym91bmQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGl0J3MgbGVzcyB0aGFuIERfb3V0LCBzZWxlY3Qgc29tZSBwZWVycyB3aXRoIG91dGJvdW5kIGNvbm5lY3Rpb25zIGFuZCBncmFmdCB0aGVtXG4gICAgICAgIGlmIChvdXRib3VuZCA8IERvdXQpIHtcbiAgICAgICAgICBjb25zdCBpbmVlZCA9IERvdXQgLSBvdXRib3VuZDtcbiAgICAgICAgICBjb25zdCBiYWNrb2ZmID0gdGhpcy5nb3NzaXBzdWIuYmFja29mZi5nZXQodG9waWMpO1xuICAgICAgICAgIGdldFJlbGF5UGVlcnModGhpcy5nb3NzaXBzdWIsIHRvcGljLCBpbmVlZCwgKGlkOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgIC8vIGZpbHRlciBvdXIgY3VycmVudCBtZXNoIHBlZXJzLCBkaXJlY3QgcGVlcnMsIHBlZXJzIHdlIGFyZSBiYWNraW5nIG9mZiwgcGVlcnMgd2l0aCBuZWdhdGl2ZSBzY29yZVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgIXBlZXJzLmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgIXRoaXMuZ29zc2lwc3ViLmRpcmVjdC5oYXMoaWQpICYmXG4gICAgICAgICAgICAgICghYmFja29mZiB8fCAhYmFja29mZi5oYXMoaWQpKSAmJlxuICAgICAgICAgICAgICBnZXRTY29yZShpZCkgPj0gMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KS5mb3JFYWNoKGdyYWZ0UGVlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc2hvdWxkIHdlIHRyeSB0byBpbXByb3ZlIHRoZSBtZXNoIHdpdGggb3Bwb3J0dW5pc3RpYyBncmFmdGluZz9cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5nb3NzaXBzdWIuaGVhcnRiZWF0VGlja3MgJVxuICAgICAgICAgIGNvbnN0YW50cy5SZWxheU9wcG9ydHVuaXN0aWNHcmFmdFRpY2tzID09PVxuICAgICAgICAgIDAgJiZcbiAgICAgICAgcGVlcnMuc2l6ZSA+IDFcbiAgICAgICkge1xuICAgICAgICAvLyBPcHBvcnR1bmlzdGljIGdyYWZ0aW5nIHdvcmtzIGFzIGZvbGxvd3M6IHdlIGNoZWNrIHRoZSBtZWRpYW4gc2NvcmUgb2YgcGVlcnMgaW4gdGhlXG4gICAgICAgIC8vIG1lc2g7IGlmIHRoaXMgc2NvcmUgaXMgYmVsb3cgdGhlIG9wcG9ydHVuaXN0aWNHcmFmdFRocmVzaG9sZCwgd2Ugc2VsZWN0IGEgZmV3IHBlZXJzIGF0XG4gICAgICAgIC8vIHJhbmRvbSB3aXRoIHNjb3JlIG92ZXIgdGhlIG1lZGlhbi5cbiAgICAgICAgLy8gVGhlIGludGVudGlvbiBpcyB0byAoc2xvd2x5KSBpbXByb3ZlIGFuIHVuZGVyIHBlcmZvcm1pbmcgbWVzaCBieSBpbnRyb2R1Y2luZyBnb29kXG4gICAgICAgIC8vIHNjb3JpbmcgcGVlcnMgdGhhdCBtYXkgaGF2ZSBiZWVuIGdvc3NpcGluZyBhdCB1cy4gVGhpcyBhbGxvd3MgdXMgdG8gZ2V0IG91dCBvZiBzdGlja3lcbiAgICAgICAgLy8gc2l0dWF0aW9ucyB3aGVyZSB3ZSBhcmUgc3R1Y2sgd2l0aCBwb29yIHBlZXJzIGFuZCBhbHNvIHJlY292ZXIgZnJvbSBjaHVybiBvZiBnb29kIHBlZXJzLlxuXG4gICAgICAgIC8vIG5vdyBjb21wdXRlIHRoZSBtZWRpYW4gcGVlciBzY29yZSBpbiB0aGUgbWVzaFxuICAgICAgICBjb25zdCBwZWVyc0xpc3QgPSBBcnJheS5mcm9tKHBlZXJzKS5zb3J0KFxuICAgICAgICAgIChhLCBiKSA9PiBnZXRTY29yZShhKSAtIGdldFNjb3JlKGIpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IG1lZGlhbkluZGV4ID0gTWF0aC5mbG9vcihwZWVycy5zaXplIC8gMik7XG4gICAgICAgIGNvbnN0IG1lZGlhblNjb3JlID0gZ2V0U2NvcmUocGVlcnNMaXN0W21lZGlhbkluZGV4XSk7XG5cbiAgICAgICAgLy8gaWYgdGhlIG1lZGlhbiBzY29yZSBpcyBiZWxvdyB0aGUgdGhyZXNob2xkLCBzZWxlY3QgYSBiZXR0ZXIgcGVlciAoaWYgYW55KSBhbmQgR1JBRlRcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1lZGlhblNjb3JlIDxcbiAgICAgICAgICB0aGlzLmdvc3NpcHN1Yi5fb3B0aW9ucy5zY29yZVRocmVzaG9sZHMub3Bwb3J0dW5pc3RpY0dyYWZ0VGhyZXNob2xkXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGJhY2tvZmYgPSB0aGlzLmdvc3NpcHN1Yi5iYWNrb2ZmLmdldCh0b3BpYyk7XG4gICAgICAgICAgY29uc3QgcGVlcnNUb0dyYWZ0ID0gZ2V0UmVsYXlQZWVycyhcbiAgICAgICAgICAgIHRoaXMuZ29zc2lwc3ViLFxuICAgICAgICAgICAgdG9waWMsXG4gICAgICAgICAgICBjb25zdGFudHMuUmVsYXlPcHBvcnR1bmlzdGljR3JhZnRQZWVycyxcbiAgICAgICAgICAgIChpZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgICAgICAgICAgIC8vIGZpbHRlciBvdXQgY3VycmVudCBtZXNoIHBlZXJzLCBkaXJlY3QgcGVlcnMsIHBlZXJzIHdlIGFyZSBiYWNraW5nIG9mZiwgcGVlcnMgYmVsb3cgb3IgYXQgdGhyZXNob2xkXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgcGVlcnMuaGFzKGlkKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmdvc3NpcHN1Yi5kaXJlY3QuaGFzKGlkKSAmJlxuICAgICAgICAgICAgICAgICghYmFja29mZiB8fCAhYmFja29mZi5oYXMoaWQpKSAmJlxuICAgICAgICAgICAgICAgIGdldFNjb3JlKGlkKSA+IG1lZGlhblNjb3JlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICBwZWVyc1RvR3JhZnQuZm9yRWFjaCgoaWQ6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5nb3NzaXBzdWIubG9nKFxuICAgICAgICAgICAgICAnSEVBUlRCRUFUOiBPcHBvcnR1bmlzdGljYWxseSBncmFmdCBwZWVyICVzIG9uIHRvcGljICVzJyxcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIHRvcGljXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZ3JhZnRQZWVyKGlkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyAybmQgYXJnIGFyZSBtZXNoIHBlZXJzIGV4Y2x1ZGVkIGZyb20gZ29zc2lwLiBXZSBoYXZlIGFscmVhZHkgcHVzaGVkXG4gICAgICAvLyBtZXNzYWdlcyB0byB0aGVtLCBzbyBpdHMgcmVkdW5kYW50IHRvIGdvc3NpcCBJSEFWRXMuXG4gICAgICB0aGlzLmdvc3NpcHN1Yi5fZW1pdEdvc3NpcCh0b3BpYywgcGVlcnMpO1xuICAgIH0pO1xuXG4gICAgLy8gZXhwaXJlIGZhbm91dCBmb3IgdG9waWNzIHdlIGhhdmVuJ3QgcHVibGlzaGVkIHRvIGluIGEgd2hpbGVcbiAgICBjb25zdCBub3cgPSB0aGlzLmdvc3NpcHN1Yi5fbm93KCk7XG4gICAgdGhpcy5nb3NzaXBzdWIubGFzdHB1Yi5mb3JFYWNoKChsYXN0cHViLCB0b3BpYykgPT4ge1xuICAgICAgaWYgKGxhc3RwdWIgKyBjb25zdGFudHMuUmVsYXlGYW5vdXRUVEwgPCBub3cpIHtcbiAgICAgICAgdGhpcy5nb3NzaXBzdWIuZmFub3V0LmRlbGV0ZSh0b3BpYyk7XG4gICAgICAgIHRoaXMuZ29zc2lwc3ViLmxhc3RwdWIuZGVsZXRlKHRvcGljKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIG1haW50YWluIG91ciBmYW5vdXQgZm9yIHRvcGljcyB3ZSBhcmUgcHVibGlzaGluZyBidXQgd2UgaGF2ZSBub3Qgam9pbmVkXG4gICAgdGhpcy5nb3NzaXBzdWIuZmFub3V0LmZvckVhY2goKGZhbm91dFBlZXJzLCB0b3BpYykgPT4ge1xuICAgICAgLy8gY2hlY2tzIHdoZXRoZXIgb3VyIHBlZXJzIGFyZSBzdGlsbCBpbiB0aGUgdG9waWMgYW5kIGhhdmUgYSBzY29yZSBhYm92ZSB0aGUgcHVibGlzaCB0aHJlc2hvbGRcbiAgICAgIGNvbnN0IHRvcGljUGVlcnMgPSB0aGlzLmdvc3NpcHN1Yi50b3BpY3MuZ2V0KHRvcGljKTtcbiAgICAgIGZhbm91dFBlZXJzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhdG9waWNQZWVycz8uaGFzKGlkKSB8fFxuICAgICAgICAgIGdldFNjb3JlKGlkKSA8XG4gICAgICAgICAgICB0aGlzLmdvc3NpcHN1Yi5fb3B0aW9ucy5zY29yZVRocmVzaG9sZHMucHVibGlzaFRocmVzaG9sZFxuICAgICAgICApIHtcbiAgICAgICAgICBmYW5vdXRQZWVycy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gZG8gd2UgbmVlZCBtb3JlIHBlZXJzP1xuICAgICAgaWYgKGZhbm91dFBlZXJzLnNpemUgPCBEKSB7XG4gICAgICAgIGNvbnN0IGluZWVkID0gRCAtIGZhbm91dFBlZXJzLnNpemU7XG4gICAgICAgIGNvbnN0IHBlZXJzU2V0ID0gZ2V0UmVsYXlQZWVycyhcbiAgICAgICAgICB0aGlzLmdvc3NpcHN1YixcbiAgICAgICAgICB0b3BpYyxcbiAgICAgICAgICBpbmVlZCxcbiAgICAgICAgICAoaWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBleGlzdGluZyBmYW5vdXQgcGVlcnMsIGRpcmVjdCBwZWVycywgYW5kIHBlZXJzIHdpdGggc2NvcmUgYWJvdmUgdGhlIHB1Ymxpc2ggdGhyZXNob2xkXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAhZmFub3V0UGVlcnMuaGFzKGlkKSAmJlxuICAgICAgICAgICAgICAhdGhpcy5nb3NzaXBzdWIuZGlyZWN0LmhhcyhpZCkgJiZcbiAgICAgICAgICAgICAgZ2V0U2NvcmUoaWQpID49XG4gICAgICAgICAgICAgICAgdGhpcy5nb3NzaXBzdWIuX29wdGlvbnMuc2NvcmVUaHJlc2hvbGRzLnB1Ymxpc2hUaHJlc2hvbGRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBwZWVyc1NldC5mb3JFYWNoKChpZDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgZmFub3V0UGVlcnMuYWRkKGlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIDJuZCBhcmcgYXJlIGZhbm91dCBwZWVycyBleGNsdWRlZCBmcm9tIGdvc3NpcC5cbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBwdXNoZWQgbWVzc2FnZXMgdG8gdGhlbSwgc28gaXRzIHJlZHVuZGFudCB0byBnb3NzaXAgSUhBVkVzXG4gICAgICB0aGlzLmdvc3NpcHN1Yi5fZW1pdEdvc3NpcCh0b3BpYywgZmFub3V0UGVlcnMpO1xuICAgIH0pO1xuXG4gICAgLy8gc2VuZCBjb2FsZXNjZWQgR1JBRlQvUFJVTkUgbWVzc2FnZXMgKHdpbGwgcGlnZ3liYWNrIGdvc3NpcClcbiAgICB0aGlzLmdvc3NpcHN1Yi5fc2VuZEdyYWZ0UHJ1bmUodG9HcmFmdCwgdG9QcnVuZSwgbm9QWCk7XG5cbiAgICAvLyBmbHVzaCBwZW5kaW5nIGdvc3NpcCB0aGF0IHdhc24ndCBwaWdneWJhY2tlZCBhYm92ZVxuICAgIHRoaXMuZ29zc2lwc3ViLl9mbHVzaCgpO1xuXG4gICAgLy8gYWR2YW5jZSB0aGUgbWVzc2FnZSBoaXN0b3J5IHdpbmRvd1xuICAgIHRoaXMuZ29zc2lwc3ViLm1lc3NhZ2VDYWNoZS5zaGlmdCgpO1xuXG4gICAgdGhpcy5nb3NzaXBzdWIuZW1pdCgnZ29zc2lwc3ViOmhlYXJ0YmVhdCcpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBSZWFkZXIgfSBmcm9tICdwcm90b2J1ZmpzL21pbmltYWwnO1xuaW1wb3J0IHsgdjQgYXMgdXVpZCB9IGZyb20gJ3V1aWQnO1xuXG5pbXBvcnQgKiBhcyBwcm90byBmcm9tICcuLi8uLi9wcm90by93YWt1L3YyL3N0b3JlJztcblxuZXhwb3J0IGVudW0gUGFnZURpcmVjdGlvbiB7XG4gIEJBQ0tXQVJEID0gJ2JhY2t3YXJkJyxcbiAgRk9SV0FSRCA9ICdmb3J3YXJkJyxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYXJhbXMge1xuICBjb250ZW50VG9waWNzOiBzdHJpbmdbXTtcbiAgcHViU3ViVG9waWM6IHN0cmluZztcbiAgcGFnZURpcmVjdGlvbjogUGFnZURpcmVjdGlvbjtcbiAgcGFnZVNpemU6IG51bWJlcjtcbiAgc3RhcnRUaW1lPzogbnVtYmVyO1xuICBlbmRUaW1lPzogbnVtYmVyO1xuICBjdXJzb3I/OiBwcm90by5JbmRleDtcbn1cblxuZXhwb3J0IGNsYXNzIEhpc3RvcnlSUEMge1xuICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHByb3RvOiBwcm90by5IaXN0b3J5UlBDKSB7fVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgSGlzdG9yeSBRdWVyeS5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVRdWVyeShwYXJhbXM6IFBhcmFtcyk6IEhpc3RvcnlSUEMge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRpcmVjdGlvblRvUHJvdG8ocGFyYW1zLnBhZ2VEaXJlY3Rpb24pO1xuICAgIGNvbnN0IHBhZ2luZ0luZm8gPSB7XG4gICAgICBwYWdlU2l6ZTogcGFyYW1zLnBhZ2VTaXplLFxuICAgICAgY3Vyc29yOiBwYXJhbXMuY3Vyc29yLFxuICAgICAgZGlyZWN0aW9uLFxuICAgIH07XG5cbiAgICBjb25zdCBjb250ZW50RmlsdGVycyA9IHBhcmFtcy5jb250ZW50VG9waWNzLm1hcCgoY29udGVudFRvcGljKSA9PiB7XG4gICAgICByZXR1cm4geyBjb250ZW50VG9waWMgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgSGlzdG9yeVJQQyh7XG4gICAgICByZXF1ZXN0SWQ6IHV1aWQoKSxcbiAgICAgIHF1ZXJ5OiB7XG4gICAgICAgIHB1YlN1YlRvcGljOiBwYXJhbXMucHViU3ViVG9waWMsXG4gICAgICAgIGNvbnRlbnRGaWx0ZXJzLFxuICAgICAgICBwYWdpbmdJbmZvLFxuICAgICAgICBzdGFydFRpbWU6IHBhcmFtcy5zdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWU6IHBhcmFtcy5lbmRUaW1lLFxuICAgICAgfSxcbiAgICAgIHJlc3BvbnNlOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGVjb2RlKGJ5dGVzOiBVaW50OEFycmF5KTogSGlzdG9yeVJQQyB7XG4gICAgY29uc3QgcmVzID0gcHJvdG8uSGlzdG9yeVJQQy5kZWNvZGUoUmVhZGVyLmNyZWF0ZShieXRlcykpO1xuICAgIHJldHVybiBuZXcgSGlzdG9yeVJQQyhyZXMpO1xuICB9XG5cbiAgZW5jb2RlKCk6IFVpbnQ4QXJyYXkge1xuICAgIHJldHVybiBwcm90by5IaXN0b3J5UlBDLmVuY29kZSh0aGlzLnByb3RvKS5maW5pc2goKTtcbiAgfVxuXG4gIGdldCBxdWVyeSgpOiBwcm90by5IaXN0b3J5UXVlcnkgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnByb3RvLnF1ZXJ5O1xuICB9XG5cbiAgZ2V0IHJlc3BvbnNlKCk6IHByb3RvLkhpc3RvcnlSZXNwb25zZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMucHJvdG8ucmVzcG9uc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlyZWN0aW9uVG9Qcm90byhcbiAgcGFnZURpcmVjdGlvbjogUGFnZURpcmVjdGlvblxuKTogcHJvdG8uUGFnaW5nSW5mb19EaXJlY3Rpb24ge1xuICBzd2l0Y2ggKHBhZ2VEaXJlY3Rpb24pIHtcbiAgICBjYXNlIFBhZ2VEaXJlY3Rpb24uQkFDS1dBUkQ6XG4gICAgICByZXR1cm4gcHJvdG8uUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEO1xuICAgIGNhc2UgUGFnZURpcmVjdGlvbi5GT1JXQVJEOlxuICAgICAgcmV0dXJuIHByb3RvLlBhZ2luZ0luZm9fRGlyZWN0aW9uLkRJUkVDVElPTl9GT1JXQVJEO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcHJvdG8uUGFnaW5nSW5mb19EaXJlY3Rpb24uRElSRUNUSU9OX0JBQ0tXQVJEX1VOU1BFQ0lGSUVEO1xuICB9XG59XG4iLCJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IGNvbmNhdCBmcm9tICdpdC1jb25jYXQnO1xuaW1wb3J0IGxwIGZyb20gJ2l0LWxlbmd0aC1wcmVmaXhlZCc7XG5pbXBvcnQgcGlwZSBmcm9tICdpdC1waXBlJztcbmltcG9ydCBMaWJwMnAgZnJvbSAnbGlicDJwJztcbmltcG9ydCB7IFBlZXIgfSBmcm9tICdsaWJwMnAvc3JjL3BlZXItc3RvcmUnO1xuaW1wb3J0IFBlZXJJZCBmcm9tICdwZWVyLWlkJztcblxuaW1wb3J0IHsgSGlzdG9yeVJlc3BvbnNlX0Vycm9yIH0gZnJvbSAnLi4vLi4vcHJvdG8nO1xuaW1wb3J0IHsgZ2V0UGVlcnNGb3JQcm90b2NvbCwgc2VsZWN0UmFuZG9tUGVlciB9IGZyb20gJy4uL3NlbGVjdF9wZWVyJztcbmltcG9ydCB7IGhleFRvQnVmIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgRGVmYXVsdFB1YlN1YlRvcGljIH0gZnJvbSAnLi4vd2FrdSc7XG5pbXBvcnQgeyBEZWNyeXB0aW9uTWV0aG9kLCBXYWt1TWVzc2FnZSB9IGZyb20gJy4uL3dha3VfbWVzc2FnZSc7XG5cbmltcG9ydCB7IEhpc3RvcnlSUEMsIFBhZ2VEaXJlY3Rpb24gfSBmcm9tICcuL2hpc3RvcnlfcnBjJztcblxuY29uc3QgZGJnID0gZGVidWcoJ3dha3U6c3RvcmUnKTtcblxuZXhwb3J0IGNvbnN0IFN0b3JlQ29kZWMgPSAnL3ZhYy93YWt1L3N0b3JlLzIuMC4wLWJldGEzJztcblxuZXhwb3J0IGNvbnN0IERlZmF1bHRQYWdlU2l6ZSA9IDEwO1xuXG5leHBvcnQgeyBQYWdlRGlyZWN0aW9uIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgUHViU3ViIFRvcGljIHRvIHVzZS4gRGVmYXVsdHMgdG8ge0BsaW5rIERlZmF1bHRQdWJTdWJUb3BpY30uXG4gICAqXG4gICAqIFRoZSB1c2FnZSBvZiB0aGUgZGVmYXVsdCBwdWJzdWIgdG9waWMgaXMgcmVjb21tZW5kZWQuXG4gICAqIFNlZSBbV2FrdSB2MiBUb3BpYyBVc2FnZSBSZWNvbW1lbmRhdGlvbnNdKGh0dHBzOi8vcmZjLnZhYy5kZXYvc3BlYy8yMy8pIGZvciBkZXRhaWxzLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7QGxpbmsgRGVmYXVsdFB1YlN1YlRvcGljfVxuICAgKi9cbiAgcHViU3ViVG9waWM/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGltZUZpbHRlciB7XG4gIHN0YXJ0VGltZTogRGF0ZTtcbiAgZW5kVGltZTogRGF0ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWVyeU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHBlZXIgdG8gcXVlcnkuIElmIHVuZGVmaW5lZCwgYSBwc2V1ZG8tcmFuZG9tIHBlZXIgaXMgc2VsZWN0ZWQgZnJvbSB0aGUgY29ubmVjdGVkIFdha3UgU3RvcmUgcGVlcnMuXG4gICAqL1xuICBwZWVySWQ/OiBQZWVySWQ7XG4gIC8qKlxuICAgKiBUaGUgcHVic3ViIHRvcGljIHRvIHBhc3MgdG8gdGhlIHF1ZXJ5LlxuICAgKiBTZWUgW1dha3UgdjIgVG9waWMgVXNhZ2UgUmVjb21tZW5kYXRpb25zXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMjMvKS5cbiAgICovXG4gIHB1YlN1YlRvcGljPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGRpcmVjdGlvbiBpbiB3aGljaCBwYWdlcyBhcmUgcmV0cmlldmVkOlxuICAgKiAtIFtbUGFnZURpcmVjdGlvbi5CQUNLV0FSRF1dOiBNb3N0IHJlY2VudCBwYWdlIGZpcnN0LlxuICAgKiAtIFtbUGFnZURpcmVjdGlvbi5GT1JXQVJEXV06IE9sZGVzdCBwYWdlIGZpcnN0LlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGRvZXMgbm90IGFmZmVjdCB0aGUgb3JkZXJpbmcgb2YgbWVzc2FnZXMgd2l0aCB0aGUgcGFnZVxuICAgKiAob2xkZXN0IG1lc3NhZ2UgaXMgYWx3YXlzIGZpcnN0KS5cbiAgICpcbiAgICogQGRlZmF1bHQgW1tQYWdlRGlyZWN0aW9uLkJBQ0tXQVJEXV1cbiAgICovXG4gIHBhZ2VEaXJlY3Rpb24/OiBQYWdlRGlyZWN0aW9uO1xuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBtZXNzYWdlIHBlciBwYWdlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBbW0RlZmF1bHRQYWdlU2l6ZV1dXG4gICAqL1xuICBwYWdlU2l6ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHJpZXZlIG1lc3NhZ2VzIHdpdGggYSB0aW1lc3RhbXAgd2l0aGluIHRoZSBwcm92aWRlZCB2YWx1ZXMuXG4gICAqL1xuICB0aW1lRmlsdGVyPzogVGltZUZpbHRlcjtcbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCBvbiBwYWdlcyBvZiBzdG9yZWQgbWVzc2FnZXMgYXMgdGhleSBhcmUgcmV0cmlldmVkLlxuICAgKlxuICAgKiBBbGxvd3MgZm9yIGEgZmFzdGVyIGFjY2VzcyB0byB0aGUgcmVzdWx0cyBhcyBpdCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhIHBhZ2VcbiAgICogaXMgcmVjZWl2ZWQuIFRyYXZlcnNhbCBvZiB0aGUgcGFnZXMgaXMgZG9uZSBhdXRvbWF0aWNhbGx5IHNvIHRoaXMgZnVuY3Rpb25cbiAgICogd2lsbCBpbnZva2VkIGZvciBlYWNoIHJldHJpZXZlZCBwYWdlLlxuICAgKlxuICAgKiBJZiB0aGUgY2FsbCBvbiBhIHBhZ2UgcmV0dXJucyBgdHJ1ZWAsIHRoZW4gdHJhdmVyc2FsIG9mIHRoZSBwYWdlcyBpcyBhYm9ydGVkLlxuICAgKiBGb3IgZXhhbXBsZSwgdGhpcyBjYW4gYmUgdXNlZCBmb3IgdGhlIGNhbGxlciB0byBzdG9wIHRoZSBxdWVyeSBhZnRlciBhXG4gICAqIHNwZWNpZmljIG1lc3NhZ2UgaXMgZm91bmQuXG4gICAqL1xuICBjYWxsYmFjaz86IChtZXNzYWdlczogV2FrdU1lc3NhZ2VbXSkgPT4gdm9pZCB8IGJvb2xlYW47XG4gIC8qKlxuICAgKiBLZXlzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRlY3J5cHQgbWVzc2FnZXMuXG4gICAqXG4gICAqIEl0IGNhbiBiZSBBc3ltbWV0cmljIFByaXZhdGUgS2V5cyBhbmQgU3ltbWV0cmljIEtleXMgaW4gdGhlIHNhbWUgYXJyYXksXG4gICAqIGFsbCBrZXlzIHdpbGwgYmUgdHJpZWQgd2l0aCBib3RoIG1ldGhvZHMuXG4gICAqL1xuICBkZWNyeXB0aW9uS2V5cz86IEFycmF5PFVpbnQ4QXJyYXkgfCBzdHJpbmc+O1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIFtXYWt1IHYyIFN0b3JlIHByb3RvY29sXShodHRwczovL3JmYy52YWMuZGV2L3NwZWMvMTMvKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdha3VTdG9yZSB7XG4gIHB1YlN1YlRvcGljOiBzdHJpbmc7XG4gIHB1YmxpYyBkZWNyeXB0aW9uS2V5czogTWFwPFxuICAgIFVpbnQ4QXJyYXksXG4gICAgeyBtZXRob2Q/OiBEZWNyeXB0aW9uTWV0aG9kOyBjb250ZW50VG9waWNzPzogc3RyaW5nW10gfVxuICA+O1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBsaWJwMnA6IExpYnAycCwgb3B0aW9ucz86IENyZWF0ZU9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucz8ucHViU3ViVG9waWMpIHtcbiAgICAgIHRoaXMucHViU3ViVG9waWMgPSBvcHRpb25zLnB1YlN1YlRvcGljO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1YlN1YlRvcGljID0gRGVmYXVsdFB1YlN1YlRvcGljO1xuICAgIH1cblxuICAgIHRoaXMuZGVjcnlwdGlvbktleXMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogRG8gYSBIaXN0b3J5IFF1ZXJ5IHRvIGEgV2FrdSBTdG9yZS5cbiAgICpcbiAgICogQHBhcmFtIGNvbnRlbnRUb3BpY3MgVGhlIGNvbnRlbnQgdG9waWNzIHRvIHBhc3MgdG8gdGhlIHF1ZXJ5LCBsZWF2ZSBlbXB0eSB0b1xuICAgKiByZXRyaWV2ZSBhbGwgbWVzc2FnZXMuXG4gICAqXG4gICAqIEB0aHJvd3MgSWYgbm90IGFibGUgdG8gcmVhY2ggYSBXYWt1IFN0b3JlIHBlZXIgdG8gcXVlcnlcbiAgICogb3IgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgd2hlbiBwcm9jZXNzaW5nIHRoZSByZXBseS5cbiAgICovXG4gIGFzeW5jIHF1ZXJ5SGlzdG9yeShcbiAgICBjb250ZW50VG9waWNzOiBzdHJpbmdbXSxcbiAgICBvcHRpb25zPzogUXVlcnlPcHRpb25zXG4gICk6IFByb21pc2U8V2FrdU1lc3NhZ2VbXT4ge1xuICAgIGxldCBzdGFydFRpbWUsIGVuZFRpbWU7XG4gICAgaWYgKG9wdGlvbnM/LnRpbWVGaWx0ZXIpIHtcbiAgICAgIHN0YXJ0VGltZSA9IG9wdGlvbnMudGltZUZpbHRlci5zdGFydFRpbWUuZ2V0VGltZSgpIC8gMTAwMDtcbiAgICAgIGVuZFRpbWUgPSBvcHRpb25zLnRpbWVGaWx0ZXIuZW5kVGltZS5nZXRUaW1lKCkgLyAxMDAwO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICBwdWJTdWJUb3BpYzogdGhpcy5wdWJTdWJUb3BpYyxcbiAgICAgICAgcGFnZURpcmVjdGlvbjogUGFnZURpcmVjdGlvbi5CQUNLV0FSRCxcbiAgICAgICAgcGFnZVNpemU6IERlZmF1bHRQYWdlU2l6ZSxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zLFxuICAgICAge1xuICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgIGVuZFRpbWUsXG4gICAgICB9LFxuICAgICAgeyBjb250ZW50VG9waWNzIH1cbiAgICApO1xuICAgIGRiZygnUXVlcnlpbmcgaGlzdG9yeSB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9ucycsIG9wdGlvbnMpO1xuXG4gICAgbGV0IHBlZXI7XG4gICAgaWYgKG9wdHMucGVlcklkKSB7XG4gICAgICBwZWVyID0gdGhpcy5saWJwMnAucGVlclN0b3JlLmdldChvcHRzLnBlZXJJZCk7XG4gICAgICBpZiAoIXBlZXIpXG4gICAgICAgIHRocm93IGBGYWlsZWQgdG8gcmV0cmlldmUgY29ubmVjdGlvbiBkZXRhaWxzIGZvciBwcm92aWRlZCBwZWVyIGluIHBlZXIgc3RvcmU6ICR7b3B0cy5wZWVySWQudG9CNThTdHJpbmcoKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZWVyID0gdGhpcy5yYW5kb21QZWVyO1xuICAgICAgaWYgKCFwZWVyKVxuICAgICAgICB0aHJvdyAnRmFpbGVkIHRvIGZpbmQga25vd24gcGVlciB0aGF0IHJlZ2lzdGVycyB3YWt1IHN0b3JlIHByb3RvY29sJztcbiAgICB9XG4gICAgaWYgKCFwZWVyLnByb3RvY29scy5pbmNsdWRlcyhTdG9yZUNvZGVjKSlcbiAgICAgIHRocm93IGBQZWVyIGRvZXMgbm90IHJlZ2lzdGVyIHdha3Ugc3RvcmUgcHJvdG9jb2w6ICR7cGVlci5pZC50b0I1OFN0cmluZygpfWA7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IHRoaXMubGlicDJwLmNvbm5lY3Rpb25NYW5hZ2VyLmdldChwZWVyLmlkKTtcbiAgICBpZiAoIWNvbm5lY3Rpb24pIHRocm93ICdGYWlsZWQgdG8gZ2V0IGEgY29ubmVjdGlvbiB0byB0aGUgcGVlcic7XG5cbiAgICBjb25zdCBkZWNyeXB0aW9uS2V5cyA9IEFycmF5LmZyb20odGhpcy5kZWNyeXB0aW9uS2V5cykubWFwKFxuICAgICAgKFtrZXksIHsgbWV0aG9kLCBjb250ZW50VG9waWNzIH1dKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBjb250ZW50VG9waWNzLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBBZGQgdGhlIGRlY3J5cHRpb24ga2V5cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhZ2FpbnN0IHRoZVxuICAgIC8vIGNvbnRlbnQgdG9waWNzIGFsc28gcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24uXG4gICAgaWYgKG9wdHMuZGVjcnlwdGlvbktleXMpIHtcbiAgICAgIG9wdHMuZGVjcnlwdGlvbktleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGRlY3J5cHRpb25LZXlzLnB1c2goe1xuICAgICAgICAgIGtleTogaGV4VG9CdWYoa2V5KSxcbiAgICAgICAgICBjb250ZW50VG9waWNzOiBjb250ZW50VG9waWNzLmxlbmd0aCA/IGNvbnRlbnRUb3BpY3MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgbWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZXM6IFdha3VNZXNzYWdlW10gPSBbXTtcbiAgICBsZXQgY3Vyc29yID0gdW5kZWZpbmVkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IHN0cmVhbSB9ID0gYXdhaXQgY29ubmVjdGlvbi5uZXdTdHJlYW0oU3RvcmVDb2RlYyk7XG4gICAgICBjb25zdCBxdWVyeU9wdHMgPSBPYmplY3QuYXNzaWduKG9wdHMsIHsgY3Vyc29yIH0pO1xuICAgICAgY29uc3QgaGlzdG9yeVJwY1F1ZXJ5ID0gSGlzdG9yeVJQQy5jcmVhdGVRdWVyeShxdWVyeU9wdHMpO1xuICAgICAgZGJnKCdRdWVyeWluZyBzdG9yZSBwZWVyJywgY29ubmVjdGlvbi5yZW1vdGVBZGRyLnRvU3RyaW5nKCkpO1xuXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBwaXBlKFxuICAgICAgICBbaGlzdG9yeVJwY1F1ZXJ5LmVuY29kZSgpXSxcbiAgICAgICAgbHAuZW5jb2RlKCksXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgbHAuZGVjb2RlKCksXG4gICAgICAgIGNvbmNhdFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlcGx5ID0gSGlzdG9yeVJQQy5kZWNvZGUocmVzLnNsaWNlKCkpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IHJlcGx5LnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICB0aHJvdyAnSGlzdG9yeSByZXNwb25zZSBtaXNzZXMgcmVzcG9uc2UgZmllbGQnO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHJlc3BvbnNlLmVycm9yICYmXG4gICAgICAgIHJlc3BvbnNlLmVycm9yID09PSBIaXN0b3J5UmVzcG9uc2VfRXJyb3IuRVJST1JfSU5WQUxJRF9DVVJTT1JcbiAgICAgICkge1xuICAgICAgICB0aHJvdyAnSGlzdG9yeSByZXNwb25zZSBjb250YWlucyBhbiBFcnJvcjogSU5WQUxJRCBDVVJTT1InO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlc3BvbnNlLm1lc3NhZ2VzIHx8ICFyZXNwb25zZS5tZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gTm8gbWVzc2FnZXMgbGVmdCAob3Igc3RvcmVkKVxuICAgICAgICBjb25zb2xlLmxvZygnTm8gbWVzc2FnZXMgcHJlc2VudCBpbiBIaXN0b3J5UlBDIHJlc3BvbnNlJyk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICAgIH1cblxuICAgICAgZGJnKFxuICAgICAgICBgJHtyZXNwb25zZS5tZXNzYWdlcy5sZW5ndGh9IG1lc3NhZ2VzIHJldHJpZXZlZCBmb3IgcHVic3ViIHRvcGljICR7b3B0cy5wdWJTdWJUb3BpY31gXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwYWdlTWVzc2FnZXM6IFdha3VNZXNzYWdlW10gPSBbXTtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICByZXNwb25zZS5tZXNzYWdlcy5tYXAoYXN5bmMgKHByb3RvTXNnKSA9PiB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYXdhaXQgV2FrdU1lc3NhZ2UuZGVjb2RlUHJvdG8ocHJvdG9Nc2csIGRlY3J5cHRpb25LZXlzKTtcblxuICAgICAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2gobXNnKTtcbiAgICAgICAgICAgIHBhZ2VNZXNzYWdlcy5wdXNoKG1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgbGV0IGFib3J0ID0gZmFsc2U7XG4gICAgICBpZiAob3B0cy5jYWxsYmFjaykge1xuICAgICAgICBhYm9ydCA9IEJvb2xlYW4ob3B0cy5jYWxsYmFjayhwYWdlTWVzc2FnZXMpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2VQYWdlU2l6ZSA9IHJlc3BvbnNlLnBhZ2luZ0luZm8/LnBhZ2VTaXplO1xuICAgICAgY29uc3QgcXVlcnlQYWdlU2l6ZSA9IGhpc3RvcnlScGNRdWVyeS5xdWVyeT8ucGFnaW5nSW5mbz8ucGFnZVNpemU7XG4gICAgICBpZiAoXG4gICAgICAgIGFib3J0IHx8XG4gICAgICAgIC8vIFJlc3BvbnNlIHBhZ2Ugc2l6ZSBzbWFsbGVyIHRoYW4gcXVlcnksIG1lYW5pbmcgdGhpcyBpcyB0aGUgbGFzdCBwYWdlXG4gICAgICAgIChyZXNwb25zZVBhZ2VTaXplICYmIHF1ZXJ5UGFnZVNpemUgJiYgcmVzcG9uc2VQYWdlU2l6ZSA8IHF1ZXJ5UGFnZVNpemUpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgICAgfVxuXG4gICAgICBjdXJzb3IgPSByZXNwb25zZS5wYWdpbmdJbmZvPy5jdXJzb3I7XG4gICAgICBpZiAoY3Vyc29yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHNlcnZlciBkb2VzIG5vdCByZXR1cm4gY3Vyc29yIHRoZW4gdGhlcmUgaXMgYW4gaXNzdWUsXG4gICAgICAgIC8vIE5lZWQgdG8gYWJvcnQgb3Igd2UgZW5kIHVwIGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgY29uc29sZS5sb2coJ05vIGN1cnNvciByZXR1cm5lZCBieSBwZWVyLicpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgZGVjcnlwdGlvbiBrZXkgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzIHJlY2VpdmVkIGluIGFueVxuICAgKiBzdWJzZXF1ZW50IFtbcXVlcnlIaXN0b3J5XV0gY2FsbC4gVGhpcyBjYW4gZWl0aGVyIGJlIGEgcHJpdmF0ZSBrZXkgZm9yXG4gICAqIGFzeW1tZXRyaWMgZW5jcnlwdGlvbiBvciBhIHN5bW1ldHJpYyBrZXkuIFtbV2FrdVN0b3JlXV0gd2lsbCBhdHRlbXB0IHRvXG4gICAqIGRlY3J5cHQgbWVzc2FnZXMgdXNpbmcgYm90aCBtZXRob2RzLlxuICAgKlxuICAgKiBTdHJpbmdzIG11c3QgYmUgaW4gaGV4IGZvcm1hdC5cbiAgICovXG4gIGFkZERlY3J5cHRpb25LZXkoXG4gICAga2V5OiBVaW50OEFycmF5IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7IG1ldGhvZD86IERlY3J5cHRpb25NZXRob2Q7IGNvbnRlbnRUb3BpY3M/OiBzdHJpbmdbXSB9XG4gICk6IHZvaWQge1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMuc2V0KGhleFRvQnVmKGtleSksIG9wdGlvbnMgPz8ge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIGRlY3J5cHRpb24ga2V5IHRoYXQgd2FzIHVzZWQgdG8gYXR0ZW1wdCBkZWNyeXB0aW9uIG9mIG1lc3NhZ2VzXG4gICAqIHJlY2VpdmVkIGluIHN1YnNlcXVlbnQgW1txdWVyeUhpc3RvcnldXSBjYWxscy5cbiAgICpcbiAgICogU3RyaW5ncyBtdXN0IGJlIGluIGhleCBmb3JtYXQuXG4gICAqL1xuICBkZWxldGVEZWNyeXB0aW9uS2V5KGtleTogVWludDhBcnJheSB8IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZGVjcnlwdGlvbktleXMuZGVsZXRlKGhleFRvQnVmKGtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMga25vd24gcGVlcnMgZnJvbSB0aGUgYWRkcmVzcyBib29rIChgbGlicDJwLnBlZXJTdG9yZWApIHRoYXQgc3VwcG9ydFxuICAgKiBzdG9yZSBwcm90b2NvbC4gV2FrdSBtYXkgb3IgIG1heSBub3QgYmUgY3VycmVudGx5IGNvbm5lY3RlZCB0byB0aGVzZSBwZWVycy5cbiAgICovXG4gIGdldCBwZWVycygpOiBQZWVyW10ge1xuICAgIHJldHVybiBnZXRQZWVyc0ZvclByb3RvY29sKHRoaXMubGlicDJwLCBTdG9yZUNvZGVjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmFuZG9tIHBlZXIgdGhhdCBzdXBwb3J0cyBzdG9yZSBwcm90b2NvbCBmcm9tIHRoZSBhZGRyZXNzXG4gICAqIGJvb2sgKGBsaWJwMnAucGVlclN0b3JlYCkuIFdha3UgbWF5IG9yICBtYXkgbm90IGJlIGN1cnJlbnRseSBjb25uZWN0ZWQgdG9cbiAgICogdGhpcyBwZWVyLlxuICAgKi9cbiAgZ2V0IHJhbmRvbVBlZXIoKTogUGVlciB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHNlbGVjdFJhbmRvbVBlZXIodGhpcy5wZWVycyk7XG4gIH1cbn1cbiIsImV4cG9ydCB7IFdha3VNZXNzYWdlIH0gZnJvbSAnLi93YWt1L3YyL21lc3NhZ2UnO1xuXG5leHBvcnQge1xuICBJbmRleCxcbiAgUGFnaW5nSW5mbyxcbiAgUGFnaW5nSW5mb19EaXJlY3Rpb24sXG4gIENvbnRlbnRGaWx0ZXIsXG4gIEhpc3RvcnlRdWVyeSxcbiAgSGlzdG9yeVJlc3BvbnNlLFxuICBIaXN0b3J5UmVzcG9uc2VfRXJyb3IsXG4gIEhpc3RvcnlSUEMsXG59IGZyb20gJy4vd2FrdS92Mi9zdG9yZSc7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgX20wIGZyb20gJ3Byb3RvYnVmanMvbWluaW1hbCc7XG5pbXBvcnQgeyBXYWt1TWVzc2FnZSB9IGZyb20gJy4uLy4uL3dha3UvdjIvbWVzc2FnZSc7XG5cbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSAnd2FrdS52Mic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVzaFJlcXVlc3Qge1xuICBwdWJTdWJUb3BpYzogc3RyaW5nO1xuICBtZXNzYWdlOiBXYWt1TWVzc2FnZSB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQdXNoUmVzcG9uc2Uge1xuICBpc1N1Y2Nlc3M6IGJvb2xlYW47XG4gIGluZm86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQdXNoUlBDIHtcbiAgcmVxdWVzdElkOiBzdHJpbmc7XG4gIHJlcXVlc3Q6IFB1c2hSZXF1ZXN0IHwgdW5kZWZpbmVkO1xuICByZXNwb25zZTogUHVzaFJlc3BvbnNlIHwgdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCYXNlUHVzaFJlcXVlc3QoKTogUHVzaFJlcXVlc3Qge1xuICByZXR1cm4geyBwdWJTdWJUb3BpYzogJycsIG1lc3NhZ2U6IHVuZGVmaW5lZCB9O1xufVxuXG5leHBvcnQgY29uc3QgUHVzaFJlcXVlc3QgPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBQdXNoUmVxdWVzdCxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLnB1YlN1YlRvcGljICE9PSAnJykge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UucHViU3ViVG9waWMpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFdha3VNZXNzYWdlLmVuY29kZShtZXNzYWdlLm1lc3NhZ2UsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogUHVzaFJlcXVlc3Qge1xuICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgX20wLlJlYWRlciA/IGlucHV0IDogbmV3IF9tMC5SZWFkZXIoaW5wdXQpO1xuICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHVzaFJlcXVlc3QoKTtcbiAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIG1lc3NhZ2UucHViU3ViVG9waWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLm1lc3NhZ2UgPSBXYWt1TWVzc2FnZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBQdXNoUmVxdWVzdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHB1YlN1YlRvcGljOiBpc1NldChvYmplY3QucHViU3ViVG9waWMpID8gU3RyaW5nKG9iamVjdC5wdWJTdWJUb3BpYykgOiAnJyxcbiAgICAgIG1lc3NhZ2U6IGlzU2V0KG9iamVjdC5tZXNzYWdlKVxuICAgICAgICA/IFdha3VNZXNzYWdlLmZyb21KU09OKG9iamVjdC5tZXNzYWdlKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBQdXNoUmVxdWVzdCk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5wdWJTdWJUb3BpYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnB1YlN1YlRvcGljID0gbWVzc2FnZS5wdWJTdWJUb3BpYyk7XG4gICAgbWVzc2FnZS5tZXNzYWdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoubWVzc2FnZSA9IG1lc3NhZ2UubWVzc2FnZVxuICAgICAgICA/IFdha3VNZXNzYWdlLnRvSlNPTihtZXNzYWdlLm1lc3NhZ2UpXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxQdXNoUmVxdWVzdD4sIEk+PihcbiAgICBvYmplY3Q6IElcbiAgKTogUHVzaFJlcXVlc3Qge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHVzaFJlcXVlc3QoKTtcbiAgICBtZXNzYWdlLnB1YlN1YlRvcGljID0gb2JqZWN0LnB1YlN1YlRvcGljID8/ICcnO1xuICAgIG1lc3NhZ2UubWVzc2FnZSA9XG4gICAgICBvYmplY3QubWVzc2FnZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5tZXNzYWdlICE9PSBudWxsXG4gICAgICAgID8gV2FrdU1lc3NhZ2UuZnJvbVBhcnRpYWwob2JqZWN0Lm1lc3NhZ2UpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFzZVB1c2hSZXNwb25zZSgpOiBQdXNoUmVzcG9uc2Uge1xuICByZXR1cm4geyBpc1N1Y2Nlc3M6IGZhbHNlLCBpbmZvOiAnJyB9O1xufVxuXG5leHBvcnQgY29uc3QgUHVzaFJlc3BvbnNlID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogUHVzaFJlc3BvbnNlLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UuaXNTdWNjZXNzID09PSB0cnVlKSB7XG4gICAgICB3cml0ZXIudWludDMyKDgpLmJvb2wobWVzc2FnZS5pc1N1Y2Nlc3MpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5pbmZvICE9PSAnJykge1xuICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuaW5mbyk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogUHVzaFJlc3BvbnNlIHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1c2hSZXNwb25zZSgpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbWVzc2FnZS5pc1N1Y2Nlc3MgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5pbmZvID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBQdXNoUmVzcG9uc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBpc1N1Y2Nlc3M6IGlzU2V0KG9iamVjdC5pc1N1Y2Nlc3MpID8gQm9vbGVhbihvYmplY3QuaXNTdWNjZXNzKSA6IGZhbHNlLFxuICAgICAgaW5mbzogaXNTZXQob2JqZWN0LmluZm8pID8gU3RyaW5nKG9iamVjdC5pbmZvKSA6ICcnLFxuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IFB1c2hSZXNwb25zZSk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5pc1N1Y2Nlc3MgIT09IHVuZGVmaW5lZCAmJiAob2JqLmlzU3VjY2VzcyA9IG1lc3NhZ2UuaXNTdWNjZXNzKTtcbiAgICBtZXNzYWdlLmluZm8gIT09IHVuZGVmaW5lZCAmJiAob2JqLmluZm8gPSBtZXNzYWdlLmluZm8pO1xuICAgIHJldHVybiBvYmo7XG4gIH0sXG5cbiAgZnJvbVBhcnRpYWw8SSBleHRlbmRzIEV4YWN0PERlZXBQYXJ0aWFsPFB1c2hSZXNwb25zZT4sIEk+PihcbiAgICBvYmplY3Q6IElcbiAgKTogUHVzaFJlc3BvbnNlIHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1c2hSZXNwb25zZSgpO1xuICAgIG1lc3NhZ2UuaXNTdWNjZXNzID0gb2JqZWN0LmlzU3VjY2VzcyA/PyBmYWxzZTtcbiAgICBtZXNzYWdlLmluZm8gPSBvYmplY3QuaW5mbyA/PyAnJztcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQdXNoUlBDKCk6IFB1c2hSUEMge1xuICByZXR1cm4geyByZXF1ZXN0SWQ6ICcnLCByZXF1ZXN0OiB1bmRlZmluZWQsIHJlc3BvbnNlOiB1bmRlZmluZWQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFB1c2hSUEMgPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBQdXNoUlBDLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UucmVxdWVzdElkICE9PSAnJykge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBQdXNoUmVxdWVzdC5lbmNvZGUobWVzc2FnZS5yZXF1ZXN0LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBQdXNoUmVzcG9uc2UuZW5jb2RlKG1lc3NhZ2UucmVzcG9uc2UsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogUHVzaFJQQyB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdXNoUlBDKCk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdCA9IFB1c2hSZXF1ZXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBtZXNzYWdlLnJlc3BvbnNlID0gUHVzaFJlc3BvbnNlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcblxuICBmcm9tSlNPTihvYmplY3Q6IGFueSk6IFB1c2hSUEMge1xuICAgIHJldHVybiB7XG4gICAgICByZXF1ZXN0SWQ6IGlzU2V0KG9iamVjdC5yZXF1ZXN0SWQpID8gU3RyaW5nKG9iamVjdC5yZXF1ZXN0SWQpIDogJycsXG4gICAgICByZXF1ZXN0OiBpc1NldChvYmplY3QucmVxdWVzdClcbiAgICAgICAgPyBQdXNoUmVxdWVzdC5mcm9tSlNPTihvYmplY3QucmVxdWVzdClcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICByZXNwb25zZTogaXNTZXQob2JqZWN0LnJlc3BvbnNlKVxuICAgICAgICA/IFB1c2hSZXNwb25zZS5mcm9tSlNPTihvYmplY3QucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IFB1c2hSUEMpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucmVxdWVzdElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5yZXF1ZXN0SWQgPSBtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgbWVzc2FnZS5yZXF1ZXN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucmVxdWVzdCA9IG1lc3NhZ2UucmVxdWVzdFxuICAgICAgICA/IFB1c2hSZXF1ZXN0LnRvSlNPTihtZXNzYWdlLnJlcXVlc3QpXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICBtZXNzYWdlLnJlc3BvbnNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucmVzcG9uc2UgPSBtZXNzYWdlLnJlc3BvbnNlXG4gICAgICAgID8gUHVzaFJlc3BvbnNlLnRvSlNPTihtZXNzYWdlLnJlc3BvbnNlKVxuICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbDxJIGV4dGVuZHMgRXhhY3Q8RGVlcFBhcnRpYWw8UHVzaFJQQz4sIEk+PihvYmplY3Q6IEkpOiBQdXNoUlBDIHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1c2hSUEMoKTtcbiAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IG9iamVjdC5yZXF1ZXN0SWQgPz8gJyc7XG4gICAgbWVzc2FnZS5yZXF1ZXN0ID1cbiAgICAgIG9iamVjdC5yZXF1ZXN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlcXVlc3QgIT09IG51bGxcbiAgICAgICAgPyBQdXNoUmVxdWVzdC5mcm9tUGFydGlhbChvYmplY3QucmVxdWVzdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS5yZXNwb25zZSA9XG4gICAgICBvYmplY3QucmVzcG9uc2UgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucmVzcG9uc2UgIT09IG51bGxcbiAgICAgICAgPyBQdXNoUmVzcG9uc2UuZnJvbVBhcnRpYWwob2JqZWN0LnJlc3BvbnNlKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbnR5cGUgQnVpbHRpbiA9XG4gIHwgRGF0ZVxuICB8IEZ1bmN0aW9uXG4gIHwgVWludDhBcnJheVxuICB8IHN0cmluZ1xuICB8IG51bWJlclxuICB8IGJvb2xlYW5cbiAgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCB0eXBlIERlZXBQYXJ0aWFsPFQ+ID0gVCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBUXG4gIDogVCBleHRlbmRzIEFycmF5PGluZmVyIFU+XG4gID8gQXJyYXk8RGVlcFBhcnRpYWw8VT4+XG4gIDogVCBleHRlbmRzIFJlYWRvbmx5QXJyYXk8aW5mZXIgVT5cbiAgPyBSZWFkb25seUFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyB7fVxuICA/IHsgW0sgaW4ga2V5b2YgVF0/OiBEZWVwUGFydGlhbDxUW0tdPiB9XG4gIDogUGFydGlhbDxUPjtcblxudHlwZSBLZXlzT2ZVbmlvbjxUPiA9IFQgZXh0ZW5kcyBUID8ga2V5b2YgVCA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgRXhhY3Q8UCwgSSBleHRlbmRzIFA+ID0gUCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBQXG4gIDogUCAmIHsgW0sgaW4ga2V5b2YgUF06IEV4YWN0PFBbS10sIElbS10+IH0gJiBSZWNvcmQ8XG4gICAgICAgIEV4Y2x1ZGU8a2V5b2YgSSwgS2V5c09mVW5pb248UD4+LFxuICAgICAgICBuZXZlclxuICAgICAgPjtcblxuaWYgKF9tMC51dGlsLkxvbmcgIT09IExvbmcpIHtcbiAgX20wLnV0aWwuTG9uZyA9IExvbmcgYXMgYW55O1xuICBfbTAuY29uZmlndXJlKCk7XG59XG5cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlOiBhbnkpOiBib29sZWFuIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IExvbmcgZnJvbSAnbG9uZyc7XG5pbXBvcnQgX20wIGZyb20gJ3Byb3RvYnVmanMvbWluaW1hbCc7XG5cbmV4cG9ydCBjb25zdCBwcm90b2J1ZlBhY2thZ2UgPSAnd2FrdS52Mic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2FrdU1lc3NhZ2Uge1xuICBwYXlsb2FkPzogVWludDhBcnJheSB8IHVuZGVmaW5lZDtcbiAgY29udGVudFRvcGljPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB2ZXJzaW9uPzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICB0aW1lc3RhbXA/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VXYWt1TWVzc2FnZSgpOiBXYWt1TWVzc2FnZSB7XG4gIHJldHVybiB7XG4gICAgcGF5bG9hZDogdW5kZWZpbmVkLFxuICAgIGNvbnRlbnRUb3BpYzogdW5kZWZpbmVkLFxuICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICB0aW1lc3RhbXA6IHVuZGVmaW5lZCxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFdha3VNZXNzYWdlID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogV2FrdU1lc3NhZ2UsXG4gICAgd3JpdGVyOiBfbTAuV3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKVxuICApOiBfbTAuV3JpdGVyIHtcbiAgICBpZiAobWVzc2FnZS5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UucGF5bG9hZCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5jb250ZW50VG9waWMpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS52ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQzMihtZXNzYWdlLnZlcnNpb24pO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigzMykuZG91YmxlKG1lc3NhZ2UudGltZXN0YW1wKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBXYWt1TWVzc2FnZSB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXYWt1TWVzc2FnZSgpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbWVzc2FnZS5wYXlsb2FkID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBXYWt1TWVzc2FnZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBheWxvYWQ6IGlzU2V0KG9iamVjdC5wYXlsb2FkKVxuICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QucGF5bG9hZClcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBjb250ZW50VG9waWM6IGlzU2V0KG9iamVjdC5jb250ZW50VG9waWMpXG4gICAgICAgID8gU3RyaW5nKG9iamVjdC5jb250ZW50VG9waWMpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgdmVyc2lvbjogaXNTZXQob2JqZWN0LnZlcnNpb24pID8gTnVtYmVyKG9iamVjdC52ZXJzaW9uKSA6IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVzdGFtcDogaXNTZXQob2JqZWN0LnRpbWVzdGFtcCkgPyBOdW1iZXIob2JqZWN0LnRpbWVzdGFtcCkgOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogV2FrdU1lc3NhZ2UpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucGF5bG9hZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnBheWxvYWQgPVxuICAgICAgICBtZXNzYWdlLnBheWxvYWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucGF5bG9hZClcbiAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgbWVzc2FnZS5jb250ZW50VG9waWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5jb250ZW50VG9waWMgPSBtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgbWVzc2FnZS52ZXJzaW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoudmVyc2lvbiA9IE1hdGgucm91bmQobWVzc2FnZS52ZXJzaW9uKSk7XG4gICAgbWVzc2FnZS50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxXYWt1TWVzc2FnZT4sIEk+PihcbiAgICBvYmplY3Q6IElcbiAgKTogV2FrdU1lc3NhZ2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV2FrdU1lc3NhZ2UoKTtcbiAgICBtZXNzYWdlLnBheWxvYWQgPSBvYmplY3QucGF5bG9hZCA/PyB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS5jb250ZW50VG9waWMgPSBvYmplY3QuY29udGVudFRvcGljID8/IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLnZlcnNpb24gPSBvYmplY3QudmVyc2lvbiA/PyB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS50aW1lc3RhbXAgPSBvYmplY3QudGltZXN0YW1wID8/IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmRlY2xhcmUgdmFyIHNlbGY6IGFueSB8IHVuZGVmaW5lZDtcbmRlY2xhcmUgdmFyIHdpbmRvdzogYW55IHwgdW5kZWZpbmVkO1xuZGVjbGFyZSB2YXIgZ2xvYmFsOiBhbnkgfCB1bmRlZmluZWQ7XG52YXIgZ2xvYmFsVGhpczogYW55ID0gKCgpID0+IHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGdsb2JhbFRoaXM7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBzZWxmO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiB3aW5kb3c7XG4gIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGdsb2JhbDtcbiAgdGhyb3cgJ1VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCc7XG59KSgpO1xuXG5jb25zdCBhdG9iOiAoYjY0OiBzdHJpbmcpID0+IHN0cmluZyA9XG4gIGdsb2JhbFRoaXMuYXRvYiB8fFxuICAoKGI2NCkgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsICdiYXNlNjQnKS50b1N0cmluZygnYmluYXJ5JykpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuY29uc3QgYnRvYTogKGJpbjogc3RyaW5nKSA9PiBzdHJpbmcgPVxuICBnbG9iYWxUaGlzLmJ0b2EgfHxcbiAgKChiaW4pID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYmluLCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnI6IFVpbnQ4QXJyYXkpOiBzdHJpbmcge1xuICBjb25zdCBiaW46IHN0cmluZ1tdID0gW107XG4gIGZvciAoY29uc3QgYnl0ZSBvZiBhcnIpIHtcbiAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgfVxuICByZXR1cm4gYnRvYShiaW4uam9pbignJykpO1xufVxuXG50eXBlIEJ1aWx0aW4gPVxuICB8IERhdGVcbiAgfCBGdW5jdGlvblxuICB8IFVpbnQ4QXJyYXlcbiAgfCBzdHJpbmdcbiAgfCBudW1iZXJcbiAgfCBib29sZWFuXG4gIHwgdW5kZWZpbmVkO1xuXG5leHBvcnQgdHlwZSBEZWVwUGFydGlhbDxUPiA9IFQgZXh0ZW5kcyBCdWlsdGluXG4gID8gVFxuICA6IFQgZXh0ZW5kcyBBcnJheTxpbmZlciBVPlxuICA/IEFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyBSZWFkb25seUFycmF5PGluZmVyIFU+XG4gID8gUmVhZG9ubHlBcnJheTxEZWVwUGFydGlhbDxVPj5cbiAgOiBUIGV4dGVuZHMge31cbiAgPyB7IFtLIGluIGtleW9mIFRdPzogRGVlcFBhcnRpYWw8VFtLXT4gfVxuICA6IFBhcnRpYWw8VD47XG5cbnR5cGUgS2V5c09mVW5pb248VD4gPSBUIGV4dGVuZHMgVCA/IGtleW9mIFQgOiBuZXZlcjtcbmV4cG9ydCB0eXBlIEV4YWN0PFAsIEkgZXh0ZW5kcyBQPiA9IFAgZXh0ZW5kcyBCdWlsdGluXG4gID8gUFxuICA6IFAgJiB7IFtLIGluIGtleW9mIFBdOiBFeGFjdDxQW0tdLCBJW0tdPiB9ICYgUmVjb3JkPFxuICAgICAgICBFeGNsdWRlPGtleW9mIEksIEtleXNPZlVuaW9uPFA+PixcbiAgICAgICAgbmV2ZXJcbiAgICAgID47XG5cbmlmIChfbTAudXRpbC5Mb25nICE9PSBMb25nKSB7XG4gIF9tMC51dGlsLkxvbmcgPSBMb25nIGFzIGFueTtcbiAgX20wLmNvbmZpZ3VyZSgpO1xufVxuXG5mdW5jdGlvbiBpc1NldCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCBMb25nIGZyb20gJ2xvbmcnO1xuaW1wb3J0IF9tMCBmcm9tICdwcm90b2J1ZmpzL21pbmltYWwnO1xuaW1wb3J0IHsgV2FrdU1lc3NhZ2UgfSBmcm9tICcuLi8uLi93YWt1L3YyL21lc3NhZ2UnO1xuXG5leHBvcnQgY29uc3QgcHJvdG9idWZQYWNrYWdlID0gJ3dha3UudjInO1xuXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4IHtcbiAgZGlnZXN0OiBVaW50OEFycmF5O1xuICByZWNlaXZlZFRpbWU6IG51bWJlcjtcbiAgc2VuZGVyVGltZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2luZ0luZm8ge1xuICBwYWdlU2l6ZTogbnVtYmVyO1xuICBjdXJzb3I6IEluZGV4IHwgdW5kZWZpbmVkO1xuICBkaXJlY3Rpb246IFBhZ2luZ0luZm9fRGlyZWN0aW9uO1xufVxuXG5leHBvcnQgZW51bSBQYWdpbmdJbmZvX0RpcmVjdGlvbiB7XG4gIERJUkVDVElPTl9CQUNLV0FSRF9VTlNQRUNJRklFRCA9IDAsXG4gIERJUkVDVElPTl9GT1JXQVJEID0gMSxcbiAgVU5SRUNPR05JWkVEID0gLTEsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWdpbmdJbmZvX0RpcmVjdGlvbkZyb21KU09OKFxuICBvYmplY3Q6IGFueVxuKTogUGFnaW5nSW5mb19EaXJlY3Rpb24ge1xuICBzd2l0Y2ggKG9iamVjdCkge1xuICAgIGNhc2UgMDpcbiAgICBjYXNlICdESVJFQ1RJT05fQkFDS1dBUkRfVU5TUEVDSUZJRUQnOlxuICAgICAgcmV0dXJuIFBhZ2luZ0luZm9fRGlyZWN0aW9uLkRJUkVDVElPTl9CQUNLV0FSRF9VTlNQRUNJRklFRDtcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAnRElSRUNUSU9OX0ZPUldBUkQnOlxuICAgICAgcmV0dXJuIFBhZ2luZ0luZm9fRGlyZWN0aW9uLkRJUkVDVElPTl9GT1JXQVJEO1xuICAgIGNhc2UgLTE6XG4gICAgY2FzZSAnVU5SRUNPR05JWkVEJzpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFBhZ2luZ0luZm9fRGlyZWN0aW9uLlVOUkVDT0dOSVpFRDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFnaW5nSW5mb19EaXJlY3Rpb25Ub0pTT04oXG4gIG9iamVjdDogUGFnaW5nSW5mb19EaXJlY3Rpb25cbik6IHN0cmluZyB7XG4gIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgY2FzZSBQYWdpbmdJbmZvX0RpcmVjdGlvbi5ESVJFQ1RJT05fQkFDS1dBUkRfVU5TUEVDSUZJRUQ6XG4gICAgICByZXR1cm4gJ0RJUkVDVElPTl9CQUNLV0FSRF9VTlNQRUNJRklFRCc7XG4gICAgY2FzZSBQYWdpbmdJbmZvX0RpcmVjdGlvbi5ESVJFQ1RJT05fRk9SV0FSRDpcbiAgICAgIHJldHVybiAnRElSRUNUSU9OX0ZPUldBUkQnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ1VOS05PV04nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudEZpbHRlciB7XG4gIGNvbnRlbnRUb3BpYzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlRdWVyeSB7XG4gIHB1YlN1YlRvcGljPzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBjb250ZW50RmlsdGVyczogQ29udGVudEZpbHRlcltdO1xuICBwYWdpbmdJbmZvPzogUGFnaW5nSW5mbyB8IHVuZGVmaW5lZDtcbiAgc3RhcnRUaW1lPzogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICBlbmRUaW1lPzogbnVtYmVyIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpc3RvcnlSZXNwb25zZSB7XG4gIG1lc3NhZ2VzOiBXYWt1TWVzc2FnZVtdO1xuICBwYWdpbmdJbmZvOiBQYWdpbmdJbmZvIHwgdW5kZWZpbmVkO1xuICBlcnJvcjogSGlzdG9yeVJlc3BvbnNlX0Vycm9yO1xufVxuXG5leHBvcnQgZW51bSBIaXN0b3J5UmVzcG9uc2VfRXJyb3Ige1xuICBFUlJPUl9OT05FX1VOU1BFQ0lGSUVEID0gMCxcbiAgRVJST1JfSU5WQUxJRF9DVVJTT1IgPSAxLFxuICBVTlJFQ09HTklaRUQgPSAtMSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpc3RvcnlSZXNwb25zZV9FcnJvckZyb21KU09OKFxuICBvYmplY3Q6IGFueVxuKTogSGlzdG9yeVJlc3BvbnNlX0Vycm9yIHtcbiAgc3dpdGNoIChvYmplY3QpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAnRVJST1JfTk9ORV9VTlNQRUNJRklFRCc6XG4gICAgICByZXR1cm4gSGlzdG9yeVJlc3BvbnNlX0Vycm9yLkVSUk9SX05PTkVfVU5TUEVDSUZJRUQ7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgJ0VSUk9SX0lOVkFMSURfQ1VSU09SJzpcbiAgICAgIHJldHVybiBIaXN0b3J5UmVzcG9uc2VfRXJyb3IuRVJST1JfSU5WQUxJRF9DVVJTT1I7XG4gICAgY2FzZSAtMTpcbiAgICBjYXNlICdVTlJFQ09HTklaRUQnOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSGlzdG9yeVJlc3BvbnNlX0Vycm9yLlVOUkVDT0dOSVpFRDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlzdG9yeVJlc3BvbnNlX0Vycm9yVG9KU09OKFxuICBvYmplY3Q6IEhpc3RvcnlSZXNwb25zZV9FcnJvclxuKTogc3RyaW5nIHtcbiAgc3dpdGNoIChvYmplY3QpIHtcbiAgICBjYXNlIEhpc3RvcnlSZXNwb25zZV9FcnJvci5FUlJPUl9OT05FX1VOU1BFQ0lGSUVEOlxuICAgICAgcmV0dXJuICdFUlJPUl9OT05FX1VOU1BFQ0lGSUVEJztcbiAgICBjYXNlIEhpc3RvcnlSZXNwb25zZV9FcnJvci5FUlJPUl9JTlZBTElEX0NVUlNPUjpcbiAgICAgIHJldHVybiAnRVJST1JfSU5WQUxJRF9DVVJTT1InO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ1VOS05PV04nO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGlzdG9yeVJQQyB7XG4gIHJlcXVlc3RJZDogc3RyaW5nO1xuICBxdWVyeTogSGlzdG9yeVF1ZXJ5IHwgdW5kZWZpbmVkO1xuICByZXNwb25zZTogSGlzdG9yeVJlc3BvbnNlIHwgdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCYXNlSW5kZXgoKTogSW5kZXgge1xuICByZXR1cm4geyBkaWdlc3Q6IG5ldyBVaW50OEFycmF5KCksIHJlY2VpdmVkVGltZTogMCwgc2VuZGVyVGltZTogMCB9O1xufVxuXG5leHBvcnQgY29uc3QgSW5kZXggPSB7XG4gIGVuY29kZShtZXNzYWdlOiBJbmRleCwgd3JpdGVyOiBfbTAuV3JpdGVyID0gX20wLldyaXRlci5jcmVhdGUoKSk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLmRpZ2VzdC5sZW5ndGggIT09IDApIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuZGlnZXN0KTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucmVjZWl2ZWRUaW1lICE9PSAwKSB7XG4gICAgICB3cml0ZXIudWludDMyKDE3KS5kb3VibGUobWVzc2FnZS5yZWNlaXZlZFRpbWUpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5zZW5kZXJUaW1lICE9PSAwKSB7XG4gICAgICB3cml0ZXIudWludDMyKDI1KS5kb3VibGUobWVzc2FnZS5zZW5kZXJUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlcjtcbiAgfSxcblxuICBkZWNvZGUoaW5wdXQ6IF9tMC5SZWFkZXIgfCBVaW50OEFycmF5LCBsZW5ndGg/OiBudW1iZXIpOiBJbmRleCB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VJbmRleCgpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbWVzc2FnZS5kaWdlc3QgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UucmVjZWl2ZWRUaW1lID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS5zZW5kZXJUaW1lID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBJbmRleCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpZ2VzdDogaXNTZXQob2JqZWN0LmRpZ2VzdClcbiAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmRpZ2VzdClcbiAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgcmVjZWl2ZWRUaW1lOiBpc1NldChvYmplY3QucmVjZWl2ZWRUaW1lKVxuICAgICAgICA/IE51bWJlcihvYmplY3QucmVjZWl2ZWRUaW1lKVxuICAgICAgICA6IDAsXG4gICAgICBzZW5kZXJUaW1lOiBpc1NldChvYmplY3Quc2VuZGVyVGltZSkgPyBOdW1iZXIob2JqZWN0LnNlbmRlclRpbWUpIDogMCxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBJbmRleCk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5kaWdlc3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5kaWdlc3QgPSBiYXNlNjRGcm9tQnl0ZXMoXG4gICAgICAgIG1lc3NhZ2UuZGlnZXN0ICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmRpZ2VzdCA6IG5ldyBVaW50OEFycmF5KClcbiAgICAgICkpO1xuICAgIG1lc3NhZ2UucmVjZWl2ZWRUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucmVjZWl2ZWRUaW1lID0gbWVzc2FnZS5yZWNlaXZlZFRpbWUpO1xuICAgIG1lc3NhZ2Uuc2VuZGVyVGltZSAhPT0gdW5kZWZpbmVkICYmIChvYmouc2VuZGVyVGltZSA9IG1lc3NhZ2Uuc2VuZGVyVGltZSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbDxJIGV4dGVuZHMgRXhhY3Q8RGVlcFBhcnRpYWw8SW5kZXg+LCBJPj4ob2JqZWN0OiBJKTogSW5kZXgge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW5kZXgoKTtcbiAgICBtZXNzYWdlLmRpZ2VzdCA9IG9iamVjdC5kaWdlc3QgPz8gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICBtZXNzYWdlLnJlY2VpdmVkVGltZSA9IG9iamVjdC5yZWNlaXZlZFRpbWUgPz8gMDtcbiAgICBtZXNzYWdlLnNlbmRlclRpbWUgPSBvYmplY3Quc2VuZGVyVGltZSA/PyAwO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFzZVBhZ2luZ0luZm8oKTogUGFnaW5nSW5mbyB7XG4gIHJldHVybiB7IHBhZ2VTaXplOiAwLCBjdXJzb3I6IHVuZGVmaW5lZCwgZGlyZWN0aW9uOiAwIH07XG59XG5cbmV4cG9ydCBjb25zdCBQYWdpbmdJbmZvID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogUGFnaW5nSW5mbyxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLnBhZ2VTaXplICE9PSAwKSB7XG4gICAgICB3cml0ZXIudWludDMyKDgpLnVpbnQ2NChtZXNzYWdlLnBhZ2VTaXplKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuY3Vyc29yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIEluZGV4LmVuY29kZShtZXNzYWdlLmN1cnNvciwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UuZGlyZWN0aW9uICE9PSAwKSB7XG4gICAgICB3cml0ZXIudWludDMyKDI0KS5pbnQzMihtZXNzYWdlLmRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogUGFnaW5nSW5mbyB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQYWdpbmdJbmZvKCk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLnBhZ2VTaXplID0gbG9uZ1RvTnVtYmVyKHJlYWRlci51aW50NjQoKSBhcyBMb25nKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UuY3Vyc29yID0gSW5kZXguZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2UuZGlyZWN0aW9uID0gcmVhZGVyLmludDMyKCkgYXMgYW55O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG5cbiAgZnJvbUpTT04ob2JqZWN0OiBhbnkpOiBQYWdpbmdJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFnZVNpemU6IGlzU2V0KG9iamVjdC5wYWdlU2l6ZSkgPyBOdW1iZXIob2JqZWN0LnBhZ2VTaXplKSA6IDAsXG4gICAgICBjdXJzb3I6IGlzU2V0KG9iamVjdC5jdXJzb3IpID8gSW5kZXguZnJvbUpTT04ob2JqZWN0LmN1cnNvcikgOiB1bmRlZmluZWQsXG4gICAgICBkaXJlY3Rpb246IGlzU2V0KG9iamVjdC5kaXJlY3Rpb24pXG4gICAgICAgID8gcGFnaW5nSW5mb19EaXJlY3Rpb25Gcm9tSlNPTihvYmplY3QuZGlyZWN0aW9uKVxuICAgICAgICA6IDAsXG4gICAgfTtcbiAgfSxcblxuICB0b0pTT04obWVzc2FnZTogUGFnaW5nSW5mbyk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgbWVzc2FnZS5wYWdlU2l6ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnBhZ2VTaXplID0gTWF0aC5yb3VuZChtZXNzYWdlLnBhZ2VTaXplKSk7XG4gICAgbWVzc2FnZS5jdXJzb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5jdXJzb3IgPSBtZXNzYWdlLmN1cnNvciA/IEluZGV4LnRvSlNPTihtZXNzYWdlLmN1cnNvcikgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UuZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmouZGlyZWN0aW9uID0gcGFnaW5nSW5mb19EaXJlY3Rpb25Ub0pTT04obWVzc2FnZS5kaXJlY3Rpb24pKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxQYWdpbmdJbmZvPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBQYWdpbmdJbmZvIHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBhZ2luZ0luZm8oKTtcbiAgICBtZXNzYWdlLnBhZ2VTaXplID0gb2JqZWN0LnBhZ2VTaXplID8/IDA7XG4gICAgbWVzc2FnZS5jdXJzb3IgPVxuICAgICAgb2JqZWN0LmN1cnNvciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jdXJzb3IgIT09IG51bGxcbiAgICAgICAgPyBJbmRleC5mcm9tUGFydGlhbChvYmplY3QuY3Vyc29yKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLmRpcmVjdGlvbiA9IG9iamVjdC5kaXJlY3Rpb24gPz8gMDtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb250ZW50RmlsdGVyKCk6IENvbnRlbnRGaWx0ZXIge1xuICByZXR1cm4geyBjb250ZW50VG9waWM6ICcnIH07XG59XG5cbmV4cG9ydCBjb25zdCBDb250ZW50RmlsdGVyID0ge1xuICBlbmNvZGUoXG4gICAgbWVzc2FnZTogQ29udGVudEZpbHRlcixcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gJycpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmNvbnRlbnRUb3BpYyk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogQ29udGVudEZpbHRlciB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250ZW50RmlsdGVyKCk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogQ29udGVudEZpbHRlciB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnRUb3BpYzogaXNTZXQob2JqZWN0LmNvbnRlbnRUb3BpYylcbiAgICAgICAgPyBTdHJpbmcob2JqZWN0LmNvbnRlbnRUb3BpYylcbiAgICAgICAgOiAnJyxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBDb250ZW50RmlsdGVyKTogdW5rbm93biB7XG4gICAgY29uc3Qgb2JqOiBhbnkgPSB7fTtcbiAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLmNvbnRlbnRUb3BpYyA9IG1lc3NhZ2UuY29udGVudFRvcGljKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxDb250ZW50RmlsdGVyPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBDb250ZW50RmlsdGVyIHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnRlbnRGaWx0ZXIoKTtcbiAgICBtZXNzYWdlLmNvbnRlbnRUb3BpYyA9IG9iamVjdC5jb250ZW50VG9waWMgPz8gJyc7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVCYXNlSGlzdG9yeVF1ZXJ5KCk6IEhpc3RvcnlRdWVyeSB7XG4gIHJldHVybiB7XG4gICAgcHViU3ViVG9waWM6IHVuZGVmaW5lZCxcbiAgICBjb250ZW50RmlsdGVyczogW10sXG4gICAgcGFnaW5nSW5mbzogdW5kZWZpbmVkLFxuICAgIHN0YXJ0VGltZTogdW5kZWZpbmVkLFxuICAgIGVuZFRpbWU6IHVuZGVmaW5lZCxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEhpc3RvcnlRdWVyeSA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IEhpc3RvcnlRdWVyeSxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGlmIChtZXNzYWdlLnB1YlN1YlRvcGljICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnB1YlN1YlRvcGljKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuY29udGVudEZpbHRlcnMpIHtcbiAgICAgIENvbnRlbnRGaWx0ZXIuZW5jb2RlKHYhLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIFBhZ2luZ0luZm8uZW5jb2RlKG1lc3NhZ2UucGFnaW5nSW5mbywgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2Uuc3RhcnRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHdyaXRlci51aW50MzIoNDEpLmRvdWJsZShtZXNzYWdlLnN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLmVuZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgd3JpdGVyLnVpbnQzMig0OSkuZG91YmxlKG1lc3NhZ2UuZW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSGlzdG9yeVF1ZXJ5IHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUhpc3RvcnlRdWVyeSgpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5wdWJTdWJUb3BpYyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2UuY29udGVudEZpbHRlcnMucHVzaChcbiAgICAgICAgICAgIENvbnRlbnRGaWx0ZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPSBQYWdpbmdJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBtZXNzYWdlLnN0YXJ0VGltZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIG1lc3NhZ2UuZW5kVGltZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogSGlzdG9yeVF1ZXJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgcHViU3ViVG9waWM6IGlzU2V0KG9iamVjdC5wdWJTdWJUb3BpYylcbiAgICAgICAgPyBTdHJpbmcob2JqZWN0LnB1YlN1YlRvcGljKVxuICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgIGNvbnRlbnRGaWx0ZXJzOiBBcnJheS5pc0FycmF5KG9iamVjdD8uY29udGVudEZpbHRlcnMpXG4gICAgICAgID8gb2JqZWN0LmNvbnRlbnRGaWx0ZXJzLm1hcCgoZTogYW55KSA9PiBDb250ZW50RmlsdGVyLmZyb21KU09OKGUpKVxuICAgICAgICA6IFtdLFxuICAgICAgcGFnaW5nSW5mbzogaXNTZXQob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgID8gUGFnaW5nSW5mby5mcm9tSlNPTihvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBzdGFydFRpbWU6IGlzU2V0KG9iamVjdC5zdGFydFRpbWUpID8gTnVtYmVyKG9iamVjdC5zdGFydFRpbWUpIDogdW5kZWZpbmVkLFxuICAgICAgZW5kVGltZTogaXNTZXQob2JqZWN0LmVuZFRpbWUpID8gTnVtYmVyKG9iamVjdC5lbmRUaW1lKSA6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9LFxuXG4gIHRvSlNPTihtZXNzYWdlOiBIaXN0b3J5UXVlcnkpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucHViU3ViVG9waWMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5wdWJTdWJUb3BpYyA9IG1lc3NhZ2UucHViU3ViVG9waWMpO1xuICAgIGlmIChtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzKSB7XG4gICAgICBvYmouY29udGVudEZpbHRlcnMgPSBtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzLm1hcCgoZSkgPT5cbiAgICAgICAgZSA/IENvbnRlbnRGaWx0ZXIudG9KU09OKGUpIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmouY29udGVudEZpbHRlcnMgPSBbXTtcbiAgICB9XG4gICAgbWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucGFnaW5nSW5mbyA9IG1lc3NhZ2UucGFnaW5nSW5mb1xuICAgICAgICA/IFBhZ2luZ0luZm8udG9KU09OKG1lc3NhZ2UucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2Uuc3RhcnRUaW1lICE9PSB1bmRlZmluZWQgJiYgKG9iai5zdGFydFRpbWUgPSBtZXNzYWdlLnN0YXJ0VGltZSk7XG4gICAgbWVzc2FnZS5lbmRUaW1lICE9PSB1bmRlZmluZWQgJiYgKG9iai5lbmRUaW1lID0gbWVzc2FnZS5lbmRUaW1lKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxIaXN0b3J5UXVlcnk+LCBJPj4oXG4gICAgb2JqZWN0OiBJXG4gICk6IEhpc3RvcnlRdWVyeSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VIaXN0b3J5UXVlcnkoKTtcbiAgICBtZXNzYWdlLnB1YlN1YlRvcGljID0gb2JqZWN0LnB1YlN1YlRvcGljID8/IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLmNvbnRlbnRGaWx0ZXJzID1cbiAgICAgIG9iamVjdC5jb250ZW50RmlsdGVycz8ubWFwKChlKSA9PiBDb250ZW50RmlsdGVyLmZyb21QYXJ0aWFsKGUpKSB8fCBbXTtcbiAgICBtZXNzYWdlLnBhZ2luZ0luZm8gPVxuICAgICAgb2JqZWN0LnBhZ2luZ0luZm8gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucGFnaW5nSW5mbyAhPT0gbnVsbFxuICAgICAgICA/IFBhZ2luZ0luZm8uZnJvbVBhcnRpYWwob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIG1lc3NhZ2Uuc3RhcnRUaW1lID0gb2JqZWN0LnN0YXJ0VGltZSA/PyB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS5lbmRUaW1lID0gb2JqZWN0LmVuZFRpbWUgPz8gdW5kZWZpbmVkO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFzZUhpc3RvcnlSZXNwb25zZSgpOiBIaXN0b3J5UmVzcG9uc2Uge1xuICByZXR1cm4geyBtZXNzYWdlczogW10sIHBhZ2luZ0luZm86IHVuZGVmaW5lZCwgZXJyb3I6IDAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEhpc3RvcnlSZXNwb25zZSA9IHtcbiAgZW5jb2RlKFxuICAgIG1lc3NhZ2U6IEhpc3RvcnlSZXNwb25zZSxcbiAgICB3cml0ZXI6IF9tMC5Xcml0ZXIgPSBfbTAuV3JpdGVyLmNyZWF0ZSgpXG4gICk6IF9tMC5Xcml0ZXIge1xuICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICBXYWt1TWVzc2FnZS5lbmNvZGUodiEsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgfVxuICAgIGlmIChtZXNzYWdlLnBhZ2luZ0luZm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgUGFnaW5nSW5mby5lbmNvZGUobWVzc2FnZS5wYWdpbmdJbmZvLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5lcnJvciAhPT0gMCkge1xuICAgICAgd3JpdGVyLnVpbnQzMigzMikuaW50MzIobWVzc2FnZS5lcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSGlzdG9yeVJlc3BvbnNlIHtcbiAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIF9tMC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBfbTAuUmVhZGVyKGlucHV0KTtcbiAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUhpc3RvcnlSZXNwb25zZSgpO1xuICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbWVzc2FnZS5tZXNzYWdlcy5wdXNoKFdha3VNZXNzYWdlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgbWVzc2FnZS5wYWdpbmdJbmZvID0gUGFnaW5nSW5mby5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgbWVzc2FnZS5lcnJvciA9IHJlYWRlci5pbnQzMigpIGFzIGFueTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogSGlzdG9yeVJlc3BvbnNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0Py5tZXNzYWdlcylcbiAgICAgICAgPyBvYmplY3QubWVzc2FnZXMubWFwKChlOiBhbnkpID0+IFdha3VNZXNzYWdlLmZyb21KU09OKGUpKVxuICAgICAgICA6IFtdLFxuICAgICAgcGFnaW5nSW5mbzogaXNTZXQob2JqZWN0LnBhZ2luZ0luZm8pXG4gICAgICAgID8gUGFnaW5nSW5mby5mcm9tSlNPTihvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBlcnJvcjogaXNTZXQob2JqZWN0LmVycm9yKVxuICAgICAgICA/IGhpc3RvcnlSZXNwb25zZV9FcnJvckZyb21KU09OKG9iamVjdC5lcnJvcilcbiAgICAgICAgOiAwLFxuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IEhpc3RvcnlSZXNwb25zZSk6IHVua25vd24ge1xuICAgIGNvbnN0IG9iajogYW55ID0ge307XG4gICAgaWYgKG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgIG9iai5tZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMubWFwKChlKSA9PlxuICAgICAgICBlID8gV2FrdU1lc3NhZ2UudG9KU09OKGUpIDogdW5kZWZpbmVkXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmoubWVzc2FnZXMgPSBbXTtcbiAgICB9XG4gICAgbWVzc2FnZS5wYWdpbmdJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIChvYmoucGFnaW5nSW5mbyA9IG1lc3NhZ2UucGFnaW5nSW5mb1xuICAgICAgICA/IFBhZ2luZ0luZm8udG9KU09OKG1lc3NhZ2UucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UuZXJyb3IgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5lcnJvciA9IGhpc3RvcnlSZXNwb25zZV9FcnJvclRvSlNPTihtZXNzYWdlLmVycm9yKSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfSxcblxuICBmcm9tUGFydGlhbDxJIGV4dGVuZHMgRXhhY3Q8RGVlcFBhcnRpYWw8SGlzdG9yeVJlc3BvbnNlPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBIaXN0b3J5UmVzcG9uc2Uge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGlzdG9yeVJlc3BvbnNlKCk7XG4gICAgbWVzc2FnZS5tZXNzYWdlcyA9XG4gICAgICBvYmplY3QubWVzc2FnZXM/Lm1hcCgoZSkgPT4gV2FrdU1lc3NhZ2UuZnJvbVBhcnRpYWwoZSkpIHx8IFtdO1xuICAgIG1lc3NhZ2UucGFnaW5nSW5mbyA9XG4gICAgICBvYmplY3QucGFnaW5nSW5mbyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wYWdpbmdJbmZvICE9PSBudWxsXG4gICAgICAgID8gUGFnaW5nSW5mby5mcm9tUGFydGlhbChvYmplY3QucGFnaW5nSW5mbylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZS5lcnJvciA9IG9iamVjdC5lcnJvciA/PyAwO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuZnVuY3Rpb24gY3JlYXRlQmFzZUhpc3RvcnlSUEMoKTogSGlzdG9yeVJQQyB7XG4gIHJldHVybiB7IHJlcXVlc3RJZDogJycsIHF1ZXJ5OiB1bmRlZmluZWQsIHJlc3BvbnNlOiB1bmRlZmluZWQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEhpc3RvcnlSUEMgPSB7XG4gIGVuY29kZShcbiAgICBtZXNzYWdlOiBIaXN0b3J5UlBDLFxuICAgIHdyaXRlcjogX20wLldyaXRlciA9IF9tMC5Xcml0ZXIuY3JlYXRlKClcbiAgKTogX20wLldyaXRlciB7XG4gICAgaWYgKG1lc3NhZ2UucmVxdWVzdElkICE9PSAnJykge1xuICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UucmVxdWVzdElkKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgSGlzdG9yeVF1ZXJ5LmVuY29kZShtZXNzYWdlLnF1ZXJ5LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgIH1cbiAgICBpZiAobWVzc2FnZS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBIaXN0b3J5UmVzcG9uc2UuZW5jb2RlKFxuICAgICAgICBtZXNzYWdlLnJlc3BvbnNlLFxuICAgICAgICB3cml0ZXIudWludDMyKDI2KS5mb3JrKClcbiAgICAgICkubGRlbGltKCk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXI7XG4gIH0sXG5cbiAgZGVjb2RlKGlucHV0OiBfbTAuUmVhZGVyIHwgVWludDhBcnJheSwgbGVuZ3RoPzogbnVtYmVyKTogSGlzdG9yeVJQQyB7XG4gICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBfbTAuUmVhZGVyID8gaW5wdXQgOiBuZXcgX20wLlJlYWRlcihpbnB1dCk7XG4gICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VIaXN0b3J5UlBDKCk7XG4gICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIG1lc3NhZ2UucXVlcnkgPSBIaXN0b3J5UXVlcnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIG1lc3NhZ2UucmVzcG9uc2UgPSBIaXN0b3J5UmVzcG9uc2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxuXG4gIGZyb21KU09OKG9iamVjdDogYW55KTogSGlzdG9yeVJQQyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcXVlc3RJZDogaXNTZXQob2JqZWN0LnJlcXVlc3RJZCkgPyBTdHJpbmcob2JqZWN0LnJlcXVlc3RJZCkgOiAnJyxcbiAgICAgIHF1ZXJ5OiBpc1NldChvYmplY3QucXVlcnkpXG4gICAgICAgID8gSGlzdG9yeVF1ZXJ5LmZyb21KU09OKG9iamVjdC5xdWVyeSlcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICByZXNwb25zZTogaXNTZXQob2JqZWN0LnJlc3BvbnNlKVxuICAgICAgICA/IEhpc3RvcnlSZXNwb25zZS5mcm9tSlNPTihvYmplY3QucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG4gIH0sXG5cbiAgdG9KU09OKG1lc3NhZ2U6IEhpc3RvcnlSUEMpOiB1bmtub3duIHtcbiAgICBjb25zdCBvYmo6IGFueSA9IHt9O1xuICAgIG1lc3NhZ2UucmVxdWVzdElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5yZXF1ZXN0SWQgPSBtZXNzYWdlLnJlcXVlc3RJZCk7XG4gICAgbWVzc2FnZS5xdWVyeSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAob2JqLnF1ZXJ5ID0gbWVzc2FnZS5xdWVyeVxuICAgICAgICA/IEhpc3RvcnlRdWVyeS50b0pTT04obWVzc2FnZS5xdWVyeSlcbiAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgIG1lc3NhZ2UucmVzcG9uc2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgKG9iai5yZXNwb25zZSA9IG1lc3NhZ2UucmVzcG9uc2VcbiAgICAgICAgPyBIaXN0b3J5UmVzcG9uc2UudG9KU09OKG1lc3NhZ2UucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gb2JqO1xuICB9LFxuXG4gIGZyb21QYXJ0aWFsPEkgZXh0ZW5kcyBFeGFjdDxEZWVwUGFydGlhbDxIaXN0b3J5UlBDPiwgST4+KFxuICAgIG9iamVjdDogSVxuICApOiBIaXN0b3J5UlBDIHtcbiAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUhpc3RvcnlSUEMoKTtcbiAgICBtZXNzYWdlLnJlcXVlc3RJZCA9IG9iamVjdC5yZXF1ZXN0SWQgPz8gJyc7XG4gICAgbWVzc2FnZS5xdWVyeSA9XG4gICAgICBvYmplY3QucXVlcnkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucXVlcnkgIT09IG51bGxcbiAgICAgICAgPyBIaXN0b3J5UXVlcnkuZnJvbVBhcnRpYWwob2JqZWN0LnF1ZXJ5KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBtZXNzYWdlLnJlc3BvbnNlID1cbiAgICAgIG9iamVjdC5yZXNwb25zZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5yZXNwb25zZSAhPT0gbnVsbFxuICAgICAgICA/IEhpc3RvcnlSZXNwb25zZS5mcm9tUGFydGlhbChvYmplY3QucmVzcG9uc2UpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9LFxufTtcblxuZGVjbGFyZSB2YXIgc2VsZjogYW55IHwgdW5kZWZpbmVkO1xuZGVjbGFyZSB2YXIgd2luZG93OiBhbnkgfCB1bmRlZmluZWQ7XG5kZWNsYXJlIHZhciBnbG9iYWw6IGFueSB8IHVuZGVmaW5lZDtcbnZhciBnbG9iYWxUaGlzOiBhbnkgPSAoKCkgPT4ge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZ2xvYmFsVGhpcztcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHNlbGY7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHdpbmRvdztcbiAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZ2xvYmFsO1xuICB0aHJvdyAnVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0Jztcbn0pKCk7XG5cbmNvbnN0IGF0b2I6IChiNjQ6IHN0cmluZykgPT4gc3RyaW5nID1cbiAgZ2xvYmFsVGhpcy5hdG9iIHx8XG4gICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdiaW5hcnknKSk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYmluID0gYXRvYihiNjQpO1xuICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5jb25zdCBidG9hOiAoYmluOiBzdHJpbmcpID0+IHN0cmluZyA9XG4gIGdsb2JhbFRoaXMuYnRvYSB8fFxuICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sICdiaW5hcnknKS50b1N0cmluZygnYmFzZTY0JykpO1xuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycjogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIGNvbnN0IGJpbjogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCBieXRlIG9mIGFycikge1xuICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICB9XG4gIHJldHVybiBidG9hKGJpbi5qb2luKCcnKSk7XG59XG5cbnR5cGUgQnVpbHRpbiA9XG4gIHwgRGF0ZVxuICB8IEZ1bmN0aW9uXG4gIHwgVWludDhBcnJheVxuICB8IHN0cmluZ1xuICB8IG51bWJlclxuICB8IGJvb2xlYW5cbiAgfCB1bmRlZmluZWQ7XG5cbmV4cG9ydCB0eXBlIERlZXBQYXJ0aWFsPFQ+ID0gVCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBUXG4gIDogVCBleHRlbmRzIEFycmF5PGluZmVyIFU+XG4gID8gQXJyYXk8RGVlcFBhcnRpYWw8VT4+XG4gIDogVCBleHRlbmRzIFJlYWRvbmx5QXJyYXk8aW5mZXIgVT5cbiAgPyBSZWFkb25seUFycmF5PERlZXBQYXJ0aWFsPFU+PlxuICA6IFQgZXh0ZW5kcyB7fVxuICA/IHsgW0sgaW4ga2V5b2YgVF0/OiBEZWVwUGFydGlhbDxUW0tdPiB9XG4gIDogUGFydGlhbDxUPjtcblxudHlwZSBLZXlzT2ZVbmlvbjxUPiA9IFQgZXh0ZW5kcyBUID8ga2V5b2YgVCA6IG5ldmVyO1xuZXhwb3J0IHR5cGUgRXhhY3Q8UCwgSSBleHRlbmRzIFA+ID0gUCBleHRlbmRzIEJ1aWx0aW5cbiAgPyBQXG4gIDogUCAmIHsgW0sgaW4ga2V5b2YgUF06IEV4YWN0PFBbS10sIElbS10+IH0gJiBSZWNvcmQ8XG4gICAgICAgIEV4Y2x1ZGU8a2V5b2YgSSwgS2V5c09mVW5pb248UD4+LFxuICAgICAgICBuZXZlclxuICAgICAgPjtcblxuZnVuY3Rpb24gbG9uZ1RvTnVtYmVyKGxvbmc6IExvbmcpOiBudW1iZXIge1xuICBpZiAobG9uZy5ndChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpIHtcbiAgICB0aHJvdyBuZXcgZ2xvYmFsVGhpcy5FcnJvcignVmFsdWUgaXMgbGFyZ2VyIHRoYW4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVInKTtcbiAgfVxuICByZXR1cm4gbG9uZy50b051bWJlcigpO1xufVxuXG5pZiAoX20wLnV0aWwuTG9uZyAhPT0gTG9uZykge1xuICBfbTAudXRpbC5Mb25nID0gTG9uZyBhcyBhbnk7XG4gIF9tMC5jb25maWd1cmUoKTtcbn1cblxuZnVuY3Rpb24gaXNTZXQodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbiIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8qIChpZ25vcmVkKSAqLyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbi8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBfX3dlYnBhY2tfbW9kdWxlc19fO1xuXG4iLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmFtZE8gPSB7fTsiLCJ2YXIgZGVmZXJyZWQgPSBbXTtcbl9fd2VicGFja19yZXF1aXJlX18uTyA9IChyZXN1bHQsIGNodW5rSWRzLCBmbiwgcHJpb3JpdHkpID0+IHtcblx0aWYoY2h1bmtJZHMpIHtcblx0XHRwcmlvcml0eSA9IHByaW9yaXR5IHx8IDA7XG5cdFx0Zm9yKHZhciBpID0gZGVmZXJyZWQubGVuZ3RoOyBpID4gMCAmJiBkZWZlcnJlZFtpIC0gMV1bMl0gPiBwcmlvcml0eTsgaS0tKSBkZWZlcnJlZFtpXSA9IGRlZmVycmVkW2kgLSAxXTtcblx0XHRkZWZlcnJlZFtpXSA9IFtjaHVua0lkcywgZm4sIHByaW9yaXR5XTtcblx0XHRyZXR1cm47XG5cdH1cblx0dmFyIG5vdEZ1bGZpbGxlZCA9IEluZmluaXR5O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGRlZmVycmVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIFtjaHVua0lkcywgZm4sIHByaW9yaXR5XSA9IGRlZmVycmVkW2ldO1xuXHRcdHZhciBmdWxmaWxsZWQgPSB0cnVlO1xuXHRcdGZvciAodmFyIGogPSAwOyBqIDwgY2h1bmtJZHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdGlmICgocHJpb3JpdHkgJiAxID09PSAwIHx8IG5vdEZ1bGZpbGxlZCA+PSBwcmlvcml0eSkgJiYgT2JqZWN0LmtleXMoX193ZWJwYWNrX3JlcXVpcmVfXy5PKS5ldmVyeSgoa2V5KSA9PiAoX193ZWJwYWNrX3JlcXVpcmVfXy5PW2tleV0oY2h1bmtJZHNbal0pKSkpIHtcblx0XHRcdFx0Y2h1bmtJZHMuc3BsaWNlKGotLSwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmdWxmaWxsZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYocHJpb3JpdHkgPCBub3RGdWxmaWxsZWQpIG5vdEZ1bGZpbGxlZCA9IHByaW9yaXR5O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihmdWxmaWxsZWQpIHtcblx0XHRcdGRlZmVycmVkLnNwbGljZShpLS0sIDEpXG5cdFx0XHR2YXIgciA9IGZuKCk7XG5cdFx0XHRpZiAociAhPT0gdW5kZWZpbmVkKSByZXN1bHQgPSByO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiLy8gbm8gYmFzZVVSSVxuXG4vLyBvYmplY3QgdG8gc3RvcmUgbG9hZGVkIGFuZCBsb2FkaW5nIGNodW5rc1xuLy8gdW5kZWZpbmVkID0gY2h1bmsgbm90IGxvYWRlZCwgbnVsbCA9IGNodW5rIHByZWxvYWRlZC9wcmVmZXRjaGVkXG4vLyBbcmVzb2x2ZSwgcmVqZWN0LCBQcm9taXNlXSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbnZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG5cdFwianMtd2FrdVwiOiAwXG59O1xuXG4vLyBubyBjaHVuayBvbiBkZW1hbmQgbG9hZGluZ1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLk8uaiA9IChjaHVua0lkKSA9PiAoaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID09PSAwKTtcblxuLy8gaW5zdGFsbCBhIEpTT05QIGNhbGxiYWNrIGZvciBjaHVuayBsb2FkaW5nXG52YXIgd2VicGFja0pzb25wQ2FsbGJhY2sgPSAocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24sIGRhdGEpID0+IHtcblx0dmFyIFtjaHVua0lkcywgbW9yZU1vZHVsZXMsIHJ1bnRpbWVdID0gZGF0YTtcblx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG5cdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuXHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwO1xuXHRpZihjaHVua0lkcy5zb21lKChpZCkgPT4gKGluc3RhbGxlZENodW5rc1tpZF0gIT09IDApKSkge1xuXHRcdGZvcihtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcblx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYocnVudGltZSkgdmFyIHJlc3VsdCA9IHJ1bnRpbWUoX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdH1cblx0aWYocGFyZW50Q2h1bmtMb2FkaW5nRnVuY3Rpb24pIHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKGRhdGEpO1xuXHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuXHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSAmJiBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcblx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSgpO1xuXHRcdH1cblx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZHNbaV1dID0gMDtcblx0fVxuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHJlc3VsdCk7XG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSB0aGlzW1wid2VicGFja0NodW5ranN3YWt1XCJdID0gdGhpc1tcIndlYnBhY2tDaHVua2pzd2FrdVwiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBkZXBlbmRzIG9uIG90aGVyIGxvYWRlZCBjaHVua3MgYW5kIGV4ZWN1dGlvbiBuZWVkIHRvIGJlIGRlbGF5ZWRcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXy5PKHVuZGVmaW5lZCwgW1widmVuZG9yc1wiXSwgKCkgPT4gKF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbmRleC50c1wiKSkpXG5fX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXy5PKF9fd2VicGFja19leHBvcnRzX18pO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9