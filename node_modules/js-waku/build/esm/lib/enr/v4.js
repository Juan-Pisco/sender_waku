var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import crypto from 'crypto';
import { keccak256 } from 'js-sha3';
import * as secp256k1 from 'secp256k1';
import { createNodeId } from './create';
export function hash(input) {
    return Buffer.from(keccak256.arrayBuffer(input));
}
export function createPrivateKey() {
    return __awaiter(this, void 0, void 0, function* () {
        return Buffer.from(yield randomBytes(32));
    });
}
export function publicKey(privKey) {
    return Buffer.from(secp256k1.publicKeyCreate(privKey));
}
export function sign(privKey, msg) {
    const { signature } = secp256k1.ecdsaSign(hash(msg), privKey);
    return Buffer.from(signature);
}
export function verify(pubKey, msg, sig) {
    // Remove the recovery id if present (byte #65)
    return secp256k1.ecdsaVerify(sig.slice(0, 64), hash(msg), pubKey);
}
export function nodeId(pubKey) {
    const uncompressedPubkey = secp256k1.publicKeyConvert(pubKey, false);
    return createNodeId(hash(uncompressedPubkey.slice(1)));
}
export class ENRKeyPair {
    constructor(nodeId, privateKey, publicKey) {
        this.nodeId = nodeId;
        this.privateKey = privateKey;
        this.publicKey = publicKey;
    }
    static create(privateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (privateKey) {
                if (!secp256k1.privateKeyVerify(privateKey)) {
                    throw new Error('Invalid private key');
                }
            }
            const _privateKey = privateKey || (yield createPrivateKey());
            const _publicKey = publicKey(_privateKey);
            const _nodeId = nodeId(_publicKey);
            return new ENRKeyPair(_nodeId, _privateKey, _publicKey);
        });
    }
    sign(msg) {
        return sign(this.privateKey, msg);
    }
    verify(msg, sig) {
        return verify(this.publicKey, msg, sig);
    }
}
function randomBytes(length) {
    if (typeof window !== 'undefined' && window && window.crypto) {
        const array = new Uint8Array(length);
        window.crypto.getRandomValues(array);
        return array;
    }
    else {
        return crypto.randomBytes(length);
    }
}
//# sourceMappingURL=v4.js.map