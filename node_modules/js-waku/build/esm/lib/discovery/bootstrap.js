var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import debug from 'debug';
import { Multiaddr } from 'multiaddr';
import { DnsNodeDiscovery } from './dns';
import { getNodesFromHostedJson, getPseudoRandomSubset } from './index';
const dbg = debug('waku:discovery:bootstrap');
/**
 * Parse options and expose function to return bootstrap peer addresses.
 */
export class Bootstrap {
    constructor(opts) {
        var _a;
        const maxPeers = (_a = opts.maxPeers) !== null && _a !== void 0 ? _a : Bootstrap.DefaultMaxPeers;
        if (opts.default) {
            dbg('Use hosted list of peers.');
            this.getBootstrapPeers = getNodesFromHostedJson.bind({}, undefined, undefined, maxPeers);
        }
        else if (opts.peers !== undefined && opts.peers.length > 0) {
            dbg('Use provided list of peers.');
            const allPeers = opts.peers.map((node) => new Multiaddr(node));
            const peers = getPseudoRandomSubset(allPeers, maxPeers);
            this.getBootstrapPeers = () => Promise.resolve(peers);
        }
        else if (typeof opts.getPeers === 'function') {
            dbg('Bootstrap: Use provided getPeers function.');
            const getPeers = opts.getPeers;
            this.getBootstrapPeers = () => __awaiter(this, void 0, void 0, function* () {
                const allPeers = yield getPeers();
                return getPseudoRandomSubset(allPeers, maxPeers).map((node) => new Multiaddr(node));
            });
        }
        else if (opts.enrUrl) {
            const enrUrl = opts.enrUrl;
            dbg('Use provided EIP-1459 ENR Tree URL.');
            const dns = DnsNodeDiscovery.dnsOverHttp();
            this.getBootstrapPeers = () => __awaiter(this, void 0, void 0, function* () {
                const enrs = yield dns.getPeers(maxPeers, [enrUrl]);
                dbg(`Found ${enrs.length} peers`);
                return enrs.map((enr) => enr.getFullMultiaddrs()).flat();
            });
        }
        else {
            dbg('No bootstrap method specified, no peer will be returned');
            this.getBootstrapPeers = undefined;
        }
    }
}
Bootstrap.DefaultMaxPeers = 1;
//# sourceMappingURL=bootstrap.js.map