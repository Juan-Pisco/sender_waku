var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * GET list of nodes from remote HTTP host.
 *
 * Default behavior is to return nodes hosted by Status.
 *
 * @param path The property path to access the node list. The result should be
 * a string, a string array or an object. If the result is an object then the
 * values of the objects are used as multiaddresses. For example, if the GET
 * request returns `{ foo: { bar: [address1, address2] } }` then `path` should be
 * `[ "foo", "bar" ]`.
 * @param url Remote host containing bootstrap peers in JSON format.
 * @param wantedNumber The number of connections desired. Defaults to [DefaultWantedNumber].
 *
 * @returns An array of multiaddresses.
 * @throws If the remote host is unreachable or the response cannot be parsed
 * according to the passed _path_.
 */
import axios from 'axios';
import debug from 'debug';
import { Multiaddr } from 'multiaddr';
import { getPseudoRandomSubset } from './index';
const dbg = debug('waku:discovery');
const DefaultWantedNumber = 1;
export function getNodesFromHostedJson(path = ['fleets', 'wakuv2.prod', 'waku-websocket'], url = 'https://fleets.status.im/', wantedNumber = DefaultWantedNumber) {
    return __awaiter(this, void 0, void 0, function* () {
        if (wantedNumber <= 0) {
            return [];
        }
        const res = yield axios.get(url, {
            headers: { 'Content-Type': 'application/json' },
        });
        let nodes = res.data;
        for (const prop of path) {
            if (nodes[prop] === undefined) {
                dbg(`Failed to retrieve bootstrap nodes: ${prop} does not exist on `, nodes);
                throw `Failed to retrieve bootstrap nodes: ${prop} does not exist on ${JSON.stringify(nodes)}`;
            }
            nodes = nodes[prop];
        }
        if (Array.isArray(nodes)) {
            return getPseudoRandomSubset(nodes, wantedNumber).map((node) => new Multiaddr(node));
        }
        if (typeof nodes === 'string') {
            return [new Multiaddr(nodes)];
        }
        if (typeof nodes === 'object') {
            nodes = Object.values(nodes);
            nodes = nodes.map((node) => new Multiaddr(node));
            return getPseudoRandomSubset(nodes, wantedNumber);
        }
        throw `Failed to retrieve bootstrap nodes: response format is not supported: ${JSON.stringify(nodes)}`;
    });
}
//# sourceMappingURL=hosted_json.js.map