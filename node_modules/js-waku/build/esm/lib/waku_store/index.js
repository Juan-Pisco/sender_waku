var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import debug from 'debug';
import concat from 'it-concat';
import lp from 'it-length-prefixed';
import pipe from 'it-pipe';
import { HistoryResponse_Error } from '../../proto';
import { getPeersForProtocol, selectRandomPeer } from '../select_peer';
import { hexToBuf } from '../utils';
import { DefaultPubSubTopic } from '../waku';
import { WakuMessage } from '../waku_message';
import { HistoryRPC, PageDirection } from './history_rpc';
const dbg = debug('waku:store');
export const StoreCodec = '/vac/waku/store/2.0.0-beta3';
export const DefaultPageSize = 10;
export { PageDirection };
/**
 * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).
 */
export class WakuStore {
    constructor(libp2p, options) {
        this.libp2p = libp2p;
        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
            this.pubSubTopic = options.pubSubTopic;
        }
        else {
            this.pubSubTopic = DefaultPubSubTopic;
        }
        this.decryptionKeys = new Map();
    }
    /**
     * Do a History Query to a Waku Store.
     *
     * @param contentTopics The content topics to pass to the query, leave empty to
     * retrieve all messages.
     *
     * @throws If not able to reach a Waku Store peer to query
     * or if an error is encountered when processing the reply.
     */
    queryHistory(contentTopics, options) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let startTime, endTime;
            if (options === null || options === void 0 ? void 0 : options.timeFilter) {
                startTime = options.timeFilter.startTime.getTime() / 1000;
                endTime = options.timeFilter.endTime.getTime() / 1000;
            }
            const opts = Object.assign({
                pubSubTopic: this.pubSubTopic,
                pageDirection: PageDirection.BACKWARD,
                pageSize: DefaultPageSize,
            }, options, {
                startTime,
                endTime,
            }, { contentTopics });
            dbg('Querying history with the following options', options);
            let peer;
            if (opts.peerId) {
                peer = this.libp2p.peerStore.get(opts.peerId);
                if (!peer)
                    throw `Failed to retrieve connection details for provided peer in peer store: ${opts.peerId.toB58String()}`;
            }
            else {
                peer = this.randomPeer;
                if (!peer)
                    throw 'Failed to find known peer that registers waku store protocol';
            }
            if (!peer.protocols.includes(StoreCodec))
                throw `Peer does not register waku store protocol: ${peer.id.toB58String()}`;
            const connection = this.libp2p.connectionManager.get(peer.id);
            if (!connection)
                throw 'Failed to get a connection to the peer';
            const decryptionKeys = Array.from(this.decryptionKeys).map(([key, { method, contentTopics }]) => {
                return {
                    key,
                    method,
                    contentTopics,
                };
            });
            // Add the decryption keys passed to this function against the
            // content topics also passed to this function.
            if (opts.decryptionKeys) {
                opts.decryptionKeys.forEach((key) => {
                    decryptionKeys.push({
                        key: hexToBuf(key),
                        contentTopics: contentTopics.length ? contentTopics : undefined,
                        method: undefined,
                    });
                });
            }
            const messages = [];
            let cursor = undefined;
            while (true) {
                const { stream } = yield connection.newStream(StoreCodec);
                const queryOpts = Object.assign(opts, { cursor });
                const historyRpcQuery = HistoryRPC.createQuery(queryOpts);
                dbg('Querying store peer', connection.remoteAddr.toString());
                const res = yield pipe([historyRpcQuery.encode()], lp.encode(), stream, lp.decode(), concat);
                const reply = HistoryRPC.decode(res.slice());
                const response = reply.response;
                if (!response) {
                    throw 'History response misses response field';
                }
                if (response.error &&
                    response.error === HistoryResponse_Error.ERROR_INVALID_CURSOR) {
                    throw 'History response contains an Error: INVALID CURSOR';
                }
                if (!response.messages || !response.messages.length) {
                    // No messages left (or stored)
                    console.log('No messages present in HistoryRPC response');
                    return messages;
                }
                dbg(`${response.messages.length} messages retrieved for pubsub topic ${opts.pubSubTopic}`);
                const pageMessages = [];
                yield Promise.all(response.messages.map((protoMsg) => __awaiter(this, void 0, void 0, function* () {
                    const msg = yield WakuMessage.decodeProto(protoMsg, decryptionKeys);
                    if (msg) {
                        messages.push(msg);
                        pageMessages.push(msg);
                    }
                })));
                let abort = false;
                if (opts.callback) {
                    abort = Boolean(opts.callback(pageMessages));
                }
                const responsePageSize = (_a = response.pagingInfo) === null || _a === void 0 ? void 0 : _a.pageSize;
                const queryPageSize = (_c = (_b = historyRpcQuery.query) === null || _b === void 0 ? void 0 : _b.pagingInfo) === null || _c === void 0 ? void 0 : _c.pageSize;
                if (abort ||
                    // Response page size smaller than query, meaning this is the last page
                    (responsePageSize && queryPageSize && responsePageSize < queryPageSize)) {
                    return messages;
                }
                cursor = (_d = response.pagingInfo) === null || _d === void 0 ? void 0 : _d.cursor;
                if (cursor === undefined) {
                    // If the server does not return cursor then there is an issue,
                    // Need to abort or we end up in an infinite loop
                    console.log('No cursor returned by peer.');
                    return messages;
                }
            }
        });
    }
    /**
     * Register a decryption key to attempt decryption of messages received in any
     * subsequent [[queryHistory]] call. This can either be a private key for
     * asymmetric encryption or a symmetric key. [[WakuStore]] will attempt to
     * decrypt messages using both methods.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.decryptionKeys.set(hexToBuf(key), options !== null && options !== void 0 ? options : {});
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received in subsequent [[queryHistory]] calls.
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.decryptionKeys.delete(hexToBuf(key));
    }
    /**
     * Returns known peers from the address book (`libp2p.peerStore`) that support
     * store protocol. Waku may or  may not be currently connected to these peers.
     */
    get peers() {
        return getPeersForProtocol(this.libp2p, StoreCodec);
    }
    /**
     * Returns a random peer that supports store protocol from the address
     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to
     * this peer.
     */
    get randomPeer() {
        return selectRandomPeer(this.peers);
    }
}
//# sourceMappingURL=index.js.map