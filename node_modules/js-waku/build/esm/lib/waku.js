var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Noise } from '@chainsafe/libp2p-noise/dist/src/noise';
import debug from 'debug';
import Libp2p from 'libp2p';
import Libp2pBootstrap from 'libp2p-bootstrap';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
import Mplex from 'libp2p-mplex';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
import Websockets from 'libp2p-websockets';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: No types available
import filters from 'libp2p-websockets/src/filters';
import Ping from 'libp2p/src/ping';
import { multiaddr } from 'multiaddr';
import PeerId from 'peer-id';
import { Bootstrap } from './discovery';
import { getPeersForProtocol } from './select_peer';
import { LightPushCodec, WakuLightPush } from './waku_light_push';
import { WakuMessage } from './waku_message';
import { RelayCodecs, WakuRelay } from './waku_relay';
import { RelayPingContentTopic } from './waku_relay/constants';
import { StoreCodec, WakuStore } from './waku_store';
const websocketsTransportKey = Websockets.prototype[Symbol.toStringTag];
export const DefaultPingKeepAliveValueSecs = 0;
export const DefaultRelayKeepAliveValueSecs = 5 * 60;
/**
 * DefaultPubSubTopic is the default gossipsub topic to use for Waku.
 */
export const DefaultPubSubTopic = '/waku/2/default-waku/proto';
const dbg = debug('waku:waku');
export class Waku {
    constructor(options, libp2p, store, lightPush) {
        var _a;
        this.libp2p = libp2p;
        this.relay = libp2p.pubsub;
        this.store = store;
        this.lightPush = lightPush;
        this.pingKeepAliveTimers = {};
        this.relayKeepAliveTimers = {};
        const pingKeepAlive = options.pingKeepAlive || DefaultPingKeepAliveValueSecs;
        const relayKeepAlive = options.relayKeepAlive || DefaultRelayKeepAliveValueSecs;
        libp2p.connectionManager.on('peer:connect', (connection) => {
            this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);
        });
        libp2p.connectionManager.on('peer:disconnect', (connection) => {
            this.stopKeepAlive(connection.remotePeer);
        });
        (_a = options === null || options === void 0 ? void 0 : options.decryptionKeys) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
            this.addDecryptionKey(key);
        });
    }
    /**
     * Create new waku node
     *
     * @param options Takes the same options than `Libp2p`.
     */
    static create(options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // Get an object in case options or libp2p are undefined
            const libp2pOpts = Object.assign({}, options === null || options === void 0 ? void 0 : options.libp2p);
            // Default for Websocket filter is `all`:
            // Returns all TCP and DNS based addresses, both with ws or wss.
            libp2pOpts.config = Object.assign({
                transport: {
                    [websocketsTransportKey]: {
                        filter: filters.all,
                    },
                },
            }, (_a = options === null || options === void 0 ? void 0 : options.libp2p) === null || _a === void 0 ? void 0 : _a.config);
            // Pass pubsub topic to relay
            if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {
                libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);
            }
            libp2pOpts.modules = Object.assign({}, (_b = options === null || options === void 0 ? void 0 : options.libp2p) === null || _b === void 0 ? void 0 : _b.modules);
            // Default transport for libp2p is Websockets
            libp2pOpts.modules = Object.assign({
                transport: [Websockets],
            }, (_c = options === null || options === void 0 ? void 0 : options.libp2p) === null || _c === void 0 ? void 0 : _c.modules);
            // streamMuxer, connection encryption and pubsub are overridden
            // as those are the only ones currently supported by Waku nodes.
            libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                streamMuxer: [Mplex],
                connEncryption: [new Noise(options === null || options === void 0 ? void 0 : options.staticNoiseKey)],
                pubsub: WakuRelay,
            });
            if (options === null || options === void 0 ? void 0 : options.bootstrap) {
                const bootstrap = new Bootstrap(options === null || options === void 0 ? void 0 : options.bootstrap);
                if (bootstrap.getBootstrapPeers !== undefined) {
                    try {
                        const list = yield bootstrap.getBootstrapPeers();
                        // Note: this overrides any other peer discover
                        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {
                            peerDiscovery: [Libp2pBootstrap],
                        });
                        libp2pOpts.config.peerDiscovery = {
                            [Libp2pBootstrap.tag]: {
                                list,
                                enabled: true,
                            },
                        };
                    }
                    catch (e) {
                        dbg('Failed to retrieve bootstrap nodes', e);
                    }
                }
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore: modules property is correctly set thanks to voodoo
            const libp2p = yield Libp2p.create(libp2pOpts);
            const wakuStore = new WakuStore(libp2p, {
                pubSubTopic: options === null || options === void 0 ? void 0 : options.pubSubTopic,
            });
            const wakuLightPush = new WakuLightPush(libp2p);
            yield libp2p.start();
            return new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush);
        });
    }
    /**
     * Dials to the provided peer.
     *
     * @param peer The peer to dial
     */
    dial(peer) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.libp2p.dialProtocol(peer, [StoreCodec].concat(RelayCodecs));
        });
    }
    /**
     * Add peer to address book, it will be auto-dialed in the background.
     */
    addPeerToAddressBook(peerId, multiaddrs) {
        let peer;
        if (typeof peerId === 'string') {
            peer = PeerId.createFromB58String(peerId);
        }
        else {
            peer = peerId;
        }
        const addresses = multiaddrs.map((addr) => {
            if (typeof addr === 'string') {
                return multiaddr(addr);
            }
            else {
                return addr;
            }
        });
        this.libp2p.peerStore.addressBook.set(peer, addresses);
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.libp2p.stop();
        });
    }
    /**
     * Register a decryption key to attempt decryption of messages received via
     * [[WakuRelay]] and [[WakuStore]]. This can either be a private key for
     * asymmetric encryption or a symmetric key.
     *
     * Strings must be in hex format.
     */
    addDecryptionKey(key, options) {
        this.relay.addDecryptionKey(key, options);
        this.store.addDecryptionKey(key, options);
    }
    /**
     * Delete a decryption key that was used to attempt decryption of messages
     * received via [[WakuRelay]] or [[WakuStore]].
     *
     * Strings must be in hex format.
     */
    deleteDecryptionKey(key) {
        this.relay.deleteDecryptionKey(key);
        this.store.deleteDecryptionKey(key);
    }
    /**
     * Return the local multiaddr with peer id on which libp2p is listening.
     * @throws if libp2p is not listening on localhost
     */
    getLocalMultiaddrWithID() {
        const localMultiaddr = this.libp2p.multiaddrs.find((addr) => addr.toString().match(/127\.0\.0\.1/));
        if (!localMultiaddr || localMultiaddr.toString() === '') {
            throw 'Not listening on localhost';
        }
        return localMultiaddr + '/p2p/' + this.libp2p.peerId.toB58String();
    }
    /**
     * Wait to be connected to a peer. Useful when using the [[CreateOptions.bootstrap]]
     * with [[Waku.create]]. The Promise resolves only once we are connected to a
     * Store peer, Relay peer and Light Push peer.
     */
    waitForConnectedPeer() {
        return __awaiter(this, void 0, void 0, function* () {
            const desiredProtocols = [[StoreCodec], [LightPushCodec], RelayCodecs];
            yield Promise.all(desiredProtocols.map((desiredProtocolVersions) => {
                const peers = new Array();
                desiredProtocolVersions.forEach((proto) => {
                    getPeersForProtocol(this.libp2p, proto).forEach((peer) => peers.push(peer));
                });
                if (peers.length > 0) {
                    return Promise.resolve();
                }
                else {
                    // No peer available for this protocol, waiting to connect to one.
                    return new Promise((resolve) => {
                        this.libp2p.peerStore.on('change:protocols', ({ protocols: connectedPeerProtocols }) => {
                            desiredProtocolVersions.forEach((desiredProto) => {
                                if (connectedPeerProtocols.includes(desiredProto)) {
                                    dbg('Resolving for', desiredProto, connectedPeerProtocols);
                                    resolve();
                                }
                            });
                        });
                    });
                }
            }));
        });
    }
    startKeepAlive(peerId, pingPeriodSecs, relayPeriodSecs) {
        // Just in case a timer already exist for this peer
        this.stopKeepAlive(peerId);
        const peerIdStr = peerId.toB58String();
        if (pingPeriodSecs !== 0) {
            this.pingKeepAliveTimers[peerIdStr] = setInterval(() => {
                Ping(this.libp2p, peerId);
            }, pingPeriodSecs * 1000);
        }
        if (relayPeriodSecs !== 0) {
            this.relayKeepAliveTimers[peerIdStr] = setInterval(() => {
                WakuMessage.fromBytes(new Uint8Array(), RelayPingContentTopic).then((wakuMsg) => this.relay.send(wakuMsg));
            }, relayPeriodSecs * 1000);
        }
    }
    stopKeepAlive(peerId) {
        const peerIdStr = peerId.toB58String();
        if (this.pingKeepAliveTimers[peerIdStr]) {
            clearInterval(this.pingKeepAliveTimers[peerIdStr]);
            delete this.pingKeepAliveTimers[peerIdStr];
        }
        if (this.relayKeepAliveTimers[peerIdStr]) {
            clearInterval(this.relayKeepAliveTimers[peerIdStr]);
            delete this.relayKeepAliveTimers[peerIdStr];
        }
    }
}
//# sourceMappingURL=waku.js.map