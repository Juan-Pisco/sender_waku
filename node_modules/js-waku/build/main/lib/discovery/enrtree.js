"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ENRTree = void 0;
const assert_1 = __importDefault(require("assert"));
const base64url_1 = __importDefault(require("base64url"));
const base32 = __importStar(require("hi-base32"));
const secp256k1_1 = require("secp256k1");
const enr_1 = require("../enr");
const utils_1 = require("../utils");
class ENRTree {
    /**
     * Extracts the branch subdomain referenced by a DNS tree root string after verifying
     * the root record signature with its base32 compressed public key.
     */
    static parseAndVerifyRoot(root, publicKey) {
        assert_1.default(root.startsWith(this.ROOT_PREFIX), `ENRTree root entry must start with '${this.ROOT_PREFIX}'`);
        const rootValues = ENRTree.parseRootValues(root);
        const decodedPublicKey = base32.decode.asBytes(publicKey);
        // The signature is a 65-byte secp256k1 over the keccak256 hash
        // of the record content, excluding the `sig=` part, encoded as URL-safe base64 string
        // (Trailing recovery bit must be trimmed to pass `ecdsaVerify` method)
        const signedComponent = root.split(' sig')[0];
        const signedComponentBuffer = Buffer.from(signedComponent);
        const signatureBuffer = base64url_1.default
            .toBuffer(rootValues.signature)
            .slice(0, 64);
        const keyBuffer = Buffer.from(decodedPublicKey);
        const isVerified = secp256k1_1.ecdsaVerify(signatureBuffer, utils_1.keccak256Buf(signedComponentBuffer), keyBuffer);
        assert_1.default(isVerified, 'Unable to verify ENRTree root signature');
        return rootValues.eRoot;
    }
    static parseRootValues(txt) {
        const matches = txt.match(/^enrtree-root:v1 e=([^ ]+) l=([^ ]+) seq=(\d+) sig=([^ ]+)$/);
        assert_1.default.ok(Array.isArray(matches), 'Could not parse ENRTree root entry');
        matches.shift(); // The first entry is the full match
        const [eRoot, lRoot, seq, signature] = matches;
        assert_1.default.ok(eRoot, "Could not parse 'e' value from ENRTree root entry");
        assert_1.default.ok(lRoot, "Could not parse 'l' value from ENRTree root entry");
        assert_1.default.ok(seq, "Could not parse 'seq' value from ENRTree root entry");
        assert_1.default.ok(signature, "Could not parse 'sig' value from ENRTree root entry");
        return { eRoot, lRoot, seq: Number(seq), signature };
    }
    /**
     * Returns the public key and top level domain of an ENR tree entry.
     * The domain is the starting point for traversing a set of linked DNS TXT records
     * and the public key is used to verify the root entry record
     */
    static parseTree(tree) {
        assert_1.default(tree.startsWith(this.TREE_PREFIX), `ENRTree tree entry must start with '${this.TREE_PREFIX}'`);
        const matches = tree.match(/^enrtree:\/\/([^@]+)@(.+)$/);
        assert_1.default.ok(Array.isArray(matches), 'Could not parse ENRTree tree entry');
        matches.shift(); // The first entry is the full match
        const [publicKey, domain] = matches;
        assert_1.default.ok(publicKey, 'Could not parse public key from ENRTree tree entry');
        assert_1.default.ok(domain, 'Could not parse domain from ENRTree tree entry');
        return { publicKey, domain };
    }
    /**
     * Returns subdomains listed in an ENR branch entry. These in turn lead to
     * either further branch entries or ENR records.
     */
    static parseBranch(branch) {
        assert_1.default(branch.startsWith(this.BRANCH_PREFIX), `ENRTree branch entry must start with '${this.BRANCH_PREFIX}'`);
        return branch.split(this.BRANCH_PREFIX)[1].split(',');
    }
}
exports.ENRTree = ENRTree;
ENRTree.RECORD_PREFIX = enr_1.ENR.RECORD_PREFIX;
ENRTree.TREE_PREFIX = 'enrtree:';
ENRTree.BRANCH_PREFIX = 'enrtree-branch:';
ENRTree.ROOT_PREFIX = 'enrtree-root:';
//# sourceMappingURL=enrtree.js.map