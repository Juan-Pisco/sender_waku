"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DnsNodeDiscovery = void 0;
const assert_1 = __importDefault(require("assert"));
const debug_1 = require("debug");
const enr_1 = require("../enr");
const dns_over_https_1 = require("./dns_over_https");
const enrtree_1 = require("./enrtree");
const dbg = debug_1.debug('waku:discovery:dns');
class DnsNodeDiscovery {
    constructor(dns) {
        this._errorTolerance = 10;
        this._DNSTreeCache = {};
        this.dns = dns;
    }
    static dnsOverHttp(endpoints) {
        const dnsClient = new dns_over_https_1.DnsOverHttps(endpoints);
        return new DnsNodeDiscovery(dnsClient);
    }
    /**
     * Returns a list of verified peers listed in an EIP-1459 DNS tree. Method may
     * return fewer peers than requested if `maxQuantity` is larger than the number
     * of ENR records or the number of errors/duplicate peers encountered by randomized
     * search exceeds `maxQuantity` plus the `errorTolerance` factor.
     */
    async getPeers(maxQuantity, enrTreeUrls) {
        let totalSearches = 0;
        const peers = [];
        const networkIndex = Math.floor(Math.random() * enrTreeUrls.length);
        const { publicKey, domain } = enrtree_1.ENRTree.parseTree(enrTreeUrls[networkIndex]);
        while (peers.length < maxQuantity &&
            totalSearches < maxQuantity + this._errorTolerance) {
            const context = {
                domain,
                publicKey,
                visits: {},
            };
            const peer = await this._search(domain, context);
            if (peer && isNewPeer(peer, peers)) {
                peers.push(peer);
                dbg(`got new peer candidate from DNS address=${peer.nodeId}@${peer.ip}`);
            }
            totalSearches++;
        }
        return peers;
    }
    /**
     * Runs a recursive, randomized descent of the DNS tree to retrieve a single
     * ENR record as an ENR. Returns null if parsing or DNS resolution fails.
     */
    async _search(subdomain, context) {
        const entry = await this._getTXTRecord(subdomain, context);
        context.visits[subdomain] = true;
        let next;
        let branches;
        const entryType = getEntryType(entry);
        try {
            switch (entryType) {
                case enrtree_1.ENRTree.ROOT_PREFIX:
                    next = enrtree_1.ENRTree.parseAndVerifyRoot(entry, context.publicKey);
                    return await this._search(next, context);
                case enrtree_1.ENRTree.BRANCH_PREFIX:
                    branches = enrtree_1.ENRTree.parseBranch(entry);
                    next = selectRandomPath(branches, context);
                    return await this._search(next, context);
                case enrtree_1.ENRTree.RECORD_PREFIX:
                    return enr_1.ENR.decodeTxt(entry);
                default:
                    return null;
            }
        }
        catch (error) {
            dbg(`Failed to search DNS tree ${entryType} at subdomain ${subdomain}: ${error}`);
            return null;
        }
    }
    /**
     * Retrieves the TXT record stored at a location from either
     * this DNS tree cache or via DNS query
     */
    async _getTXTRecord(subdomain, context) {
        if (this._DNSTreeCache[subdomain]) {
            return this._DNSTreeCache[subdomain];
        }
        // Location is either the top level tree entry host or a subdomain of it.
        const location = subdomain !== context.domain
            ? `${subdomain}.${context.domain}`
            : context.domain;
        const response = await this.dns.resolveTXT(location);
        assert_1.default(response.length, 'Received empty result array while fetching TXT record');
        assert_1.default(response[0].length, 'Received empty TXT record');
        // Branch entries can be an array of strings of comma delimited subdomains, with
        // some subdomain strings split across the array elements
        const result = response.join('');
        this._DNSTreeCache[subdomain] = result;
        return result;
    }
}
exports.DnsNodeDiscovery = DnsNodeDiscovery;
function getEntryType(entry) {
    if (entry.startsWith(enrtree_1.ENRTree.ROOT_PREFIX))
        return enrtree_1.ENRTree.ROOT_PREFIX;
    if (entry.startsWith(enrtree_1.ENRTree.BRANCH_PREFIX))
        return enrtree_1.ENRTree.BRANCH_PREFIX;
    if (entry.startsWith(enrtree_1.ENRTree.RECORD_PREFIX))
        return enrtree_1.ENRTree.RECORD_PREFIX;
    return '';
}
/**
 * Returns a randomly selected subdomain string from the list provided by a branch
 * entry record.
 *
 * The client must track subdomains which are already resolved to avoid
 * going into an infinite loop b/c branch entries can contain
 * circular references. It’s in the client’s best interest to traverse the
 * tree in random order.
 */
function selectRandomPath(branches, context) {
    // Identify domains already visited in this traversal of the DNS tree.
    // Then filter against them to prevent cycles.
    const circularRefs = {};
    for (const [idx, subdomain] of branches.entries()) {
        if (context.visits[subdomain]) {
            circularRefs[idx] = true;
        }
    }
    // If all possible paths are circular...
    if (Object.keys(circularRefs).length === branches.length) {
        throw new Error('Unresolvable circular path detected');
    }
    // Randomly select a viable path
    let index;
    do {
        index = Math.floor(Math.random() * branches.length);
    } while (circularRefs[index]);
    return branches[index];
}
/**
 * @returns false if candidate peer already exists in the
 *         current collection of peers based on the node id value;
 *         true otherwise.
 */
function isNewPeer(peer, peers) {
    if (!peer || !peer.nodeId)
        return false;
    for (const existingPeer of peers) {
        if (peer.nodeId === existingPeer.nodeId) {
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=dns.js.map