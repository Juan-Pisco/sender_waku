/// <reference types="node" />
import { Multiaddr } from 'multiaddr';
import PeerId from 'peer-id';
import { IKeypair, KeypairType } from './keypair';
import { ENRKey, ENRValue, NodeId, SequenceNumber } from './types';
export declare class ENR extends Map<ENRKey, ENRValue> {
    static readonly RECORD_PREFIX = "enr:";
    seq: SequenceNumber;
    signature: Buffer | null;
    constructor(kvs?: Record<ENRKey, ENRValue>, seq?: SequenceNumber, signature?: Buffer | null);
    static createV4(publicKey: Buffer, kvs?: Record<ENRKey, ENRValue>): ENR;
    static createFromPeerId(peerId: PeerId, kvs?: Record<ENRKey, ENRValue>): ENR;
    static decodeFromValues(decoded: Buffer[]): ENR;
    static decode(encoded: Buffer): ENR;
    static decodeTxt(encoded: string): ENR;
    set(k: ENRKey, v: ENRValue): this;
    get id(): string;
    get keypairType(): KeypairType;
    get publicKey(): Buffer;
    get keypair(): IKeypair;
    get peerId(): PeerId;
    get nodeId(): NodeId;
    get ip(): string | undefined;
    set ip(ip: string | undefined);
    get tcp(): number | undefined;
    set tcp(port: number | undefined);
    get udp(): number | undefined;
    set udp(port: number | undefined);
    get ip6(): string | undefined;
    set ip6(ip: string | undefined);
    get tcp6(): number | undefined;
    set tcp6(port: number | undefined);
    get udp6(): number | undefined;
    set udp6(port: number | undefined);
    /**
     * Get the `multiaddrs` field from ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of [[getLocationMultiaddr]] should be preferred.
     *
     * The multiaddresses stored in this field are expected to be location multiaddresses, ie, peer id less.
     */
    get multiaddrs(): Multiaddr[] | undefined;
    /**
     * Set the `multiaddrs` field on the ENR.
     *
     * This field is used to store multiaddresses that cannot be stored with the current ENR pre-defined keys.
     * These can be a multiaddresses that include encapsulation (e.g. wss) or do not use `ip4` nor `ip6` for the host
     * address (e.g. `dns4`, `dnsaddr`, etc)..
     *
     * If the peer information only contains information that can be represented with the ENR pre-defined keys
     * (ip, tcp, etc) then the usage of [[setLocationMultiaddr]] should be preferred.
     *
     * The multiaddresses stored in this field must to be location multiaddresses, ie, peer id less.
     */
    set multiaddrs(multiaddrs: Multiaddr[] | undefined);
    getLocationMultiaddr(protocol: 'udp' | 'udp4' | 'udp6' | 'tcp' | 'tcp4' | 'tcp6'): Multiaddr | undefined;
    setLocationMultiaddr(multiaddr: Multiaddr): void;
    /**
     * Returns the full multiaddr from the ENR fields matching the provided
     * `protocol` parameter.
     * To return full multiaddrs from the `multiaddrs` ENR field,
     * use [[ENR.getFullMultiaddrs]]
     *
     * @param protocol
     */
    getFullMultiaddr(protocol: 'udp' | 'udp4' | 'udp6' | 'tcp' | 'tcp4' | 'tcp6'): Multiaddr | undefined;
    /**
     * Returns the full multiaddrs from the `multiaddrs` ENR field.
     */
    getFullMultiaddrs(): Multiaddr[];
    verify(data: Buffer, signature: Buffer): boolean;
    sign(data: Buffer, privateKey: Buffer): Buffer;
    encodeToValues(privateKey?: Buffer): (ENRKey | ENRValue | number)[];
    encode(privateKey?: Buffer): Buffer;
    encodeTxt(privateKey?: Buffer): string;
}
